<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Why‘s The Desigin on huizhou92&#39;s Blog</title>
        <link>https://huizhou92.com/categories/whys-the-desigin/</link>
        <description>Recent content in Why‘s The Desigin on huizhou92&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>Copyright © 2023 huizhou92</copyright>
        <lastBuildDate>Fri, 28 Jun 2024 16:33:50 +0800</lastBuildDate><atom:link href="https://huizhou92.com/categories/whys-the-desigin/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Why TCP requires three handshakes to establish a connection</title>
        <link>https://huizhou92.com/p/why-tcp-requires-three-handshakes-to-establish-a-connection/</link>
        <pubDate>Fri, 28 Jun 2024 16:33:50 +0800</pubDate>
        
        <guid>https://huizhou92.com/p/why-tcp-requires-three-handshakes-to-establish-a-connection/</guid>
        <description>&lt;p&gt;TCP protocol is a network protocol that we encounter almost every day. The majority of network connections are established based on the TCP protocol. People who have studied computer networks or have some understanding of the TCP protocol know that establishing a connection using TCP requires a three-way handshake.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This article is first published in the medium MPP plan. If you are a medium user, please follow me in &lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;medium&lt;/a&gt;. Thank you very much.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/c680b2ef5dc88552c1838e5bf7f1ba65.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20240517205741&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;If we briefly explain the process of establishing a TCP connection, many people who have prepared for interviews would be familiar with it. However, when it comes to delving into the question of “Why does TCP require a three-way handshake to establish a connection?” most people would not be able to answer this question or might provide incorrect answers. This article will discuss why we need a three-way handshake to establish a TCP connection instead of four or two.&lt;/p&gt;
&lt;h1 id=&#34;overview&#34;&gt;Overview
&lt;/h1&gt;&lt;p&gt;Before analyzing the question at hand, let’s first address a common misconception that has misled many people regarding the TCP connection process. For a long time, the author of this article also believed that it provided a good explanation for why a TCP connection requires a three-way handshake:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ndash;&amp;gt; Can you hear me?&lt;br&gt;
&amp;lt;&amp;ndash; I can hear you. Can you hear me?&lt;br&gt;
&amp;ndash;&amp;gt; I can hear you too.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Using analogies to explain a problem often leads to a situation where “nine out of ten analogies are wrong.” If someone uses an analogy to answer your “why” question, you need to carefully consider the flaws in their analogy. Analogies can only provide a partial similarity, and we can never find an absolutely correct analogy. Analogies are only useful when we want to present the characteristics of something in a simple and understandable way. In the rest of the article, we will explain why this analogy is flawed, and readers can read the remaining content with this question in mind.&lt;/p&gt;
&lt;p&gt;When many people try to answer or think about this question, they tend to focus on the “three” in the three-way handshake, which is indeed important. However, if we reexamine the question, do we really understand what a “connection” is? Only when we know the definition of a “connection” can we attempt to answer why TCP requires a three-way handshake.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream. The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;The &lt;a class=&#34;link&#34; href=&#34;https://tools.ietf.org/html/rfc793&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RFC 793 — Transmission Control Protocol&lt;/a&gt; document clearly defines what a connection is in TCP. In summary, a connection is the information used to ensure reliability and flow control mechanisms, including sockets, sequence numbers, and window sizes.&lt;/p&gt;
&lt;p&gt;Therefore, establishing a TCP connection means that the two parties involved in communication need to reach a consensus on the three types of information mentioned above. A pair of sockets in a connection is composed of an Internet address identifier and a port. The window size is mainly used for flow control, and the sequence number is used to track the sequence of data packets sent by the initiating party, allowing the receiving party to confirm the successful receipt of a particular data packet based on the sequence number.&lt;/p&gt;
&lt;p&gt;At this point, we have transformed the original question into “Why do we need a three-way handshake to initialize sockets, window sizes, and initial sequence numbers?” Next, we will analyze and seek explanations for this refined question.&lt;/p&gt;
&lt;h1 id=&#34;design&#34;&gt;Design
&lt;/h1&gt;&lt;p&gt;This article will mainly discuss why we need a three-way handshake to initialize sockets, window sizes, initial sequence numbers, and establish a TCP connection from the following aspects:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A three-way handshake is required to prevent the initialization of duplicate historical connections.&lt;/li&gt;
&lt;li&gt;A three-way handshake is required to initialize the initial sequence numbers of both communicating parties.&lt;/li&gt;
&lt;li&gt;Discuss the possibility of establishing a connection with a different number of handshakes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Among these arguments, the first one is the primary reason why TCP chooses to use a three-way handshake. The other reasons are secondary in comparison. We discuss them here to provide a more comprehensive perspective and understand this interesting design decision from multiple angles.&lt;/p&gt;
&lt;h1 id=&#34;historical-connections&#34;&gt;Historical Connections
&lt;/h1&gt;&lt;p&gt;The &lt;a class=&#34;link&#34; href=&#34;https://tools.ietf.org/html/rfc793&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RFC 793 — Transmission Control Protocol&lt;/a&gt; clearly points out the primary reason why TCP uses a three-way handshake: to prevent confusion caused by the initiation of old duplicate connections.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/6679e5256608619c68d265cab45e3c3c.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img for geeksforgeeks.org&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Imagine this scenario: if the number of communications between the two parties is only two, once the sender sends a connection establishment request, it cannot retract this request. In a complex or poor network condition, if the sender continuously sends multiple connection establishment requests and TCP establishes a connection with only two communications, the receiver can only choose to accept or reject the sender’s request. The receiver is not sure whether this request is an expired connection due to network congestion.&lt;/p&gt;
&lt;p&gt;Therefore, TCP chooses to use a three-way handshake to establish a connection and introduces the &lt;code&gt;RST&lt;/code&gt; control message. When the receiver receives the request, it sends the sender&amp;rsquo;s &lt;code&gt;SEQ+1&lt;/code&gt; as part of the &lt;code&gt;ACK&lt;/code&gt; control message. At this point, the sender can determine whether the current connection is a historical connection:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the current connection is a historical connection, meaning the &lt;code&gt;SEQ&lt;/code&gt; has expired or timed out, the sender will directly send an &lt;code&gt;RST&lt;/code&gt; control message to terminate this connection.&lt;/li&gt;
&lt;li&gt;If the current connection is not a historical connection, the sender will send an &lt;code&gt;ACK&lt;/code&gt; control message, and the two parties will successfully establish a connection.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By using a three-way handshake and the &lt;code&gt;RST&lt;/code&gt; control message, the ultimate control over whether to establish a connection is given to the sender. Only the sender has enough context to determine if the current connection is erroneous or expired. This is also the primary reason why TCP uses a three-way handshake to establish a connection.&lt;/p&gt;
&lt;h1 id=&#34;initial-sequence-numbers&#34;&gt;Initial Sequence Numbers
&lt;/h1&gt;&lt;p&gt;Another important reason for using a three-way handshake is that both communicating parties need to obtain an initial sequence number for sending information. As a reliable transport layer protocol, TCP needs to build a reliable transport layer in an unstable network environment. The uncertainty of the network can lead to issues such as packet loss and out-of-order delivery. Common problems may include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Data packets being repeatedly sent by the sender, resulting in duplicate data.&lt;/li&gt;
&lt;li&gt;Data packets being lost during transmission due to routing or other network nodes.&lt;/li&gt;
&lt;li&gt;Data packets arriving at the receiver may not be in the order they were sent.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To address these potential issues, the TCP protocol requires the sender to include a “sequence number” field in the data packet. With the sequence number corresponding to each data packet, we can:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The receiver can deduplicate repeated data packets based on the sequence number.&lt;/li&gt;
&lt;li&gt;The sender will resend the corresponding data packet until it is acknowledged.&lt;/li&gt;
&lt;li&gt;The receiver can reorder the data packets based on their sequence numbers.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sequence numbers play a crucial role in TCP connections, and the initial sequence number, as part of a TCP connection, needs to be initialized during the three-way handshake. Since both parties in a TCP connection need to obtain the initial sequence number, they need to send a &lt;code&gt;SYN&lt;/code&gt; control message to each other, carrying their expected initial sequence number &lt;code&gt;SEQ&lt;/code&gt;. Upon receiving the &lt;code&gt;SYN&lt;/code&gt; message, the receiver will confirm it using the &lt;code&gt;ACK&lt;/code&gt; control message and &lt;code&gt;SEQ+1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;As shown in the above diagram, the two TCPs, A and B, send &lt;code&gt;SYN&lt;/code&gt; and &lt;code&gt;ACK&lt;/code&gt; control messages to each other. After both parties obtain their expected initial sequence numbers, they can start communication. Due to the design of the TCP message header, we can combine the two middle communications into one. TCP B can send both the &lt;code&gt;ACK&lt;/code&gt; and &lt;code&gt;SYN&lt;/code&gt; control messages to TCP A simultaneously, reducing the four communications to three.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;A three-way handshake is necessary because sequence numbers are not tied to a global clock in the network, and TCPs may have different mechanisms for picking the ISN’s. The receiver of the first SYN has no way of knowing whether the segment was an old delayed one or not unless it remembers the last sequence number used on the connection (which is not always possible), and so it must ask the sender to verify this SYN. The three-way handshake and the advantages of a clock-driven scheme are discussed in [3].&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Furthermore, as a distributed system, the network does not have a global clock for counting. TCP can initialize sequence numbers using different mechanisms. As the receiver of a TCP connection, we cannot determine if the initial sequence number received from the other party is expired. Therefore, we need the other party to make this determination. It is not practical for the receiver to save and verify the sequence numbers, which reinforces the point we made in the previous section — avoiding the initialization of historical wrong connections.&lt;/p&gt;
&lt;h1 id=&#34;number-of-communications&#34;&gt;Number of Communications
&lt;/h1&gt;&lt;p&gt;When discussing the number of communications required to establish a TCP connection, we often focus on why it takes three communications instead of two or four. Discussing using more communications to establish a connection is often meaningless because we can always “exchange the same information using more communications.” Therefore, it is technically possible to establish a connection using four, five, or even more communications.&lt;/p&gt;
&lt;p&gt;The issue of increasing the number of communications in a TCP connection often does not require discussion. What we pursue is actually completing the information exchange with the fewest number of communications (the theoretical minimum). This is why we repeatedly emphasize in the previous sections that using a “two-way handshake” cannot establish a TCP connection, and using a three-way handshake is the minimum number of communications required to establish a connection.&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion
&lt;/h1&gt;&lt;p&gt;In this article, we discussed why TCP requires a three-way handshake to establish a connection. Before analyzing this question in detail, we first reconsidered what a TCP connection is. The &lt;a class=&#34;link&#34; href=&#34;https://tools.ietf.org/html/rfc793&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RFC 793 — Transmission Control Protocol — IETF Tools&lt;/a&gt; provides a clear definition of a TCP connection — the data used for ensuring reliability and flow control mechanisms, including sockets, sequence numbers, and window sizes.&lt;/p&gt;
&lt;p&gt;The three-way handshake in TCP can effectively prevent the initiation of erroneous historical connections and reduce unnecessary resource consumption for both communicating parties. The three-way handshake helps both parties obtain the initial sequence numbers, ensuring that data packets are transmitted without duplication or loss and maintaining their order. At this point, it is clear why “two-way handshake” and “four-way handshake” are not used:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“Two-way handshake”: It cannot prevent the initialization of erroneous historical connections and wastes resources for the receiver.&lt;/li&gt;
&lt;li&gt;“Four-way handshake”: The design of the TCP protocol allows us to simultaneously transmit both the &lt;code&gt;ACK&lt;/code&gt; and &lt;code&gt;SYN&lt;/code&gt; control messages, reducing the number of communications. Therefore, there is no need to use more communications to transmit the same information.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Returning to the question raised at the beginning of the article, why is using an analogy to explain TCP’s three-way handshake incorrect? This is mainly because the analogy does not clearly explain the core issue — avoiding the initialization of historical duplicate connections.&lt;/p&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://tools.ietf.org/html/rfc793&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RFC 793 — Transmission Control Protocol — IETF Tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://networkengineering.stackexchange.com/questions/24068/why-do-we-need-a-3-way-handshake-why-not-just-2-way&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Why do we need a 3-way handshake? Why not just 2-way?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/tcp-3-way-handshake-process/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;# TCP 3-Way Handshake Process&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Why Did Google Choose To Implement gRPC Using HTTP/2?</title>
        <link>https://huizhou92.com/p/why-did-google-choose-to-implement-grpc-using-http2/</link>
        <pubDate>Thu, 23 May 2024 10:18:54 +0800</pubDate>
        
        <guid>https://huizhou92.com/p/why-did-google-choose-to-implement-grpc-using-http2/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;https://images.unsplash.com/photo-1427104227401-94b390b378b0?ixid=M3wzNjAwOTd8MHwxfHNlYXJjaHw4NHx8aHR0cHxlbnwwfDB8fHwxNzM1MTk0Mzc2fDA&amp;amp;ixlib=rb-4.0.3&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;woman with blue nails reading ipad&#34;
	
	
&gt;&lt;/p&gt;
&lt;div style=&#34;text-align: center;&#34;&gt;
      &lt;a href=&#34;https://unsplash.com/photos/woman-holding-white-ipad-CPWhnIkL4Lk&#34;&gt;Backlink&lt;/a&gt; | |Photo by &lt;a href=&#34;https://unsplash.com/@annademy?utm_source=Obsidian%20Image%20Inserter%20Plugin&amp;utm_medium=referral&#34;&gt;Anna Demianenko&lt;/a&gt; on &lt;a href=&#34;https://unsplash.com/?utm_source=Obsidian%20Image%20Inserter%20Plugin&amp;utm_medium=referral&#34;&gt;Unsplash&lt;/a&gt;
      &lt;/div&gt;
&lt;h2 id=&#34;background&#34;&gt;Background
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://grpc.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gRPC&lt;/a&gt; is an open-source high-performance RPC framework developed by Google. The design goal of gRPC is to run in any environment, supporting pluggable load balancing, tracing, health checking, and authentication. It not only supports service calls within and across data centers but is also suitable for the last mile of distributed computing, connecting devices, mobile applications, and browsers to backend services. For more on the motivation and principles behind gRPC&amp;rsquo;s design, refer to this article: &lt;a class=&#34;link&#34; href=&#34;https://grpc.io/blog/principles&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gRPC Motivation and Design Principles&lt;/a&gt;.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;blockquote&gt;
&lt;p&gt;This article is first published in the medium MPP plan. If you are a medium user, please follow me in &lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;medium&lt;/a&gt;. Thank you very much.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Key points from the official article:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Internally, there is a framework called Stubby, but it is not based on any standard.&lt;/li&gt;
&lt;li&gt;Supports use in any environment, including IoT, mobile, and browsers.&lt;/li&gt;
&lt;li&gt;Supports streaming and flow control.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In reality, performance is not the primary goal of gRPC design. So why choose HTTP/2?&lt;/p&gt;
&lt;h2 id=&#34;what-is-http2&#34;&gt;What is HTTP/2
&lt;/h2&gt;&lt;p&gt;Before discussing why gRPC chose HTTP/2, let&amp;rsquo;s briefly understand HTTP/2.&lt;br&gt;
HTTP/2 can be simply introduced with an image:&lt;br&gt;
&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/ae09920e853bee0b21be83f8e770ba01.svg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;https://hpbn.co/&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;From: &lt;a class=&#34;link&#34; href=&#34;https://hpbn.co/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://hpbn.co/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The header in HTTP/1 corresponds to the HEADERS frame in HTTP/2.&lt;/li&gt;
&lt;li&gt;The payload in HTTP/1 corresponds to the DATA frame in HTTP/2.&lt;br&gt;
In the Chrome browser, open &lt;code&gt;chrome://net-internals/#http2&lt;/code&gt; to see information about HTTP/2 connections.&lt;br&gt;
&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/01dd6bce8fde7de2b3a8f9ee06158978.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;chrome-http2&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Many websites are already running on HTTP/2.&lt;/p&gt;
&lt;h2 id=&#34;grpc-over-http2&#34;&gt;gRPC Over HTTP/2
&lt;/h2&gt;&lt;p&gt;Strictly speaking, gRPC is designed in layers, with the underlying layer supporting different protocols. Currently, gRPC supports:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gRPC over HTTP2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gRPC Web&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;However, most discussions are based on gRPC over HTTP2. Let&amp;rsquo;s look at a real gRPC &lt;code&gt;SayHello&lt;/code&gt; request and see how it is implemented over HTTP/2 using Wireshark:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/40be952445bf4ec323071035fcf9da88.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;wireshark-grpc&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;You can see the following headers:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Header: :authority: localhost:50051
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Header: :path: /helloworld.Greeter/SayHello
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Header: :method: POST
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Header: :scheme: http
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Header: content-type: application/grpc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Header: user-agent: grpc-java-netty/1.11.0  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Then the request parameters are in the DATA frame:&lt;br&gt;
&lt;code&gt;GRPC Message: /helloworld.Greeter/SayHello, Request&lt;/code&gt;&lt;br&gt;
In short, gRPC puts metadata in HTTP/2 Headers and serialized request parameters in the DATA frame.&lt;/p&gt;
&lt;h2 id=&#34;advantages-of-http2-protocol&#34;&gt;Advantages of HTTP/2 Protocol
&lt;/h2&gt;&lt;h3 id=&#34;http2-is-an-open-standard&#34;&gt;HTTP/2 Is an Open Standard
&lt;/h3&gt;&lt;p&gt;Google thought this through and chose not to open-source its internal Stubby but to create something new. As technology becomes more open, the space for proprietary protocols is shrinking.&lt;/p&gt;
&lt;h3 id=&#34;http2-is-a-proven-standard&#34;&gt;HTTP/2 Is a Proven Standard
&lt;/h3&gt;&lt;p&gt;HTTP/2 was developed based on practical experience, which is crucial. Many unsuccessful standards were created by a group of vendors before implementation, leading to chaos and unusability, such as CORBA. HTTP/2&amp;rsquo;s predecessor was Google&amp;rsquo;s &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/SPDY&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;SPDY&lt;/a&gt;. Without Google&amp;rsquo;s practice and promotion, HTTP/2 might not exist.&lt;/p&gt;
&lt;h3 id=&#34;http2-naturally-supports-iot-mobile-and-browsers&#34;&gt;HTTP/2 Naturally Supports IoT, Mobile, and Browsers
&lt;/h3&gt;&lt;p&gt;In fact, mobile phones and mobile browsers were the first to adopt HTTP/2. The mobile internet has driven the development and adoption of HTTP/2.&lt;/p&gt;
&lt;h3 id=&#34;multi-language-implementation-of-http2-is-easy&#34;&gt;Multi-language Implementation of HTTP/2 is Easy
&lt;/h3&gt;&lt;p&gt;Discussing only the implementation of the protocol itself, without considering serialization:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Every popular programming language has a mature HTTP/2 Client.&lt;/li&gt;
&lt;li&gt;HTTP/2 Clients are well-tested and reliable.&lt;/li&gt;
&lt;li&gt;Sending HTTP/2 requests with a Client is much easier than sending/receiving packets with sockets.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http2-supports-stream-and-flow-control&#34;&gt;HTTP/2 Supports Stream and Flow Control
&lt;/h3&gt;&lt;p&gt;There are many streaming solutions in the industry, such as those based on WebSocket or &lt;a class=&#34;link&#34; href=&#34;https://github.com/rsocket/rsocket&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;rsocket&lt;/a&gt;. However, these solutions are not universal.&lt;br&gt;
Streams in HTTP/2 can also be prioritized, which might be used in complex scenarios, although less frequently in RPC.&lt;/p&gt;
&lt;h3 id=&#34;easy-support-for-http2-in-gatewayproxy&#34;&gt;Easy Support for HTTP/2 in Gateway/Proxy
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Nginx support for gRPC: &lt;a class=&#34;link&#34; href=&#34;https://www.nginx.com/blog/nginx-1-13-10-grpc/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.nginx.com/blog/nginx-1-13-10-grpc/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Envoy support for gRPC: &lt;a class=&#34;link&#34; href=&#34;https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/grpc#&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/grpc#&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http2-ensures-security&#34;&gt;HTTP/2 Ensures Security
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;HTTP/2 naturally supports SSL, although gRPC can run on a clear text protocol (i.e., unencrypted).&lt;/li&gt;
&lt;li&gt;Many proprietary RPC protocols might wrap a layer of TLS support, making it very complex to use. Do developers have enough security knowledge? Are users configuring it correctly? Can operators understand it correctly?&lt;/li&gt;
&lt;li&gt;HTTP/2 ensures secure transmission over public networks. For example, the &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/CRIME&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CRIME attack&lt;/a&gt; is hard to prevent in proprietary protocols.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mature-authentication-in-http2&#34;&gt;Mature Authentication in HTTP/2
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Authentication systems developed from HTTP/1 are mature and can be seamlessly used in HTTP/2.&lt;/li&gt;
&lt;li&gt;End-to-end authentication from front-end to back-end without any conversion or adaptation.&lt;br&gt;
For example, traditional RPC like Dubbo requires writing a Dubbo filter and considering how to pass authentication-related information through thread local. The RPC protocol itself also needs to support it. In short, it&amp;rsquo;s very complex. In fact, most RPCs in companies do not have authentication and can be called freely.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;disadvantages-of-http2-protocol&#34;&gt;Disadvantages of HTTP/2 Protocol
&lt;/h2&gt;&lt;h3 id=&#34;inefficient-transmission-of-rpc-metadata&#34;&gt;Inefficient Transmission of RPC Metadata
&lt;/h3&gt;&lt;p&gt;Although HPAC can compress HTTP Headers, for RPC, determining a function call can be simplified to an int. Once negotiated between both ends, it can be directly looked up in a table, without the need for HPAC encoding and decoding.&lt;br&gt;
Consider optimizing an HTTP/2 parser specifically for gRPC to reduce some general processing and improve performance.&lt;/p&gt;
&lt;h3 id=&#34;grpc-calls-in-http2-require-two-decodings&#34;&gt;gRPC Calls in HTTP/2 Require Two Decodings
&lt;/h3&gt;&lt;p&gt;One for the HEADERS frame and one for the DATA frame.&lt;/p&gt;
&lt;p&gt;The HTTP/2 standard itself only allows one TCP connection, but in practice, gRPC may have multiple TCP connections, which needs attention during use.&lt;br&gt;
Choosing HTTP/2 for gRPC means its performance won&amp;rsquo;t be top-notch. &lt;strong&gt;But for RPC, moderate QPS is acceptable&lt;/strong&gt;, and generality and compatibility are the most important. Refer to the official benchmark: &lt;a class=&#34;link&#34; href=&#34;https://grpc.io/docs/guides/benchmarking.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://grpc.io/docs/guides/benchmarking.html&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/hank-whu/rpc-benchmark&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/hank-whu/rpc-benchmark&lt;/a&gt;&lt;br&gt;
If your scenario is to&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;googles-standard-setting-ability&#34;&gt;Google&amp;rsquo;s Standard-Setting Ability
&lt;/h2&gt;&lt;p&gt;In the past decade, Google&amp;rsquo;s ability to set standards has grown stronger. Here are some standards:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP/2&lt;/li&gt;
&lt;li&gt;WebP image format&lt;/li&gt;
&lt;li&gt;WebRTC for real-time communication&lt;/li&gt;
&lt;li&gt;VP9/AV1 video encoding standards&lt;/li&gt;
&lt;li&gt;Service Worker/PWA&lt;/li&gt;
&lt;li&gt;QUIC/HTTP/3&lt;br&gt;
Of course, Google doesn&amp;rsquo;t always succeed. Many initiatives it tried to push failed, such as Chrome&amp;rsquo;s Native Client.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;gRPC is currently the de facto standard in the Kubernetes ecosystem. Will gRPC become the RPC standard in more areas and larger fields?&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;why-grpc-emerged&#34;&gt;Why gRPC Emerged
&lt;/h2&gt;&lt;p&gt;Why did an HTTP/2-based RPC emerge?&lt;/p&gt;
&lt;p&gt;I believe an important reason is that in the trend of Cloud Native, the need for open interoperability inevitably leads to HTTP/2-based RPC. Even without gRPC, there would be other HTTP/2-based RPCs.&lt;/p&gt;
&lt;p&gt;gRPC was first used internally at Google on Google Cloud Platform and public APIs: &lt;a class=&#34;link&#34; href=&#34;https://opensource.google.com/projects/grpc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://opensource.google.com/projects/grpc&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary
&lt;/h2&gt;&lt;p&gt;Although gRPC may not replace internal RPC implementations, in an era of open interoperability, not just on Kubernetes, gRPC will have more and more stages to showcase its capabilities.&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://grpc.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://grpc.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://hpbn.co/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://hpbn.co/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://grpc.io/blog/loadbalancing&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://grpc.io/blog/loadbalancing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://http2.github.io/faq&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://http2.github.io/faq&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/grpc/grpc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/grpc/grpc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Why The Design :Why is the CPU slow to access the hard disk?</title>
        <link>https://huizhou92.com/p/why-the-design-why-is-the-cpu-slow-to-access-the-hard-disk/</link>
        <pubDate>Mon, 19 Feb 2024 03:02:00 +0000</pubDate>
        
        <guid>https://huizhou92.com/p/why-the-design-why-is-the-cpu-slow-to-access-the-hard-disk/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;https://cdn-images-1.medium.com/max/800/0*WaxXsYm3cXY_ZGVG&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Mechanical hard disk drives (HDD) and solid-state drives (SSD) are two of the most common types of hard drives. As external storage for computers, it takes a long time for the CPU to access the data stored on them. According to the table below, accessing 4KB of data randomly in an SSD takes 1,500 times longer than accessing main memory, while the seek time for a mechanical disk is 100,000 times longer than accessing main memory:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This article is first published in the medium MPP plan. If you are a medium user, please follow me in &lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;medium&lt;/a&gt;. Thank you very much.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn-images-1.medium.com/max/800/1*uPqEtBpV77g_KjSICrt0OA.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;em&gt;Latency Numbers Every Programmer Should Know&lt;/em&gt; &lt;a class=&#34;link&#34; href=&#34;https://gist.github.com/jboner/2841832&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;em&gt;https://gist.github.com/jboner/2841832&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Although the seek time for a disk is only 10 ms, it is already a very long time for the CPU. When we scale up the times mentioned above proportionally, we can intuitively feel the performance differences. For example, if accessing L1 cache takes 1 second for the CPU, accessing main memory would take 3 minutes, reading data randomly from an SSD would take 3.4 days, disk seek would take 2 months, and network transmission could take over a year.&lt;/p&gt;
&lt;p&gt;In computer architecture, hard disks are common input/output devices, and the operating system does not necessarily need a hard disk to start. It can start through a hard disk, a network device, or an external device. Therefore, a hard disk is not a necessary condition for computer operation.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn-images-1.medium.com/max/800/0*yyPSe13T7fXKL3lI.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;strong&gt;Input/Output Devices&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As an external input/output device, compared to CPU cache and memory, the slow read and write speed of a hard disk is reasonable. However, the several thousand to several hundred thousand times difference in speed does make it difficult to imagine or accept. In this article, we will analyze why accessing a hard disk is very slow for the CPU:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The process of CPU accessing data from a hard disk is complex. It first reads the data from the disk into memory through I/O operations and then accesses the data stored in memory.&lt;/li&gt;
&lt;li&gt;Mechanical hard disks rely on mechanical structures to access the data in the disk, which requires moving the mechanical arm of the disk.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;io-operations&#34;&gt;I/O Operations
&lt;/h1&gt;&lt;p&gt;In order for the CPU to access data from the disk, it must first read the data from the disk into memory through I/O operations, and then access the data stored in memory. There are three common types of I/O operations in computers: Programmed I/O, Interrupt-driven I/O, and Direct Memory Access (DMA). We will introduce these operations one by one:&lt;/p&gt;
&lt;p&gt;The simplest form of performing I/O operations is using &lt;em&gt;Programmed I/O&lt;/em&gt;. When using Programmed I/O, the CPU is responsible for all the work. For example, if we want to output “Hello World” on the screen, the CPU will write a new character to the I/O device each time, and after writing, it will poll the device’s status and wait for it to complete its work before writing a new character. This method is simple but it occupies all the CPU resources, which can cause serious waste of computing resources in some complex systems.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Interrupt-driven I/O&lt;/em&gt; is a more efficient way to perform I/O operations. In Programmed I/O, the CPU actively retrieves the device’s status and waits for the device to become idle. However, if Interrupt-driven I/O is used, the device will actively initiate an interrupt when it is idle, pause the current process, and save the context. The operating system will then execute the interrupt handler for the I/O device:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If there are no characters to be printed at the moment, the interrupt handler stops and resumes the paused process.&lt;/li&gt;
&lt;li&gt;If there are characters to be printed, the next character is copied to the device and the paused process is resumed.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Using Interrupt-driven I/O allows the CPU to handle other tasks when the device is busy, thus maximizing CPU utilization and avoiding wasting precious computing resources. Compared to Programmed I/O, Interrupt-driven I/O delegates some work to the I/O device, thereby improving resource utilization.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Direct Memory Access (DMA)&lt;/em&gt; uses a DMA controller to perform I/O operations. Interrupt-driven I/O requires triggering an operating system interrupt for each character, which consumes CPU time. When we use a DMA controller, the CPU reads all the data from the buffer into the DMA controller at once, and the DMA controller is responsible for writing the data to the I/O device character by character。 Although the DMA controller can free up the CPU and reduce the number of interrupts, its execution speed is much slower than the CPU. If the DMA controller cannot drive the I/O device quickly, the CPU may have to wait for the DMA controller to trigger an interrupt. In this case, Interrupt-driven I/O or even Programmed I/O can provide faster access speed.&lt;/p&gt;
&lt;p&gt;By default, we use a DMA controller to perform I/O tasks. However, Programmed I/O and Interrupt-driven I/O are also acceptable options. When the CPU frequently needs to wait for the DMA controller to perform I/O tasks, using Interrupt-driven I/O or even polling Programmed I/O can achieve higher throughput. However, regardless of the method used, I/O is a complex and time-consuming operation in the program.&lt;/p&gt;
&lt;h1 id=&#34;mechanical-hard-disk&#34;&gt;Mechanical Hard Disk
&lt;/h1&gt;&lt;p&gt;A mechanical hard disk drive (HDD) is an electronic, non-volatile mechanical data storage device. It uses magnetic storage to store and retrieve data on the disk. During the process of reading and writing data, the disk head connected to the mechanical arm of the hard disk reads and writes bits on the surface of the disk &lt;a class=&#34;link&#34; href=&#34;https://draveness.me/whys-the-design-cpu-and-disk//#fn:4&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Because the disk has a complex mechanical structure, reading and writing data on the disk takes a lot of time. The read and write performance of databases also depends on the performance of the disk. If we randomly query a piece of data in a database using a mechanical hard disk, it may trigger random I/O on the disk. However, it requires a significant cost to read data from the disk into memory. Loading data from a regular disk (non-SSD) involves processes such as queueing, seeking, rotating, and transferring data, which takes about 10 ms.&lt;/p&gt;
&lt;p&gt;When estimating the query performance of a database, we can use the order of magnitude of 10 ms to estimate the time occupied by random I/O. It is worth mentioning that random I/O has a significant impact on the query performance of databases. On the other hand, reading data sequentially from a disk can achieve a speed of up to 40 MB/s, which is several orders of magnitude faster. Therefore, we should try to minimize the number of random I/O operations in order to improve performance.&lt;/p&gt;
&lt;p&gt;A solid-state drive (SSD) is a computer storage device that uses flash memory as persistent storage. Unlike mechanical hard disks, SSDs do not contain any mechanical structures. When we read or write data using an SSD, no mechanical structures are involved because everything is done by circuits. Therefore, the read and write speed of an SSD is much faster than that of an HDD.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn-images-1.medium.com/max/800/0*Yw0ydv7zAqHbVrXZ.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Figure 5 — HDD and SSD Prices&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Since their inception, the prices of both mechanical hard disks and SSDs have been continuously decreasing. Mechanical hard disks are the main external storage used in data centers today. Most general-purpose commercial servers use mechanical hard disks as their main external storage. However, because the read and write speed of SSDs is tens of times faster than that of mechanical hard disks, more and more servers, especially databases, use SSDs as their external storage. However, as an external storage device with mechanical structures, it is susceptible to external interference when subjected to vibration.&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion
&lt;/h1&gt;&lt;p&gt;Hard disks are external storage devices in computers that can store large amounts of data persistently. However, the CPU cannot directly access the data on the hard disk. When a computer starts, the operating system loads the necessary data from the disk into memory for CPU access. But if the data the CPU wants to access is not in memory, it takes several thousand to several hundred thousand times longer to read the data. This is mainly due to the following two reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU needs to access data in external storage through I/O operations. The three methods of Programmed I/O, Interrupt-driven I/O, and DMA all incur additional overhead and consume a significant amount of CPU time.&lt;/li&gt;
&lt;li&gt;Mechanical hard disks access the data in the disk through mechanical structures. Each random I/O operation on the hard disk requires several processes such as queueing, seeking, rotating, and transferring data, which takes about 10 ms.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As mentioned in the article, a hard disk is not a necessary hardware device for computer operation. A computer can load the necessary data for startup from any external storage device such as a disk or CD-ROM into memory and start normally. However, hard disks are currently the most common external storage devices. In the end, let’s look at some open-ended questions related to the topic. Interested readers can carefully consider the following questions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Is data written to a hard disk always persistently stored without loss?&lt;/li&gt;
&lt;li&gt;Why is the data in memory cleared after a power outage and restart?&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;If you have any questions about the content of the article or want to learn more about the reasons behind some design decisions in software engineering, you can leave a comment below the blog post. The author will reply to related questions in a timely manner and select suitable topics for future content based on them&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;</description>
        </item>
        <item>
        <title>Why Does It Take Four Waves For TCP To Disconnect?</title>
        <link>https://huizhou92.com/p/why-does-it-take-four-waves-for-tcp-to-disconnect/</link>
        <pubDate>Thu, 01 Feb 2024 11:11:00 +0000</pubDate>
        
        <guid>https://huizhou92.com/p/why-does-it-take-four-waves-for-tcp-to-disconnect/</guid>
        <description>&lt;p&gt;TCP protocol is one of the network protocols we use in our daily lives. It is responsible for establishing and terminating connections. In the &lt;a class=&#34;link&#34; href=&#34;https://levelup.gitconnected.com/why-tcp-requires-three-handshakes-to-establish-a-connection-31d814aac6b8&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;previous&lt;/a&gt; blog post, we analyzed why TCP requires three handshakes to establish a connection. When establishing a connection, we need to ensure the issues of historical connections and sequence numbers. Unlike the three-way handshake during connection establishment, disconnecting a TCP connection requires a four-way handshake. This article will explore why TCP disconnects require a four-way handshake instead of three or any other number.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This article is first published in the medium MPP plan. If you are a medium user, please follow me in &lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;medium&lt;/a&gt;. Thank you very much.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/db19965682f215f42c5a8a03cd7f7b76.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Material from: history-computer.com&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;overview&#34;&gt;Overview
&lt;/h1&gt;&lt;p&gt;Before delving into why a four-way handshake is necessary, let’s first understand the process of TCP connection termination. Typically, when one party in the communication decides to terminate the connection, it sends a FIN (Finish) control message to the other party, indicating that it has no more data to send. The receiving party responds with an ACK (Acknowledgment) control message to acknowledge and enters a half-closed state, indicating that it will no longer send data but can still receive data. When the other party also has no more data to send, it sends a FIN message to indicate its intention to disconnect. The receiving party then sends another ACK message to confirm, and only then will the connection be fully closed.&lt;br&gt;
&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/b2b3a5d3921acfa31d009eab0f48e139.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;The Four-Way Handshake Process（ geeksforgeeks.org ）&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;design&#34;&gt;Design
&lt;/h1&gt;&lt;p&gt;Why does TCP disconnect require a four-way handshake? Let’s analyze this question from several aspects:&lt;/p&gt;
&lt;h1 id=&#34;ensuring-data-integrity&#34;&gt;Ensuring Data Integrity
&lt;/h1&gt;&lt;p&gt;TCP is a connection-oriented reliable transport protocol that guarantees data reliability and integrity. During connection termination, both parties may still have unsent or unacknowledged data packets. If only a three-way handshake is performed, the other party may not know whether the FIN message it sent has been received during the final handshake. This could result in the other party not fully receiving the data, leading to data loss. Therefore, by performing a four-way handshake, both parties can ensure that they receive each other’s data completely and maintain data integrity.&lt;/p&gt;
&lt;h1 id=&#34;handling-network-latency-and-packet-loss&#34;&gt;Handling Network Latency and Packet Loss
&lt;/h1&gt;&lt;p&gt;In a network, data packets may be delayed or lost due to network latency or packet loss. During connection termination, if only a three-way handshake is performed, the other party may not know whether the FIN message it sent has been received, which may prevent timely closure of the connection. By performing a four-way handshake, sufficient time is provided for the network to handle latency and packet loss issues, ensuring that the connection can be properly closed.&lt;/p&gt;
&lt;h1 id=&#34;waiting-for-unsent-data-to-be-sent&#34;&gt;Waiting for Unsent Data to Be Sent
&lt;/h1&gt;&lt;p&gt;During connection termination, both parties may still have unsent data packets. If only a three-way handshake is performed, the other party may not know whether there is any unsent data before sending the FIN message. By performing a four-way handshake, both parties have enough time to send and receive the remaining data, ensuring data integrity and correctness.&lt;/p&gt;
&lt;h1 id=&#34;handling-the-half-closed-state&#34;&gt;Handling the Half-Closed State
&lt;/h1&gt;&lt;p&gt;During the TCP connection termination process, one party enters a half-closed state by sending a FIN message, indicating that it will no longer send data but can still receive data. If only a three-way handshake is performed, the other party will immediately close the connection upon receiving the FIN message, which may prevent proper handling of the half-closed state. By performing a four-way handshake, both parties can ensure the correct handling of the half-closed state, avoiding data loss and confusion.&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion
&lt;/h1&gt;&lt;p&gt;Based on the analysis above, we can conclude that a four-way handshake is necessary for TCP disconnection to ensure data integrity, handle network latency and packet loss, wait for unsent data to be sent, and handle the half-closed state. Through the four-way handshake, both parties can better coordinate and handle the disconnection, ensuring the correct transmission of data and secure closure of the connection.&lt;/p&gt;
&lt;p&gt;When discussing TCP disconnection, we should not focus on why a four-way handshake is used, but rather understand why multiple handshakes are needed to ensure data integrity and proper connection closure. By gaining a deep understanding of TCP protocol design, we can better apply and comprehend the principles and mechanisms of network communication.&lt;/p&gt;
&lt;p&gt;Whether it is three handshakes or four handshakes, the first element of a tcp connection to consider is always security and data integrity, although it seems that three handshakes and four handshakes seem to be very inefficient, but the vast majority of Internet traffic is based on the tcp protocol, which is enough to prove that its reliability, on the issue of performance, there are other ways to optimize the performance of the protocol, such as udp, and later on, we will analyze how UDP and UDP-based QUIC protocol will affect the Internet in the next ten years. and how the UDP-based QUIC protocol will influence the next decade of the Internet.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;If you found my article enjoyable, feel free to follow me and give it a 👏. Your support would be greatly appreciated.&lt;/p&gt;
&lt;h1 id=&#34;references&#34;&gt;References
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://tools.ietf.org/html/rfc793&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RFC 793 — Transmission Control Protocol — IETF Tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://networkengineering.stackexchange.com/questions/24072/why-do-we-need-a-4-way-handshake-to-terminate-a-tcp-connection&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Why do we need a 4-way handshake to terminate a TCP connection?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/why-tcp-connect-termination-need-4-way-handshake&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;why-tcp-connect-termination-need-4-way-handshake&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        
    </channel>
</rss>
