<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>技术 on huizhou92&#39;s Blog</title>
        <link>https://huizhou92.com/zh-cn/categories/tech/</link>
        <description>Recent content in 技术 on huizhou92&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>Copyright © 2023 huizhou92</copyright>
        <lastBuildDate>Thu, 13 Nov 2025 16:58:54 +0800</lastBuildDate><atom:link href="https://huizhou92.com/zh-cn/categories/tech/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Go 1.26 黑科技：跳过 GC 直接释放内存，性能飙升 200%</title>
        <link>https://huizhou92.com/zh-cn/p/go-1.26-%E9%BB%91%E7%A7%91%E6%8A%80%E8%B7%B3%E8%BF%87-gc-%E7%9B%B4%E6%8E%A5%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E6%80%A7%E8%83%BD%E9%A3%99%E5%8D%87-200/</link>
        <pubDate>Thu, 13 Nov 2025 16:58:54 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/go-1.26-%E9%BB%91%E7%A7%91%E6%8A%80%E8%B7%B3%E8%BF%87-gc-%E7%9B%B4%E6%8E%A5%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E6%80%A7%E8%83%BD%E9%A3%99%E5%8D%87-200/</guid>
        <description>&lt;!-- more--&gt;
&lt;p&gt;最近，Go 语言社区围绕一个全新的内存管理提案展开了激烈讨论：&lt;strong&gt;在不依赖垃圾回收 (GC) 的情况下直接释放并重用内存&lt;/strong&gt;。&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/74299&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;#74299&lt;/a&gt; 引入了 &lt;code&gt;runtime.free&lt;/code&gt; 及相关机制，试图让编译器和标准库在特定场景下安全地跳过 GC，对短命的内存对象进行即时回收利用&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/74299#:~:text=Note%20that%20runtime,called%20directly%20by%20end%20users&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;github.com&lt;/a&gt;&lt;a class=&#34;link&#34; href=&#34;https://go.googlesource.com/proposal/&amp;#43;/refs/changes/55/700255/14/design/74299-runtime-free.md#:~:text=1,Challenges%20here%20include&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;go.googlesource.com&lt;/a&gt;。此举被认为可能为 Go 带来一次&lt;strong&gt;性能上的革命&lt;/strong&gt;：初步原型显示，在 &lt;code&gt;strings.Builder&lt;/code&gt; 这样的场景中，利用该机制&lt;strong&gt;性能提升可达 2 倍&lt;/strong&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/74299#:~:text=%28In%20short%2C%20currently%20,more%20allocations%20per%20benchmark%20loop&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;github.com&lt;/a&gt;。本文将回顾 Go 内存管理领域从 &lt;em&gt;arena&lt;/em&gt; 实验到 &lt;em&gt;memory region&lt;/em&gt; 构想，再到 &lt;em&gt;runtime.free&lt;/em&gt; 提案的探索之旅，并剖析这一新提案的技术细节、产生的意义、演化过程，以及对普通开发者的影响。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;runtime.free 将在 Golang1.26 中 以 GOEXPERIMENT 的方式提供实验性支持。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;背景一场关于手动内存管理的漫长探索&#34;&gt;背景：一场关于“手动”内存管理的漫长探索
&lt;/h2&gt;&lt;p&gt;自 Go 语言诞生以来，自动垃圾回收（GC）就是其核心特性之一。然而在&lt;strong&gt;对性能极度敏感&lt;/strong&gt;的场景（如高吞吐的服务端程序）中，GC 带来的开销始终让开发者有所顾虑。为了进一步降低 GC 负担，Go 团队近年开始了一系列关于“手动”或“半自动”内存管理的探索尝试。&lt;/p&gt;
&lt;h3 id=&#34;arena-实验--强大却难以融合&#34;&gt;Arena 实验 —— 强大却难以融合
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Arena&lt;/strong&gt; 实验&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/51317&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;#51317&lt;/a&gt;是 Go 团队在 2022 年迈出的大胆一步。它引入了一个新的 &lt;code&gt;arena&lt;/code&gt; 包和 &lt;code&gt;Arena&lt;/code&gt; 类型，允许开发者将一组生命周期相同的对象分配到一个独立的内存区域中，并在不需要时&lt;strong&gt;一次性释放整个区域&lt;/strong&gt; 这一做法类似其他语言的 &lt;em&gt;region-based memory management&lt;/em&gt; 思想：大量对象集中分配、集中释放，从而降低常规分配/回收的成本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Arena 的优点&lt;/strong&gt;在某些场景下非常显著：所有对象统一释放，大幅减少了 GC 扫描和回收的工作量，谷歌内部测试显示对大型应用最高可节省约15%的 CPU 和内存开销。但是，Arena 随即暴露出严重的问题——&lt;strong&gt;API 侵入性&lt;/strong&gt;太强。为了使用 Arena，几乎每个相关函数都不得不增加一个 &lt;code&gt;arena.Arena&lt;/code&gt; 参数，这导致这种用法具有“&lt;strong&gt;病毒式&lt;/strong&gt;”传播效应，破坏了 Go 一贯强调的简洁与可组合性。另外，Arena 在与 Go 现有特性（如隐式接口、逃逸分析）配合时也出现了诸多不兼容之处。最终，由于 API 难以融入生态，Go 官方在 2023 年初宣布 &lt;strong&gt;无限期搁置 Arena 提案&lt;/strong&gt;，并明确表示 &lt;code&gt;GOEXPERIMENT=arena&lt;/code&gt; 仅供实验、不建议在生产中使用。&lt;/p&gt;
&lt;h3 id=&#34;memory-region-构想--优雅但实现复杂&#34;&gt;Memory Region 构想 —— 优雅但实现复杂
&lt;/h3&gt;&lt;p&gt;吸取了 Arena 的教训，Go 团队接着提出了更贴合 Go 哲学的概念：&lt;strong&gt;内存区域（Memory Region&lt;/strong&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/70257&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;#70257&lt;/a&gt;）它设想引入一种更&lt;strong&gt;透明&lt;/strong&gt;的机制——例如通过一个 &lt;code&gt;region.Do(func(){ ... })&lt;/code&gt; 调用，将某段函数作用域内的所有内存分配&lt;strong&gt;隐式绑定&lt;/strong&gt;到一个临时区域。当这段代码执行完毕时，该区域内分配的所有对象都可以一并释放。&lt;/p&gt;
&lt;p&gt;Memory Region 的&lt;strong&gt;优点&lt;/strong&gt;在于：对开发者而言几乎是透明的，无需修改函数签名或显式传递 Arena 对象。另外，通过运行时的巧妙设计，它依然能保持&lt;strong&gt;内存安全&lt;/strong&gt;。具体来说，如果区域中的某个对象被外部保留（“逃逸”出了区域作用域），运行时会&lt;strong&gt;自动将该对象挪回全局堆&lt;/strong&gt;由 GC 管理，从而避免类似 Arena 那样可能出现的 use-after-free 错误。这一设计既有手动内存管理的性能，又尽可能避免了手动管理常见的安全隐患。&lt;/p&gt;
&lt;p&gt;然而，Memory Region 的&lt;strong&gt;问题在于实现极其复杂&lt;/strong&gt;。要支持这种“区域化”的内存管理，需要对运行时和 GC 做重大改造。例如，开启区域时可能需要一个特殊的低开销写屏障来追踪对象逃逸情况，这增加了垃圾回收机制的复杂性和运行成本。虽然理论上可行，但要让这一方案高效稳健地落地，无疑是一项长期且充满不确定性的研究课题。迄今为止，Memory Region 仍停留在讨论和原型阶段，没有迅速融入 Go 主线。&lt;/p&gt;
&lt;h3 id=&#34;最终的焦点runtimefree&#34;&gt;最终的焦点：runtime.free
&lt;/h3&gt;&lt;p&gt;在 Arena 的侵入性和 Memory Region 的复杂性之间，Go 团队终于找到了一条&lt;strong&gt;更务实、工程上可行的中间路线&lt;/strong&gt;——这就是本次的 &lt;strong&gt;runtime.free 提案&lt;/strong&gt;。相比之前“大包大揽”的方案，&lt;code&gt;runtime.free&lt;/code&gt; 走的是&lt;strong&gt;精细化局部优化&lt;/strong&gt;的路子：与其让开发者手动管理整片内存，不如让更了解代码细节的&lt;strong&gt;编译器&lt;/strong&gt;和&lt;strong&gt;底层标准库&lt;/strong&gt;来决定何时安全地释放特定的堆内存。换言之，runtime.free 旨在像一把手术刀，&lt;strong&gt;精准切除&lt;/strong&gt;那些生命周期短暂且已确定不再使用的内存块，减少 GC 不必要的工作。&lt;/p&gt;
&lt;p&gt;这种方法极大地缓解了 Arena 的可组合性难题（因为开发者不需要改动代码、一切由编译器和运行时自动处理），也避开了 Memory Region 那种对 GC 全局机制的大改动。更重要的是，它为解决 Go 长期存在的性能**“鸡与蛋”困局&lt;strong&gt;提供了新的思路：许多优化（例如更激进的逃逸分析）过去之所以收效甚微，是因为即便消除了某个原因，内存对象仍可能由于&lt;/strong&gt;另一原因&lt;a class=&#34;link&#34; href=&#34;https://go.googlesource.com/proposal/&amp;#43;/refs/changes/55/700255/14/design/74299-runtime-free.md#:~:text=For%20example%2C%20,to%20eliminate%20the%20first%20reason&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;**逃逸到堆上，最终并未减少 GC 负担&lt;/a&gt;。而 runtime.free 的出现，相当于提供了一把钥匙，可以&lt;strong&gt;打破这种循环&lt;/strong&gt;——一旦对象在运行时被判定“确实不再需要”，就立即释放，从而&lt;a class=&#34;link&#34; href=&#34;https://go.googlesource.com/proposal/&amp;#43;/refs/changes/55/700255/14/design/74299-runtime-free.md#:~:text=In%20other%20words%2C%20a%20runtime,valuable%2C%20including%20in%20escape%20analysis&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;真正实现减少 GC 压力的初衷&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;runtimefree-的实现机制编译器自动化--标准库配合&#34;&gt;runtime.free 的实现机制：编译器自动化 + 标准库配合
&lt;/h2&gt;&lt;p&gt;需要强调的是，runtime.free &lt;strong&gt;并不&lt;/strong&gt;打算提供给普通开发者一个手工调用 &lt;code&gt;free&lt;/code&gt; 的新玩具。相反，它采取高度受控的“双管齐下”策略，通过&lt;strong&gt;编译器&lt;/strong&gt;和&lt;strong&gt;标准库&lt;/strong&gt;的改进来实现内存释放优化，同时不向 Go 程序员暴露额外的复杂度。&lt;/p&gt;
&lt;h3 id=&#34;编译器自动释放-runtimefreetracked&#34;&gt;编译器自动释放 (runtime.freetracked)
&lt;/h3&gt;&lt;p&gt;首先，也是整个提案最令人兴奋的部分：&lt;strong&gt;编译器将自动插入内存释放逻辑&lt;/strong&gt;。具体而言，当编译器检测到某些场景下分配的内存可以安全提前回收时，就会在编译阶段悄悄地产生额外的代码来跟踪并释放这些内存：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;识别阶段：&lt;/strong&gt; 对于典型的 &lt;code&gt;make([]T, size)&lt;/code&gt; 切片分配，如果编译器发现该切片虽然因为长度或容量未知而必须逃逸到堆上，但它的使用范围不超过当前函数（例如不会被保存到全局或返回给调用者），那么编译器将把这次分配标记为&lt;a class=&#34;link&#34; href=&#34;https://go.googlesource.com/proposal/&amp;#43;/refs/changes/55/700255/14/design/74299-runtime-free.md#:~:text=2,in%20a%20loop&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;“&lt;strong&gt;可跟踪释放&lt;/strong&gt;”&lt;/a&gt;。这种情况下，会调用一个特殊的分配函数（如 &lt;code&gt;makeslicetracked64&lt;/code&gt;）来分配对象，并将该对象的指针记录到当前函数栈上的一个&lt;a class=&#34;link&#34; href=&#34;https://go.googlesource.com/proposal/&amp;#43;/refs/changes/55/700255/14/design/74299-runtime-free.md#:~:text=The%20second%20API%20,as%20a%20scope%20is%20exited&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;strong&gt;追踪列表&lt;/strong&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;跟踪阶段：&lt;/strong&gt; 编译器在栈上维护一个 &lt;code&gt;freeables&lt;/code&gt; 数组（或切片），收集所有被标记为可释放的堆对象。当有新的可释放对象分配时，其指针会被追加到这个列表中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;释放阶段：&lt;/strong&gt; 在函数返回前，编译器会自动插入一行类似 &lt;code&gt;defer runtime.freeTracked(&amp;amp;freeables)&lt;/code&gt; 的调用&lt;a class=&#34;link&#34; href=&#34;https://tonybai.com/2025/09/18/go-runtime-free-proposal/#:~:text=1.%20%E8%AF%86%E5%88%AB%EF%BC%9A%E5%BD%93%E7%BC%96%E8%AF%91%E5%99%A8%E9%81%87%E5%88%B0%E4%B8%80%E4%B8%AA%20make%28,%E8%87%AA%E5%8A%A8%E9%87%8D%E5%86%99%20%E4%B8%BA%E4%B8%8D%E4%BA%A7%E7%94%9F%20GC%20%E5%8E%8B%E5%8A%9B%E7%9A%84%E7%89%88%E6%9C%AC%EF%BC%8C%E8%80%8C%E5%BC%80%E5%8F%91%E8%80%85%E5%AF%B9%E6%AD%A4%20%E5%AE%8C%E5%85%A8%E6%97%A0%E6%84%9F%E3%80%82&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;tonybai.com&lt;/a&gt;。这样，当函数退出时，这个延迟调用将执行，通知运行时回收 &lt;code&gt;freeables&lt;/code&gt; 列表中记录的所有堆对象。这种做法确保了在&lt;strong&gt;作用域结束&lt;/strong&gt;时，临时分配的对象立即被释放，而无需等待下一轮 GC。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/11/2b6c0d576255984f33c9aa53a40d8187.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;未命名&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;对于开发者来说，这一切都是&lt;strong&gt;透明&lt;/strong&gt;的：你完全可以像往常一样编写代码，而编译器在背后已经将其“悄悄优化”为一个更少堆分配、更少 GC 压力的版本。举个简单例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 开发者原始代码&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;buf&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;byte&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 可能逃逸到堆上&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// ... 使用 buf&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 编译器优化后的等效代码（概念示意）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;freeables&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;buf&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;runtime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;makeslicetracked64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freeables&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 分配受跟踪的 slice&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// ... 使用 buf&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;runtime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;freeTracked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freeables&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 函数退出时释放 buf 对应的内存&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;经过这种改写，原本可能需要 GC 扫描回收的 &lt;code&gt;buf&lt;/code&gt; 内存，将在函数结束时&lt;strong&gt;立即归还&lt;/strong&gt;给运行时可用的内存池。因此，未来我们编写的一些看似会产生大量堆分配的代码，有望在&lt;strong&gt;不改变任何源码&lt;/strong&gt;的情况下，由编译器替我们转换成“零 GC 压力”的高效版本——开发者对此&lt;strong&gt;毫无感知&lt;/strong&gt;，但程序性能却因此获益。&lt;/p&gt;
&lt;h3 id=&#34;标准库协助释放-runtimefreesized&#34;&gt;标准库协助释放 (runtime.freesized)
&lt;/h3&gt;&lt;p&gt;另一方面，对于 Go &lt;strong&gt;标准库中少数性能关键的组件&lt;/strong&gt;，开发团队也在尝试手动加入 &lt;code&gt;runtime.free&lt;/code&gt; 的调用。这并不是要把手动内存管理强加给所有库，而是利用标准库对自身情况的了解，在&lt;strong&gt;极有限&lt;/strong&gt;的热点场景显式地释放内存，以追求极致性能。提案中提到的主要目标包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;strings.Builder&lt;/code&gt; / &lt;code&gt;bytes.Buffer&lt;/code&gt;&lt;/strong&gt; 的扩容：当内部缓冲区需要增长时，旧的缓冲区实际上已经不再使用，完全可以当场释放，避免占用堆并减轻后续 GC 压力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;map&lt;/code&gt; 的扩容&lt;/strong&gt;：Go 的 map 在扩容和重新哈希（rehash）时会分配新的底层数组，此时旧的 buckets 数组事实上已死，同样可以立即回收。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;slices.Collect&lt;/code&gt; 等&lt;/strong&gt;切片收集/拼接的操作：在构造最终结果过程中产生的大量中间切片，仅用于过渡，也可以及时释放。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于这些场景，runtime.free 提供了一个内部运行时函数 &lt;code&gt;runtime.freeSized(ptr, size, noscan)&lt;/code&gt;（提案原型中使用的是 &lt;code&gt;freesized&lt;/code&gt;），允许在知道一个对象指针 &lt;code&gt;ptr&lt;/code&gt; 及其大小后，立刻释放对应内存。这种调用仅限于&lt;strong&gt;非常底层&lt;/strong&gt;且对内存使用有精确认知的代码。例如 Go 作者们在实验中修改了 &lt;code&gt;strings.Builder&lt;/code&gt; 的代码，在扩容逻辑中加入对旧缓冲区的 &lt;code&gt;runtime.freeSized&lt;/code&gt; 调用。结果表明：&lt;strong&gt;对于执行多次扩容的场景，新版 &lt;code&gt;strings.Builder&lt;/code&gt; 性能提升了约 45%～55%&lt;/strong&gt;，几乎&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/74299#:~:text=BuildString_Builder%2F10Write_36Bytes_NoGrow,55.71%25%20%28p%3D0.000%20n%3D20&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;strong&gt;快了一倍&lt;/strong&gt;&lt;/a&gt;！换句话说，通过在正确的时机手动释放内存，可以实打实地换来巨大性能收益。&lt;/p&gt;
&lt;p&gt;需要注意的是，这种手动调用只会出现在&lt;strong&gt;少数标准库&lt;/strong&gt;内部。Go 团队并不打算在诸如 &lt;code&gt;net/http&lt;/code&gt; 这样的高级库里遍地插入 &lt;code&gt;runtime.free&lt;/code&gt; —— 毕竟那样又回到了“到处手动管理内存”的老路上。这一步更多是为了验证：&lt;strong&gt;在哪些特殊场景下，提前释放内存能够带来明显收益&lt;/strong&gt;。如果证明效果显著，我们也许会在未来看到这些改进融入正式版本中；如果收益不大或风险高，也可以根据讨论再决定是否采纳。&lt;/p&gt;
&lt;h2 id=&#34;性能影响与收益&#34;&gt;性能影响与收益
&lt;/h2&gt;&lt;p&gt;让 GC “少管一些事”听起来很美好，但也要评估此举本身的性能代价。插入额外的跟踪和释放逻辑，会不会拖慢常规代码的速度？根据目前的原型测试结果，答案是&lt;strong&gt;几乎可以忽略&lt;/strong&gt;。对比启用 &lt;code&gt;runtimefree&lt;/code&gt; 实验前后的基准数据表明：*&lt;em&gt;在没有可释放对象的普通分配场景下，新机制对性能的影响在 -1.5% 到 +2.2% 之间，几何平均值几乎为零。也就是说，如果你的代码并不存在那些可以提前释放的内存对象，启用这个功能对性能既不会造成明显负担，也几乎不会带来益处——它基本是&lt;/em&gt;“零成本”（pay-for-what-you-use）*的。&lt;/p&gt;
&lt;p&gt;而在命中了优化路径的情况下，&lt;strong&gt;收益则是多方面的&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;减少 GC 的 CPU 消耗：&lt;/strong&gt; 这是最直接的好处。部分内存由运行时立即回收，意味着 GC 每次需要标记、扫描的对象变少，从而降低了 GC 自身的CPU占用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拉长 GC 间隔、缩短写屏障时间：&lt;/strong&gt; 垃圾变少了，GC 自然可以更久运行一次。对于 Go 程序来说，这意味着更多时间处于&lt;strong&gt;无 GC 干扰&lt;/strong&gt;的状态，写屏障（write barrier）启用的总时间减少，进而让应用代码本身跑得更快。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高缓存局部性：&lt;/strong&gt; 被 &lt;code&gt;runtime.free&lt;/code&gt; 释放的对象立即回收到对应大小类的空闲链表中，下一个相同大小的新对象分配&lt;strong&gt;很可能重用这块内存&lt;/strong&gt;。 这样一来，内存分配/释放形成类似&lt;strong&gt;栈式（LIFO）&lt;/strong&gt; 的模式，新分配的内存地址往往与刚释放的相同，对 CPU 缓存非常友好。相比任由 GC 随机回收、重新从堆中找内存，这种局部性有望进一步提升运行效率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;减少 GC 停顿和辅助操作：&lt;/strong&gt; 总体上，GC 工作量变小后，STW（stop-the-world）暂停的时间和 GC &lt;strong&gt;辅助运行&lt;/strong&gt;（assist）的触发频率都会降低，让应用更平稳&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外，新的垃圾回收器 &lt;code&gt;Green Tea&lt;/code&gt; 也可能从这种优化中受益——例如更高的每个span内存利用率，等等。尽管这方面还是推测，但&lt;strong&gt;runtime.free&lt;/strong&gt; 提案的出现显然为未来 GC 和内存优化的融合创造了更多可能。&lt;/p&gt;
&lt;h2 id=&#34;意义与展望开发者获得什么&#34;&gt;意义与展望：开发者获得什么？
&lt;/h2&gt;&lt;p&gt;从开发者的角度来看，runtime.free &lt;em&gt;究竟意味着什么&lt;/em&gt;？一言以蔽之：&lt;strong&gt;性能提升，几乎无需额外付出&lt;/strong&gt;。对于普罗大众的 Go 开发者来说，这个提案&lt;strong&gt;不会改变&lt;/strong&gt;我们日常编码的方式——没有新语法、也无需调用新的 API。所有魔法都发生在幕后：&lt;strong&gt;编译器&lt;/strong&gt;变得更聪明，&lt;strong&gt;运行时/标准库&lt;/strong&gt;替我们多做了一些工作。然而，它的影响可能是深远的：&lt;/p&gt;
&lt;p&gt;首先，这标志着 Go 的内存管理正在探索 &lt;strong&gt;“自动 GC”之外的第三条道路&lt;/strong&gt;。传统上，我们有完全自动的 GC（简单易用但性能牺牲）和手工的内存管理（复杂易出错但性能可控）。而 Go 的 runtime.free 尝试证明，两者并非水火不容：语言运行时本身可以变得更智能，&lt;strong&gt;在保证内存安全的前提下&lt;/strong&gt;，帮我们完成一些人工才能做到的优化。从某种意义上说，Go 正在尝试“靠自己”变得更快，而不是把负担转嫁给开发者。&lt;/p&gt;
&lt;p&gt;其次，对性能敏感的Go程序将直接受益于此。在未来的版本（提案目前计划针对 Go 1.26），当这一实验正式上线后，你或许会发现&lt;strong&gt;某些场景下 GC 压力突然降低&lt;/strong&gt;了。例如，大量使用临时切片进行计算的函数，不再生成那么多短命的垃圾；频繁扩容的 &lt;code&gt;bytes.Buffer&lt;/code&gt;、构建巨型 slice 的代码，在新版标准库里跑得飞快。这些性能改进都是 &lt;strong&gt;“开箱即得”&lt;/strong&gt; 的，开发者甚至不需要知道 runtime.free 的存在，就已经享受到了它的好处。&lt;/p&gt;
&lt;p&gt;当然，runtime.free 仍处于试验和完善阶段。它目前通过 &lt;code&gt;GOEXPERIMENT=runtimefree&lt;/code&gt; 提供，说明官方也在审慎评估其效果和风险。接下来社区会继续打磨细节，确保不会引入难以预料的错误（比如要严格杜绝“提前释放仍在用的对象”这种灾难性情况）。好消息是，到目前为止初步验证并未发现不可逾越的技术障碍，核心团队成员也给予了正面反馈。&lt;/p&gt;
&lt;p&gt;总体而言，runtime.free 提案代表了 Go 内存管理上&lt;strong&gt;务实而具有前瞻性&lt;/strong&gt;的一步。它不追求颠覆性的架构重写，而是聚焦于具体的瓶颈问题，寻求切实的优化突破；它也不牺牲类型安全和简洁性，将复杂度限定在编译器和运行时内部。这种思路一旦被证明行之有效，未来完全可以推广到更多模式（例如&lt;a class=&#34;link&#34; href=&#34;https://go.googlesource.com/proposal/&amp;#43;/refs/changes/55/700255/14/design/74299-runtime-free.md#:~:text=4.%20Recognizing%20,does%20not%20otherwise%20become%20aliased&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;识别更多 &lt;code&gt;append&lt;/code&gt; 循环的场景等&lt;/a&gt;），进一步减少 Go 程序的内存开销和 GC 次数。&lt;/p&gt;
&lt;p&gt;对于普通开发者来说，这意味着&lt;strong&gt;更快的程序&lt;/strong&gt;和&lt;strong&gt;更少的垃圾回收停顿&lt;/strong&gt;，而你依然可以像过去一样专注于业务逻辑，无需为手动内存管理操碎心。随着编译器与运行时不断进化，Go 有望在保持“一键爽跑”的易用性的同时，在性能上再攀新高峰——这一切，值得我们拭目以待。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引用资料：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Go Issue 【74299】“runtime, cmd/compile: add runtime.free, runtime.freetracked and GOEXPERIMENT=runtimefree”&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/74299#:~:text=updated%20manually%20to%20start%2C%20which,to%20automatically%20recognize%20its%20pattern&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;github.com&lt;/a&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/74299#:~:text=%28In%20short%2C%20currently%20,more%20allocations%20per%20benchmark%20loop&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;github.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Go Proposal 设计文档 “Directly freeing user memory to reduce GC work”&lt;a class=&#34;link&#34; href=&#34;https://go.googlesource.com/proposal/&amp;#43;/refs/changes/55/700255/14/design/74299-runtime-free.md#:~:text=For%20example%2C%20,to%20eliminate%20the%20first%20reason&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;go.googlesource.com&lt;/a&gt;&lt;a class=&#34;link&#34; href=&#34;https://go.googlesource.com/proposal/&amp;#43;/refs/changes/55/700255/14/design/74299-runtime-free.md#:~:text=1,Challenges%20here%20include&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;go.googlesource.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Go Issue 【&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/51317#:~:text=Note%2C%202023,recommend%20its%20use%20in%20production&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;#51317&lt;/a&gt;】“proposal: arena: new package providing memory arenas”（已被标记 hold)&lt;/li&gt;
&lt;li&gt;Go Discussions 【70257】“memory regions” (内存区域管理的讨论线程)&lt;/li&gt;
&lt;li&gt;Stack Overflow: &lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/72471052/how-to-free-memory-manually-in-golang&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;How to free memory manually in golang&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>HTTP/3：看似无处不在，实则难觅踪影</title>
        <link>https://huizhou92.com/zh-cn/p/http3%E7%9C%8B%E4%BC%BC%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8%E5%AE%9E%E5%88%99%E9%9A%BE%E8%A7%85%E8%B8%AA%E5%BD%B1/</link>
        <pubDate>Tue, 11 Nov 2025 18:57:08 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/http3%E7%9C%8B%E4%BC%BC%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8%E5%AE%9E%E5%88%99%E9%9A%BE%E8%A7%85%E8%B8%AA%E5%BD%B1/</guid>
        <description>&lt;img src="https://httptoolkit.com/images/header-images/http-toolkit-assets/h-sign-opt-640.WEBP" alt="Featured image of post HTTP/3：看似无处不在，实则难觅踪影" /&gt;&lt;p&gt;HTTP/3 的研发至少可追溯至 2016 年，而其底层传输协议 QUIC 更是由 Google 在 2013 年率先提出。如今这两项技术均已确立国际标准：&lt;a class=&#34;link&#34; href=&#34;https://caniuse.com/http3&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;strong&gt;获得 95% 浏览器的支持&lt;/strong&gt;&lt;/a&gt;，**Cloudflare 处理的 HTTP 请求中已有 &lt;a class=&#34;link&#34; href=&#34;https://radar.cloudflare.com/adoption-and-usage&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;32% 采用该协议**&lt;/a&gt;，并且在 HTTP Archive 数据集中，有 &lt;strong&gt;&lt;a class=&#34;link&#34; href=&#34;https://almanac.httparchive.org/en/2024/http#discovering-http3-support&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;35% 的网站&lt;/a&gt;&lt;/strong&gt; 宣称支持HTTP/3 (通过 alt-svc 或 DNS）。&lt;/p&gt;
&lt;p&gt;我们不仅成功开发出全新一代 HTTP 协议，更已将超三分之一的网络流量迁移至该协议——这堪称里程碑式的进展。&lt;/p&gt;
&lt;p&gt;然而矛盾的是，包括 Node.js、Go、Rust、Python 和 Ruby 在内的主流编程语言，其标准库均未内置对 QUIC 或 HTTP/3 的支持。Curl 虽然近期&lt;a class=&#34;link&#34; href=&#34;https://curl.se/docs/http3.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;新增了相关功能&lt;/a&gt;，但仍标记为实验性质且在大多数发行版中默认禁用。某些语言虽有第三方实现库，但均处于实验阶段，且无法与核心网络 API 协同工作。更值得注意的是，尽管移动网络是 HTTP/3 的关键应用场景，Android 主流 HTTP 库 OkHttp &lt;a class=&#34;link&#34; href=&#34;https://github.com/square/okhttp/blob/59cbf64f6ba98e2c8f95bf9db41dc47ad2232f94/okhttp/src/commonJvmAndroid/kotlin/okhttp3/Protocol.kt#L86-L94&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;仍明确不支持该协议&lt;/a&gt;。Nginx 仅提供&lt;a class=&#34;link&#34; href=&#34;https://nginx.org/en/docs/quic.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;实验性模块&lt;/a&gt;且默认关闭，Apache 既无支持计划也未公布路线图，而 Kubernetes 最流行的反向代理 Ingress-Nginx 更是&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes/ingress-nginx/issues/4760&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;完全放弃了支持计划&lt;/a&gt;，将相关功能移交至尚未发布的新一代项目。&lt;/p&gt;
&lt;p&gt;事实上，目前几乎找不到能完整支持 HTTP/3 的流行开源工具——这项技术的推广部署仍处于萌芽阶段。&lt;/p&gt;
&lt;p&gt;这种矛盾现象背后究竟隐藏着什么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;本文假设读者已了解 HTTP/1.1、HTTP/2 与 HTTP/3 的核心差异。如需入门资料，curl 创始人 Daniel Stenberg 撰写的 &lt;a class=&#34;link&#34; href=&#34;https://http2-explained.haxx.se/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http2-explained&lt;/a&gt; 与 &lt;a class=&#34;link&#34; href=&#34;https://http3-explained.haxx.se/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http3-explained&lt;/a&gt; 是绝佳参考。&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;让我们回溯根本：为什么这很重要？如果浏览器和大型 CDN 已支持 HTTP/3，其他客户端或服务端实现是否还有必要跟进？&lt;/p&gt;
&lt;p&gt;有观点认为，&lt;a class=&#34;link&#34; href=&#34;https://byroot.github.io/ruby/performance/2025/02/24/http2-past-the-load-balancer.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;在负载均衡器之后使用 HTTP/2 意义有限&lt;/a&gt;。其核心论点是：H&lt;strong&gt;TTP/2 的多路复用主要解决延迟与&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Head-of-line_blocking&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;队头阻塞 (Head-of-line blocking)&lt;/a&gt; 问题，但在延迟极低的内部网络中，通过长连接即可规避这些问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这个论点同样适用于 HTTP/3：它对高延迟、多请求的 浏览器-CDN 场景有益，但对其他场景价值有限。但即使只考虑 HTTP/1.1 与 HTTP/2，多路复用优势的现实情况也更加复杂：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;响应延迟不仅来自网络传输：服务端处理缓慢同样会阻塞 TCP 连接&lt;/li&gt;
&lt;li&gt;负载均衡器常与后端服务异地部署（例如通过全球 CDN 提供服务时，动态请求仍需回源至独立后端）&lt;/li&gt;
&lt;li&gt;长连接 TCP 连接并不可靠：即使在数据中心内，网络故障也时有发生，“保持连接”只是理想状态。HTTP 协议本身也会强制中断连接（如响应体传输中途失败时）&lt;/li&gt;
&lt;li&gt;流量波动会导致 TCP 连接数失衡：要么长期维持冗余连接池，要么在峰值时建立新连接，面临慢启动、往返延迟与 TLS 握手开销&lt;/li&gt;
&lt;li&gt;非网站类流量（移动应用、API 服务、物联网设备）同样面临网络延迟与服务端阻塞问题，这些场景都能从 HTTP/2/3 中获益&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除多路复用外，HTTP/2 还有更多跨场景优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;头部压缩（HTTP/2 的 &lt;a class=&#34;link&#34; href=&#34;https://blog.cloudflare.com/hpack-the-silent-killer-feature-of-http-2/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;HPACK&lt;/a&gt; 与 HTTP/3 的 &lt;a class=&#34;link&#34; href=&#34;https://datatracker.ietf.org/doc/rfc9204/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;QPACK&lt;/a&gt;）显著减少传输数据量，对内部长连接效果尤为明显&lt;/li&gt;
&lt;li&gt;双向流通信（仅 HTTP/2/3 支持）开启全新交互模式，gRPC 即基于此特性构建，类似 WebSocket 但完全兼容 HTTP 语义&lt;/li&gt;
&lt;li&gt;请求优先级控制允许服务端优化资源分配，这对负载均衡器与后端通信同样重要&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTTP/3 更在以下方面实现突破：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过取消 TCP 严格包序，使单个流独立传输，避免流间阻塞&lt;/li&gt;
&lt;li&gt;结合 TLS 1.3 与 QUIC 实现 &lt;a class=&#34;link&#34; href=&#34;https://blog.cloudflare.com/even-faster-connection-establishment-with-quic-0-rtt-resumption/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;0RTT 握手&lt;/a&gt;，首次请求无需等待 TLS 握手完成&lt;/li&gt;
&lt;li&gt;降低传输开销与连接数，减少客户端能耗与服务端资源消耗&lt;/li&gt;
&lt;li&gt;支持&lt;a class=&#34;link&#34; href=&#34;https://pulse.internetsociety.org/blog/how-quic-helps-you-seamlessly-connect-to-different-networks&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;连接迁移&lt;/a&gt;，IP 变更时保持会话连续性，未来甚至支持多路径传输&lt;/li&gt;
&lt;li&gt;采用 &lt;a class=&#34;link&#34; href=&#34;https://research.google/pubs/bbr-congestion-based-congestion-control-2/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;BBR 拥塞控制&lt;/a&gt;等先进算法，提升网络适应能力&lt;/li&gt;
&lt;li&gt;为 &lt;a class=&#34;link&#34; href=&#34;https://github.com/w3c/webtransport/blob/main/explainer.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WebTransport&lt;/a&gt; 提供基础，实现低延迟双向通信的同时解决 WebSocket 的队头阻塞等问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际测试数据同样佐证其价值。RequestMetric 的&lt;a class=&#34;link&#34; href=&#34;https://requestmetrics.com/web-performance/http3-is-fast/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;基准测试&lt;/a&gt;显示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://httptoolkit.com/images/posts/http-toolkit-assets/requestmetrics-http3-opt-1080.WEBP&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;各类网站在 HTTP/1.1、2、3 下的加载时间对比，显示 HTTP/3 显著提速&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Fastly 也在实际环境中观测到首字节时间的大幅优化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://httptoolkit.com/images/posts/http-toolkit-assets/fastly-http3-opt-1080.WEBP&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Fastly 实测 HTTP/3 降低首字节时间 18%&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;显然，这是一项&lt;strong&gt;具有实质价值&lt;/strong&gt;的技术。&lt;/p&gt;
&lt;p&gt;既然 HTTP/3 已完成标准化、获得广泛支持并经过实践检验，没理由不让所有开发者都能通过常用开发工具链享受这些技术红利。&lt;/p&gt;
&lt;h2 id=&#34;割裂的网络&#34;&gt;割裂的网络
&lt;/h2&gt;&lt;p&gt;现实却截然相反：尽管技术优势明显且网络流量占比显著，大多数开发者仍难以端到端部署 HTTP/3。这种现象折射出互联网长期存在的分层现状。如今的网络流量已分化为两种形态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;超大规模流量&lt;/strong&gt;：主流浏览器与特定移动应用通过精心调优的客户端，与少数科技巨头的自有基础设施或大型 CDN 通信&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;长尾流量&lt;/strong&gt;：后端服务、中小型应用、物联网设备、学术研究等多样化场景，依赖开源生态与共享技术栈&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两大阵营的核心差异包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;长尾流量规模更大： &lt;a class=&#34;link&#34; href=&#34;https://almanac.httparchive.org/en/2024/cdn#cdn-adoption&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;67%&lt;/a&gt; 的网页请求直连源站，Cloudflare 2024 年数据表明其 &lt;a class=&#34;link&#34; href=&#34;https://blog.cloudflare.com/application-security-report-2024-update/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;30% 流量来自自动化程序，60% 属于 API 调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;长尾生态天然碎片化，主要依赖志愿维护的开源项目&lt;/li&gt;
&lt;li&gt;超大规模阵营由少数利益相关方主导，能快速协调标准制定与落地&lt;/li&gt;
&lt;li&gt;商业动机高度集中：性能毫秒级提升直接关联企业收益&lt;/li&gt;
&lt;li&gt;长尾完全依赖开源实现，而超大规模玩家拥有自研定制的实力与资源&lt;/li&gt;
&lt;li&gt;版本迭代速度差异巨大：长尾工具注重稳定性，超大规模阵营追求快速迭代&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种分化并非善恶对立——从工程角度，HTTP/3 正是跨组织协作的卓越成果。但问题在于：当下一代网络技术由少数群体定义并优先服务自身需求时，大多数开发者只能通过购买 CDN 服务间接获取技术红利，这无疑限制了创新生态的健康发展。&lt;/p&gt;
&lt;h2 id=&#34;openssl-与-quic-的兼容困局&#34;&gt;OpenSSL 与 QUIC 的兼容困局
&lt;/h2&gt;&lt;p&gt;这种分化最具体的体现就是 OpenSSL 对 QUIC 的支持策略。作为最基础的 TLS 库，OpenSSL 的态度直接影响整个开源生态。事件脉络如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BoringSSL 2018 年即提供 QUIC API&lt;/li&gt;
&lt;li&gt;OpenSSL 长期缺失该功能，催生 QuicTLS 等兼容分支&lt;/li&gt;
&lt;li&gt;现有 HTTP/3 实现生态（Quiche、msh3、nghttp3 等）均基于 BoringSSL 或分支构建&lt;/li&gt;
&lt;li&gt;OpenSSL 3.2 起采用不兼容的实现方案，导致生态分裂&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;curl 的项目现状图清晰展现了这种割裂：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://httptoolkit.com/images/posts/http-toolkit-assets/http3-components-in-curl-opt-1080.WEBP&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;curl 支持的 HTTP/3 组件体系，现有实现均构建于 OpenSSL 替代方案之上&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;对大多数项目而言，放弃 OpenSSL 转向其他方案成本过高，这导致它们至今无法原生支持 QUIC。Node.js 曾&lt;a class=&#34;link&#34; href=&#34;https://github.com/nodejs/node/issues/57379&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;讨论切换方案&lt;/a&gt;，但考虑到系统兼容性、长期支持等现实因素，最终难以实施。&lt;/p&gt;
&lt;p&gt;这正是双层网络差异的典型体现：&lt;strong&gt;开源工具必须保持向后兼容，而超大规模玩家可以为了技术先进性承担更大变更成本&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;未来走向&#34;&gt;未来走向
&lt;/h2&gt;&lt;p&gt;组织架构差异正在导致互联网技术栈的分裂。虽然长尾场景未必急需 HTTP/3，但若放任不管，可能导致：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性能差距扩大：超大规模网站在移动网络环境下体验优势加剧&lt;/li&gt;
&lt;li&gt;工具链分化：前端框架等基础设施逐渐以 HTTP/3 为默认假设&lt;/li&gt;
&lt;li&gt;技术壁垒形成：缺乏 HTTP/3 支持可能成为被限流或验证的依据&lt;/li&gt;
&lt;li&gt;生态恶性循环：长尾需求逐渐被技术演进忽略&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有这些都还有一段距离，而且是相当假设性的！我怀疑其中一些假设会在某种程度上发生，但可能性范围很广。不过值得注意的是，这不仅仅适用于 HTTP/3：少数 CDN 和网络客户端的这种集中和协调很容易在许多其他类型的技术改进中也以类似的方式发生。&lt;/p&gt;
&lt;p&gt;至少对于 HTTP/3 而言，我希望这里能有一个愉快的解决方案来及时改善这种分裂，尽管我不知道它是否会足够快以避免明显的后果。许多 QUIC 和 HTTP/3 的外部库和实验性实现会随着时间的推移而成熟，而且我认为最终 (我真的非常希望) OpenSSL QUIC API 的分裂将得到解决，从而为 许多基于 OpenSSL 的环境中的 QUIC 支持打开大门，要么通过适配器支持这两种方法，要么通过直接支持 OpenSSL 模型的新 HTTP/3 和 QUIC 堆栈。&lt;br&gt;
然而，所有这一切都不会在今天发生，因此不幸的是，如果您想在您的应用程序中端到端地使用 HTTP/3，您可能还需要经历一段时间的艰难时期。敬请关注。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/http3%E7%9C%8B%E4%BC%BC%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8%E5%AE%9E%E5%88%99%E9%9A%BE%E8%A7%85%E8%B8%AA%E5%BD%B1/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;本文长期链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果您觉得我的博客对你有帮助，请通过 &lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/index.xml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RSS&lt;/a&gt;订阅我。&lt;/li&gt;
&lt;li&gt;或者在&lt;a class=&#34;link&#34; href=&#34;https://x.com/@piaopiaopig&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;X&lt;/a&gt;上关注我。&lt;/li&gt;
&lt;li&gt;如果您有&lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Medium&lt;/a&gt;账号，能给我个关注嘛？我的文章第一时间都会发布在Medium。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Go 官方再谈错误处理：新语法为何迟迟无法落地？</title>
        <link>https://huizhou92.com/zh-cn/p/go-%E5%AE%98%E6%96%B9%E5%86%8D%E8%B0%88%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%96%B0%E8%AF%AD%E6%B3%95%E4%B8%BA%E4%BD%95%E8%BF%9F%E8%BF%9F%E6%97%A0%E6%B3%95%E8%90%BD%E5%9C%B0/</link>
        <pubDate>Wed, 04 Jun 2025 20:14:24 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/go-%E5%AE%98%E6%96%B9%E5%86%8D%E8%B0%88%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%96%B0%E8%AF%AD%E6%B3%95%E4%B8%BA%E4%BD%95%E8%BF%9F%E8%BF%9F%E6%97%A0%E6%B3%95%E8%90%BD%E5%9C%B0/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/06/0d71cfc56d9aec68cc85fd38ca37e3a7.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20250605093005&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;go-官方再谈错误处理新语法为何迟迟无法落地&#34;&gt;Go 官方再谈错误处理：新语法为何迟迟无法落地？
&lt;/h1&gt;&lt;p&gt;近日，Go 官方博客发布了一篇名为《&lt;a class=&#34;link&#34; href=&#34;https://go.dev/blog/error-syntax&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;On | No syntactic support for error handling&lt;/a&gt;》的文章。这篇文章没有带来期待中的语法突破，反而再次回顾了 Go 语言过去在错误处理语法上多次尝试的失败经验。&lt;br&gt;
Go 团队为什么发表这么一篇文章？&lt;/p&gt;
&lt;h2 id=&#34;为什么-go-团队反复探讨错误处理&#34;&gt;为什么 Go 团队反复探讨“错误处理”？
&lt;/h2&gt;&lt;p&gt;自诞生以来，Go 语言以简洁明了著称，但却始终背负着一个无法回避的问题：错误处理语法过于冗长。&lt;br&gt;
我们熟悉的 Go 错误处理通常长这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;``&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Go&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;printSum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;strconv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Atoi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;strconv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Atoi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;result:&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;反复出现的 &lt;code&gt;if err != nil&lt;/code&gt; 显得单调乏味，代码中大量的错误处理重复模式经常被批评为“&lt;strong&gt;机械且冗余&lt;/strong&gt;”。因此，过去数年，Go 团队多次尝试设计更为简洁的新语法，但最终都未能成功落地。&lt;/p&gt;
&lt;h2 id=&#34;曾经尝试却未成功的那些提案&#34;&gt;曾经尝试却未成功的那些提案
&lt;/h2&gt;&lt;p&gt;Go 团队在过去提出了几种备受关注但最终放弃的方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2018年：&lt;a class=&#34;link&#34; href=&#34;https://go.googlesource.com/proposal/&amp;#43;/master/design/go2draft-error-handling.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;check&lt;/code&gt; 与 &lt;code&gt;handle&lt;/code&gt;&lt;/a&gt; 提案&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;尝试用新关键字简化错误传播，但社区担忧复杂度增加，被否决。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2019年：&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/32437&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; 提案&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;引入内置函数 &lt;code&gt;try&lt;/code&gt;，期望简化语法。但社区认为该方案过于隐式，破坏了代码的明确性，也被搁置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2024 年：？&lt;br&gt;
Ian Lance Taylor 参考 Rust 的实现提出了 &lt;a class=&#34;link&#34; href=&#34;https://go.dev/issue/71203&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;“使用 &lt;code&gt;?&lt;/code&gt; ”减少错误处理样板&lt;/a&gt; 也遭遇到了大量的反对意见，  我也水了一篇博客&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些尝试的失败不仅仅是技术上的，更体现了 Go 社区一种特殊的文化和理念——&lt;strong&gt;明确胜于隐式&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;真正的动机是什么&#34;&gt;真正的动机是什么？
&lt;/h2&gt;&lt;p&gt;细读这篇博客，我们会发现 Go 团队并不是单纯地“回忆过去”，而是在认真回应社区持续发酵的讨论：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;究竟有没有必要为错误处理引入新语法？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文章的字里行间传递了一个关键的讯号：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“Go 社区对于新语法的需求，并非简单的‘yes or no’，而是深入涉及到语言设计哲学和社区价值观的问题。”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;换句话说，Go 团队的动机并不是要立即给出一个新提案，而是希望借此引导社区回到初心，认真审视“我们真正需要什么样的语言设计？”&lt;/p&gt;
&lt;h2 id=&#34;明确胜于隐式go-社区无法放弃的原则&#34;&gt;“明确胜于隐式”：Go 社区无法放弃的原则
&lt;/h2&gt;&lt;p&gt;Go 语言的成功，正是因为其清晰且明确的设计哲学。任何新语法都必须经过社区的严格审视：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新语法能否保持明确性？&lt;/li&gt;
&lt;li&gt;新语法能否带来足够的收益，值得牺牲现有的简单性？&lt;/li&gt;
&lt;li&gt;新语法是否有可能带来其他负面影响？&lt;br&gt;
在这种原则下，每个提案都难免面临严格审视和质疑。这也是过去的尝试频频受挫的根本原因。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;五未来的路在哪里&#34;&gt;五、未来的路在哪里？
&lt;/h2&gt;&lt;p&gt;这篇官方博客所释放的另一个信息是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Go 团队已经接受了短期内不会推出新错误处理语法的现实。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;他们似乎在暗示：错误处理的语法简化并非完全不可行，但至少现在还未找到完美的答案，社区需要更多时间的探索、实践与反思。&lt;br&gt;
因此，未来很长一段时间内，Go 程序员仍需忍受现有模式的重复。但同时也意味着，Go 语言暂时保持了它清晰、直接、没有魔法的风格。&lt;/p&gt;
&lt;p&gt;Go 团队主动发布这样一篇文章，看似回顾历史、承认失败，实则希望引发社区更深层次的讨论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;我们究竟希望 Go 变成什么样子？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;为了简洁，我们愿意牺牲多少明确性？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;无论你是否赞同当前的处理方式，这样的反思和讨论对于语言生态的健康发展，都是极其重要的。&lt;br&gt;
也许下一次提案会再次失败，也许未来某一天，社区终究找到满意的平衡点。但至少，我们可以肯定的是：&lt;br&gt;
&lt;strong&gt;Go 社区一直在探索，一直在反思，也一直在进步。&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;原文链接：&lt;a class=&#34;link&#34; href=&#34;https://go.dev/blog/error-syntax&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://go.dev/blog/error-syntax&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/go-%E5%AE%98%E6%96%B9%E5%86%8D%E8%B0%88%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%96%B0%E8%AF%AD%E6%B3%95%E4%B8%BA%E4%BD%95%E8%BF%9F%E8%BF%9F%E6%97%A0%E6%B3%95%E8%90%BD%E5%9C%B0/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;本文长期链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果您觉得我的博客对你有帮助，请通过 &lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/index.xml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RSS&lt;/a&gt;订阅我。&lt;/li&gt;
&lt;li&gt;或者在&lt;a class=&#34;link&#34; href=&#34;https://x.com/@piaopiaopig&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;X&lt;/a&gt;上关注我。&lt;/li&gt;
&lt;li&gt;如果您有&lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Medium&lt;/a&gt;账号，能给我个关注嘛？我的文章第一时间都会发布在Medium。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Go 的 map 为什么变慢了?.zh-cn</title>
        <link>https://huizhou92.com/zh-cn/p/go-%E7%9A%84-map-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%98%E6%85%A2%E4%BA%86.zh-cn/</link>
        <pubDate>Tue, 20 May 2025 22:18:57 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/go-%E7%9A%84-map-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%98%E6%85%A2%E4%BA%86.zh-cn/</guid>
        <description>&lt;img src="https://images.hxzhouh.com/blog-images/2025/05/a7748f1ab7e01c49c0f35f9591f6cfd3.png" alt="Featured image of post Go 的 map 为什么变慢了?.zh-cn" /&gt;&lt;blockquote&gt;
&lt;p&gt;这篇文章解释了为什么在 Go 1.24 版本中，你的程序可能因为 map 变慢了，以及 Go 团队是怎么计划修复这个问题的。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Golang 1.24 中最吸引我的功能就是 &lt;strong&gt;SwissMap&lt;/strong&gt;，在以前的非官方实现中，有些场景能够提升50% 的性能，官方的实现中，也有不小的性能提升。&lt;br&gt;
详情参考我以前的文章:&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/swisstable-%E4%BC%9A%E6%88%90%E4%B8%BA-golang-std-map%E5%98%9B/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;SwissTable 会成为 Golang std map嘛？&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/go-124-%E7%9A%84-swiss-map%E5%85%BC%E5%AE%B9%E6%80%A7%E6%89%A9%E5%B1%95%E5%93%88%E5%B8%8C%E4%B8%8E%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 1.24 的 Swiss Map：兼容性、扩展哈希与遗留问题&lt;/a&gt;&lt;/p&gt;
&lt;!-- more--&gt;
&lt;p&gt;但是 如果你在使用 Go 1.24 时可能会发现&lt;strong&gt;SwissMap&lt;/strong&gt; 没有达到预期的表现，甚至程序运行变慢了，特别是在 Map很大的时候，这不是你的幻觉，确实存在这个问题。&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/05/4b861f761a7ffbfbd6d6a5cad8010276.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20250520225045&#34;
	
	
&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://x.com/valyala/status/1879988053076504761&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://x.com/valyala/status/1879988053076504761&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个问题记录在 &lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/70835&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Issue #70835&lt;/a&gt; 中，开发者们正在努力解决它。&lt;/p&gt;
&lt;h2 id=&#34;问题出在哪&#34;&gt;问题出在哪？
&lt;/h2&gt;&lt;p&gt;Go 的 map 在新版中使用了Swiss Table，它在小 map 和高并发的场景下非常快。但是当 map 很大、数据又不在 CPU 缓存里（也就是说，数据是“冷”的），就会变慢。&lt;/p&gt;
&lt;p&gt;为什么会这样呢？&lt;/p&gt;
&lt;p&gt;因为 SwissMap 的内部结构比较复杂，它会分几层来存储数据：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先是一个 map 的头部结构&lt;/li&gt;
&lt;li&gt;它指向一个目录，这个目录是多个 table 的指针组成的列表&lt;/li&gt;
&lt;li&gt;每个 table 里面有控制信息、key 和 value&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/01/784e3f6a0ff90601480a2da80f3cb9d0.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当你查找一个 key 的时候，可能需要进行 &lt;strong&gt;4 到 6 次跳转&lt;/strong&gt;，每一次都可能遇到缓存未命中。这样就会导致 CPU 忙着从内存取数据，速度就慢了。&lt;/p&gt;
&lt;p&gt;像 Prometheus 这样的大型项目就发现了这个问题。他们升级到 Go 1.24 后，CPU 使用率上升了很多，经调查发现就是因为 map 的查找变慢了。&lt;/p&gt;
&lt;h2 id=&#34;是怎么发现的&#34;&gt;是怎么发现的？
&lt;/h2&gt;&lt;p&gt;问题并不是在测试用例里发现的，而是在真实的线上场景中出现的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用了很大的 map（比如几兆字节大小）&lt;/li&gt;
&lt;li&gt;经常读取 map 里的数据&lt;/li&gt;
&lt;li&gt;数据不在 CPU 的高速缓存里&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Go 团队的工程师 Michael Pratt 通过做很多测试，找到了 map 访问变慢的原因，并在 &lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/70835&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Issue #70835&lt;/a&gt; 中详细说明。&lt;/p&gt;
&lt;h2 id=&#34;怎么修&#34;&gt;怎么修？
&lt;/h2&gt;&lt;p&gt;为了让 map 更快，他们计划做以下几件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;简化目录结构&lt;/strong&gt;：把原来存指针的列表改成直接存结构，减少一次跳转&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制信息更紧凑&lt;/strong&gt;：把控制信息安排得更集中，这样更容易被 CPU 一次加载&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分离 key 和 value&lt;/strong&gt;：改成“key-key-key + value-value-value”的结构，这样可以优化加载顺序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对齐控制字节&lt;/strong&gt;：把控制信息按照 CPU 缓存对齐，减少未命中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些改动并不简单，因为会影响到 Go 的运行时核心：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要确保垃圾回收能正常工作&lt;/li&gt;
&lt;li&gt;map 扩容和缩容逻辑要更新&lt;/li&gt;
&lt;li&gt;要确保对小 map 的性能没有影响&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;哪些地方在讨论这个&#34;&gt;哪些地方在讨论这个？
&lt;/h2&gt;&lt;p&gt;这个问题被广泛讨论和跟踪，可以通过&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/70835&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Issue #70835&lt;/a&gt;  了解更多的 细节。 &lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/milestone/122&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go Release Dashboard&lt;/a&gt; 中已经标记这个问题将会在 Go1.25 中解决&lt;br&gt;
此外 &lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/71368&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Issue #71368&lt;/a&gt; 中也讨论了 另一个与内存布局的问题。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结
&lt;/h2&gt;&lt;p&gt;Go 团队一直在努力让语言运行得更快更稳。SwissMap 是个好改进，但它也带来了新挑战，比如这次的冷缓存性能下降。&lt;br&gt;
Issue #70835 展示了 Go 是如何通过社区反馈不断进步的。感谢像 Prometheus 这样的开源项目，他们的报告帮助 Go 做得更好。&lt;br&gt;
如果一切顺利，Go 1.25 就能把速度和稳定性都带回来。&lt;br&gt;
我们一起期待吧！&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Green Tea GC: Golang 的 ZGC？</title>
        <link>https://huizhou92.com/zh-cn/p/green-tea-gc-golang-%E7%9A%84-zgc/</link>
        <pubDate>Mon, 05 May 2025 16:30:26 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/green-tea-gc-golang-%E7%9A%84-zgc/</guid>
        <description>&lt;img src="https://images.hxzhouh.com/blog-images/2025/05/fb6313678681ee8e97a05ee521bd0e20.png" alt="Featured image of post Green Tea GC: Golang 的 ZGC？" /&gt;&lt;p&gt;近年来，Go 语言的垃圾回收（GC）机制虽然经历了多个版本优化，但它的性能瓶颈，尤其在高并发与大规模内存场景下，依然是开发者关注的重点。最近，Go 官方在 GitHub 上提出的 &lt;strong&gt;Green Tea GC&lt;/strong&gt;（#73581）引发了热议：它能否进一步解决 Go GC 的耗时问题？本文将深入解析 Go GC 的设计、缺点、实测表现，并带你了解 Green Tea GC 的技术突破。&lt;/p&gt;
&lt;!-- more--&gt;
&lt;h2 id=&#34;-go-gc-的设计与实现&#34;&gt;📦 Go GC 的设计与实现
&lt;/h2&gt;&lt;p&gt;自 Go 1.5 起，Go 使用并发标记-清除（concurrent mark-sweep）算法，结合“三色标记”模型与 Yuasa 写屏障。&lt;/p&gt;
&lt;p&gt;简而言之，Go GC 会在后台并发地遍历堆内存，标记可达对象，并逐步清除未被引用的内存块。整个回收过程中，Go 追求&lt;strong&gt;低延迟、低停顿&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;✅ 并发标记、并发清除&lt;br&gt;
✅ 不会移动对象（即 no compaction）&lt;br&gt;
✅ 按 span（内存块）分批清扫，减少单次 STW（Stop-the-World）时长&lt;/p&gt;
&lt;p&gt;这种设计的直接好处是：应用大部分时间能与 GC 并行工作，最大停顿时间通常低于毫秒级。&lt;/p&gt;
&lt;h2 id=&#34;-go-gc-的已知问题&#34;&gt;🚧 Go GC 的已知问题
&lt;/h2&gt;&lt;p&gt;虽然 Go GC 的延迟表现优秀，但它在耗时和扩展性上仍有几个硬伤，尤其体现在：&lt;/p&gt;
&lt;p&gt;1️⃣ &lt;strong&gt;内存访问低效&lt;/strong&gt;&lt;br&gt;
GC 的标记阶段会跨对象跳跃，导致 CPU 频繁 cache miss、等待内存，约 35% 的 GC CPU 周期被耗在“等内存”。这在 NUMA 架构或多核大内存机器上尤为明显。&lt;/p&gt;
&lt;p&gt;2️⃣ &lt;strong&gt;缺乏分代收集&lt;/strong&gt;&lt;br&gt;
Go GC 没有分代机制，所有对象一视同仁，这在高分配率场景下显得笨重。Pinterest 工程师曾指出，内存压力一旦增大，GC 就会暴增 CPU 消耗，引发延迟激增。&lt;/p&gt;
&lt;p&gt;3️⃣ &lt;strong&gt;频繁 GC 带来的 CPU 占用&lt;/strong&gt;&lt;br&gt;
Twitch 工程团队曾报告：即便在中小堆内存下（&amp;lt;450 MiB），系统稳态下每秒会触发 8–10 次 GC，每分钟累计 400–600 次，GC 占用约 &lt;strong&gt;30% 的 CPU 时间&lt;/strong&gt;。这直接挤压了业务线程的执行空间。&lt;/p&gt;
&lt;h2 id=&#34;-性能测试gc-对-go-程序的影响&#34;&gt;📊 性能测试：GC 对 Go 程序的影响
&lt;/h2&gt;&lt;p&gt;我们来看几个实际基准的变化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Go 1.3/1.4（并发 GC 前）&lt;/strong&gt;&lt;br&gt;
大堆（10GB+）上的 GC 停顿：以秒计算。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Go 1.5（并发 GC 引入后）&lt;/strong&gt;&lt;br&gt;
相同条件下，GC 停顿压缩到 &amp;lt;1ms。&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/05/8d6a9563ad431b76e34d31077cbcd82b.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20250504161704&#34;
	
	
&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Go 1.6–1.8&lt;/strong&gt;&lt;br&gt;
最大堆 200GB，GC 停顿控制在 20ms 以下，甚至常态 1ms。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些进步非常亮眼，但注意：&lt;br&gt;
✅ 延迟控制好了&lt;br&gt;
⚠️ 总耗时和 CPU 消耗依然显著，特别是高负载或高分配场景。&lt;/p&gt;
&lt;h2 id=&#34;-green-tea-gc全新优化方案&#34;&gt;🌿 Green Tea GC：全新优化方案
&lt;/h2&gt;&lt;p&gt;面对这些问题，Go 官方提出了 Green Tea GC。它的核心优化点是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;从单对象扫描，升级为按 span（内存块）批量扫描。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;具体来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小对象（≤512B）标记由单个对象粒度提升为 span 粒度。&lt;/li&gt;
&lt;li&gt;每个 span 中，只有首次标记的对象会将整个 span 推入扫描队列。&lt;/li&gt;
&lt;li&gt;GC 扫描阶段批量处理整个 span，极大提升了内存访问局部性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，Green Tea 改进了并行队列管理，采用类似 Go 调度器的工作窃取机制，进一步提高了多核扩展性。&lt;/p&gt;
&lt;h2 id=&#34;-green-tea-gc-实测表现&#34;&gt;⚡ Green Tea GC 实测表现
&lt;/h2&gt;&lt;p&gt;从初步基准来看，Green Tea GC 带来了有选择性的性能提升：&lt;/p&gt;
&lt;p&gt;✅ &lt;strong&gt;Tile38 基准（高扇出树结构）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GC 开销降低约 35%&lt;/li&gt;
&lt;li&gt;吞吐、延迟、内存使用全面优化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;⚠ &lt;strong&gt;bleve-index 基准（低扇出、频繁变异）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象分布散乱，内存局部性差&lt;/li&gt;
&lt;li&gt;Green Tea 与常规 GC 性能相近，有时略低&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结：Green Tea 并非“银弹”，但在内存局部性良好、多核扩展场景下，它展现了明显优势，并为未来 SIMD 加速等硬件优化奠定了基础。&lt;/p&gt;
&lt;h2 id=&#34;-总结&#34;&gt;🏁 总结
&lt;/h2&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;比较项&lt;/th&gt;
          &lt;th&gt;当前 Go GC&lt;/th&gt;
          &lt;th&gt;Green Tea GC&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;标记粒度&lt;/td&gt;
          &lt;td&gt;单对象&lt;/td&gt;
          &lt;td&gt;span（批量）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;内存局部性&lt;/td&gt;
          &lt;td&gt;差，随机跳跃&lt;/td&gt;
          &lt;td&gt;高，同 span 内批量&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;多核扩展性&lt;/td&gt;
          &lt;td&gt;受限&lt;/td&gt;
          &lt;td&gt;改进，采用工作窃取队列&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;性能提升&lt;/td&gt;
          &lt;td&gt;已接近低延迟上限&lt;/td&gt;
          &lt;td&gt;某些场景下 GC 耗时降 35%&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;应用适用范围&lt;/td&gt;
          &lt;td&gt;普通场景&lt;/td&gt;
          &lt;td&gt;内存局部性好、分配密集场景&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;对于追求极限性能的开发者，Green Tea GC 提供了一个值得关注的新方向。想要试验 Green Tea，可以在 Go 1.25+ 开启实验标志体验。&lt;/p&gt;
&lt;p&gt;📝 &lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/73581&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GitHub Issue #73581&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/31684862/how-fast-is-the-go-1-5-gc-with-terabytes-of-ram&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stackoverflow.com/questions/31684862/how-fast-is-the-go-1-5-gc-with-terabytes-of-ram&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/green-tea-gc-golang-%E7%9A%84-zgc/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;本文长期链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果您觉得我的博客对你有帮助，请通过 &lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/index.xml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RSS&lt;/a&gt;订阅我。&lt;/li&gt;
&lt;li&gt;或者在&lt;a class=&#34;link&#34; href=&#34;https://x.com/@piaopiaopig&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;X&lt;/a&gt;上关注我。&lt;/li&gt;
&lt;li&gt;如果您有&lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Medium&lt;/a&gt;账号，能给我个关注嘛？我的文章第一时间都会发布在Medium。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>【译】：gRPC丑陋的部分</title>
        <link>https://huizhou92.com/zh-cn/p/%E8%AF%91grpc%E4%B8%91%E9%99%8B%E7%9A%84%E9%83%A8%E5%88%86/</link>
        <pubDate>Fri, 14 Mar 2025 09:59:10 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/%E8%AF%91grpc%E4%B8%91%E9%99%8B%E7%9A%84%E9%83%A8%E5%88%86/</guid>
        <description>&lt;p&gt;原文链接：https://kmcd.dev/posts/grpc-the-ugly-parts/&lt;br&gt;
这篇文章是&lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/series/grpc-the-good-and-the-bad/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gRPC：好与坏&lt;/a&gt;系列的一部分。&lt;/p&gt;
&lt;p&gt;gRPC无疑是微服务领域中的一把利器，它带来了效率和性能上的优势，但gRPC也有其丑陋的一面。作为一个在gRPC上花费了大量时间的人，我想揭示这项技术的一些不那么美好的方面。我已经讨论过gRPC的&lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/grpc-the-good-parts&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;优点&lt;/a&gt;和&lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/grpc-the-bad-parts&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;缺点&lt;/a&gt;，现在让我们来谈谈它的丑陋之处。&lt;/p&gt;
&lt;h2 id=&#34;代码生成&#34;&gt;代码生成
&lt;/h2&gt;&lt;p&gt;首先，我不得不说一下从&lt;code&gt;protobuf&lt;/code&gt;生成的代码有多么丑陋。这些代码通常很冗长、复杂且难以阅读。尽管它并不是为了手动编辑而设计的，但这会影响代码的可读性和可维护性，尤其是在将gRPC集成到大型项目中时。最近在大多数语言中，这种情况已经有所改善，但仍然存在一些粗糙的地方。&lt;/p&gt;
&lt;h3 id=&#34;语言特定的怪癖&#34;&gt;语言特定的怪癖
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;protobuf&lt;/code&gt;和&lt;code&gt;gRPC&lt;/code&gt;的初始实现常常偏离语言特定的规范，尤其是在HTTP处理方面。这在一定程度上源于强制支持&lt;code&gt;HTTP/2&lt;/code&gt;的决定，这一决定后来被证明限制了&lt;code&gt;gRPC&lt;/code&gt;在前端的应用。我们现在从&lt;code&gt;gRPC-Web&lt;/code&gt;中了解到，&lt;code&gt;trailer&lt;/code&gt;并不是像gRPC这样的协议的硬性要求。在这一决定之后，我们现在需要改进&lt;code&gt;protobuf&lt;/code&gt;和&lt;code&gt;gRPC&lt;/code&gt;的语言实现，使其更符合每种语言的习惯。&lt;/p&gt;
&lt;p&gt;对于Go语言来说，避免使用&lt;code&gt;net/http&lt;/code&gt;包是一个艰难的决定，因为这使得在与其他类型的HTTP API一起使用gRPC端点时变得更加困难，并且难以复用HTTP中间件。他们最终在grpc-go中添加了一个&lt;a class=&#34;link&#34; href=&#34;https://pkg.go.dev/google.golang.org/grpc#Server.ServeHTTP&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;ServeHTTP()&lt;/code&gt;&lt;/a&gt;接口，作为使用Go标准库中的HTTP服务器的一种实验性方法，但使用这种方法会导致&lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/benchmarking-go-grpc/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;显著的性能损失&lt;/a&gt;。也许他们这样做是出于性能考虑？如果是这样，这无疑是一个将gRPC与Go生态系统其他部分割裂的权衡。&lt;/p&gt;
&lt;p&gt;有时，语言特定的怪癖实际上会影响你如何设计protobuf类型。如果你遵循&lt;a class=&#34;link&#34; href=&#34;https://buf.build/docs/best-practices/style-guide&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Buf&lt;/a&gt;的风格建议，枚举的名称应该以枚举名的大写蛇形版本作为前缀，就像这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FooBar&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;FOO_BAR_UNSPECIFIED&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;FOO_BAR_FIRST_VALUE&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;FOO_BAR_SECOND_VALUE&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这在&lt;a class=&#34;link&#34; href=&#34;https://buf.build/docs/lint/rules#enum_value_prefix&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;buf的lint规则描述&lt;/a&gt;中有更好的解释，但这种风格指南之所以如此，是因为C++的枚举作用域规则，这使得在同一包中无法有两个具有相同枚举值名称的枚举值。虽然这种约定源于C++的作用域规则，但它影响了你应该如何设计所有的protobuf文件。为什么枚举内部的作用域不足以让C++编译器生成唯一的名称？为什么这种缺陷会影响风格指南，并进而影响所有目标语言？对我来说，这有点丑陋，因为某些语言实现的怪癖以不直观的方式冒了出来。&lt;/p&gt;
&lt;h3 id=&#34;生成的代码甚至不够快&#34;&gt;生成的代码甚至不够快
&lt;/h3&gt;&lt;p&gt;生成代码的一个好处是，你可以生成一些正常人不会写的代码，以获得一些性能优化。然而，如果你查看一些从protobuf生成的代码，你会发现大量使用了运行时反射。为什么？在某种程度上，我是在说生成的代码&lt;strong&gt;不够丑陋&lt;/strong&gt;。让我们看一个具体的例子。请注意，这将是一个非常Go特定的部分，因为我大部分关于protobuf的经验都是在Go中。然而，相同的策略已经应用于大多数语言。&lt;/p&gt;
&lt;p&gt;让我们来看一个Go中的超级简单示例。以下是protobuf：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Hello&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这是由protoc生成的类型：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Hello&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;         &lt;span class=&#34;nx&#34;&gt;protoimpl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;MessageState&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;sizeCache&lt;/span&gt;     &lt;span class=&#34;nx&#34;&gt;protoimpl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;SizeCache&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;unknownFields&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;protoimpl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;UnknownFields&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;Name&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`protobuf:&amp;#34;bytes,1,opt,name=name,proto3&amp;#34; json:&amp;#34;name,omitempty&amp;#34;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// With these methods, contents are stripped&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Reset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ProtoMessage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ProtoReflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;protoreflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Message&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;实际上，并没有为这个类型定义专门的&lt;code&gt;Marshal()&lt;/code&gt;或&lt;code&gt;Unmarshal()&lt;/code&gt;函数。这意味着序列化是通过运行时反射来实现的。反射通常被认为较慢，因为它&lt;strong&gt;确实&lt;/strong&gt;较慢。我觉得奇怪的是，没有为Go生成优化的、类型特定的序列化代码。话虽如此，你可以通过使用一个名为&lt;a class=&#34;link&#34; href=&#34;https://github.com/planetscale/vtprotobuf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vtprotobuf&lt;/a&gt;的单独protoc插件来获得这一点，该插件将为每个protobuf类型生成专门的marshal和unmarshal函数。它还允许使用类型特定的内存池，这也有助于减少分配并提高性能。根据我的&lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/benchmarking-go-grpc/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;测试&lt;/a&gt;，只需添加&lt;code&gt;vtprotobuf&lt;/code&gt;而不做任何代码更改，就可以将性能提高2-4%。这基本上是“免费”的2-4%，所以我觉得很奇怪，这竟然不是标准编译器的一部分。&lt;a class=&#34;link&#34; href=&#34;https://github.com/sudorandom/go-grpc-bench/blob/v0.0.1/gen/flex_vtproto.pb.go#L573&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;你可能不喜欢它，但这就是峰值性能的样子&lt;/a&gt;。无论如何，这个项目需要更多的关注和支持。&lt;/p&gt;
&lt;p&gt;请注意，还有其他一些项目声称在标准protobuf库的基础上取得了惊人的性能提升。他们确实通过做出一些权衡来实现这些性能提升，但很多时候，额外的复杂性是值得的。&lt;/p&gt;
&lt;p&gt;你可能会读到这一部分并想：“好吧，这会增加生成的代码量，增加二进制文件或包的大小，在某些环境中，你可能不希望这样。”这是事实，这就是为什么protobuf有一个&lt;code&gt;optimize_for&lt;/code&gt;选项，所以你可以注释以下之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;option optimize_for = SPEED;&lt;/code&gt; - 更冗长、更快的代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;option optimize_for = CODE_SIZE;&lt;/code&gt; - 更小的代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;option optimize_for = LITE_RUNTIME;&lt;/code&gt; - 旨在在较小的运行时上运行，省略了描述符和反射等功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请参阅&lt;a class=&#34;link&#34; href=&#34;https://protobuf.dev/programming-guides/proto3/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方protobuf文档&lt;/a&gt;中关于&lt;code&gt;optimize_for&lt;/code&gt;的完整描述。虽然这些选项存在，但它们实际上并没有用于大多数目标语言。将来，我完全希望看到大部分&lt;code&gt;vtprotobuf&lt;/code&gt;被整合到Go的标准protobuf编译器中，并在&lt;code&gt;optimize_for = SPEED&lt;/code&gt;时使用。将类似&lt;code&gt;vtprotobuf&lt;/code&gt;的优化整合到标准protobuf编译器中，可以为Go带来显著的性能提升，其他语言也可能存在类似的机会。&lt;/p&gt;
&lt;h2 id=&#34;必填字段&#34;&gt;必填字段
&lt;/h2&gt;&lt;p&gt;Protobuf的维护者在必填字段方面学到了一些艰难的教训。他们觉得自己犯了一个严重的错误，以至于他们推出了一个新版本的protobuf，即proto3，只是为了从规范中删除必填字段。为什么？“必填字段有害”宣言的作者在&lt;a class=&#34;link&#34; href=&#34;https://news.ycombinator.com/item?id=18190005&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;一篇冗长的Hacker News评论&lt;/a&gt;中谈到了这一点，但重要的是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现实世界的实践也表明，许多最初被认为是“必填”的字段随着时间的推移往往会变成可选的，因此有了“必填字段有害”的宣言。在实践中，你希望将所有字段声明为可选的，以便为变化提供最大的灵活性。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;这一点在&lt;a class=&#34;link&#34; href=&#34;https://protobuf.dev/programming-guides/dos-donts/#add-required&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方protobuf风格指南&lt;/a&gt;中得到了呼应，他们建议添加注释来指示某个字段是必填的。如果我们讨论的是将消息从A传递到B，我完全同意这种思路。然而，仅仅因为某些字段被认为是“必填”的会随着时间的推移而变化，并不意味着必填字段不存在。仍然需要代码来强制执行这一要求，老实说，我不想编写这些代码。因此，我认为在不编写大量空检查的情况下处理必填字段的最佳方法是使用&lt;a class=&#34;link&#34; href=&#34;https://github.com/bufbuild/protovalidate&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;protovalidate&lt;/a&gt;或类似的库，这些库具有protobuf选项，允许你注释哪些字段是必填的。然后在服务器和/或客户端上有代码可以使用库来强制执行这些要求。在我看来，这兼具了两者的优点：你仍然可以以不会完全破坏消息完整性的方式声明必填字段。&lt;/p&gt;
&lt;p&gt;我不喜欢这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;User&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;int32&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// required.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我喜欢这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;User&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;int32&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf.validate.field&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;required&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我是&lt;a class=&#34;link&#34; href=&#34;https://github.com/bufbuild/protovalidate&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;protovalidate&lt;/a&gt;的忠实粉丝，我已经多次使用它并为其做出了贡献。一般来说，我认为protobuf字段的&lt;a class=&#34;link&#34; href=&#34;https://protobuf.dev/programming-guides/proto3/#customoptions&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;自定义选项&lt;/a&gt;是protobuf的一个未被充分利用的超能力。&lt;/p&gt;
&lt;h2 id=&#34;难以入门&#34;&gt;难以入门
&lt;/h2&gt;&lt;p&gt;尽管gRPC具有不可否认的优势，但其学习曲线可能很陡峭。对于新手来说，开始使用&lt;code&gt;protobuf&lt;/code&gt;、理解工具链以及设置必要的基础设施可能会让人望而生畏，这使得初始采用的障碍比使用更简单的基于JSON的API更高。为什么它如此陡峭？嗯，它在大多数语言中引入了非惯用的工具链。有一些语言支持的例子使得protobuf生成变得无缝。&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/en-us/aspnet/core/grpc/basics&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Grpc.Tools&lt;/a&gt; for &lt;code&gt;.NET&lt;/code&gt;就是一个闪亮的例子，展示了如何将protobuf工具链更紧密地集成到标准语言工具链中。我们需要更多这样的例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kmcd.dev/posts/grpc-the-ugly-parts/learning-curve.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;当许多使用和依赖protobuf和gRPC的人积极不希望gRPC扩展到前端，并认为推动这一方向会导致不了解情况的人侵入后端领域时，陡峭的学习曲线并没有帮助，他们认为只有他们足够聪明才能在后端工作。这是精英主义的守门行为，不幸的是，这种行业普遍存在。我相信gRPC在Web前端中与在微服务中一样有其地位。&lt;/p&gt;
&lt;p&gt;我通过帮助其他人使用protobuf学到了很多。你可能会在&lt;a class=&#34;link&#34; href=&#34;https://buf.build/links/slack&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Buf的Slack频道&lt;/a&gt;或相关讨论中看到我，因为我确实从中受益匪浅。许多文章的想法直接来自于在那里回答问题。如果我看到某个问题出现的频率足够高，我可能会写一篇文章来讨论它。我认为protobuf和gRPC社区需要更多这种态度。&lt;/p&gt;
&lt;p&gt;我相信陡峭的学习曲线（可以通过工具链来缓解），加上一些后端开发者的抵制（可以通过……同理心来缓解？），已经减缓了它在Web开发中的广泛采用。&lt;/p&gt;
&lt;h2 id=&#34;grpc有其历史&#34;&gt;gRPC有其历史
&lt;/h2&gt;&lt;p&gt;gRPC最初专注于微服务，并且与HTTP/2的紧密联系阻碍了它在Web开发中的广泛采用。即使有了&lt;a class=&#34;link&#34; href=&#34;https://grpc.io/blog/state-of-grpc-web/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gRPC-Web的出现&lt;/a&gt;，仍然有一种看法认为它在前端生态系统中并不是一等公民。与&lt;a class=&#34;link&#34; href=&#34;https://tanstack.com/query/latest&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TanStack Query&lt;/a&gt;等流行前端库缺乏强大的集成进一步巩固了这种看法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kmcd.dev/posts/grpc-the-ugly-parts/bad-blood.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;我认为通过改进工具链，有真正的机会让更多前端开发者对gRPC感到兴奋。目前，整个行业正在围绕“前端”和“后端”之间的界限进行一场巨大的讨论，我认为无论结果如何，我们都会看到更多使用gRPC的TypeScript代码。&lt;/p&gt;
&lt;h2 id=&#34;grpc中的g&#34;&gt;gRPC中的“g”
&lt;/h2&gt;&lt;p&gt;虽然&lt;a class=&#34;link&#34; href=&#34;https://grpc.io/docs/what-is-grpc/faq/#what-does-grpc-stand-for&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gRPC项目声称&lt;/a&gt; gRPC中的“g”是一个&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Backronym&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;反向缩略词&lt;/a&gt;，代表“gRPC”，但它最初代表Google，因为是Google开发并发布了protobuf和gRPC。&lt;br&gt;
&lt;img src=&#34;https://kmcd.dev/posts/grpc-the-ugly-parts/google.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;google 的墓碑&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;关于Google对gRPC和protobuf的长期承诺，始终存在一个悬而未决的问题。他们会继续投资于这些开源项目，还是会在优先级发生变化时突然撤资？请记住，Google&lt;a class=&#34;link&#34; href=&#34;https://techcrunch.com/2024/05/01/google-lays-off-staff-from-flutter-dart-python-weeks-before-its-developer-conference/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;最近裁掉了Flutter、Dart和Python团队的大部分成员&lt;/a&gt;。Protobuf社区正在发展，但它是否足够自给自足以应对这种情况？&lt;/p&gt;
&lt;h2 id=&#34;它尚未完成&#34;&gt;它尚未完成
&lt;/h2&gt;&lt;p&gt;其他人说gRPC不成熟，不是因为它的年龄，而是因为它的生态系统发展程度。我倾向于同意，因为它缺少我期望在一个成熟生态系统中看到的功能和工具。&lt;/p&gt;
&lt;h3 id=&#34;缺少包管理器&#34;&gt;缺少包管理器
&lt;/h3&gt;&lt;p&gt;在没有专门工具的情况下，跨多个项目或仓库共享protobuf定义是一个持续的挑战。虽然像&lt;a class=&#34;link&#34; href=&#34;https://bazel.build/reference/be/protocol-buffer&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Bazel&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://www.pantsbuild.org/2.21/docs/go/integrations/protobuf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Pants&lt;/a&gt;和&lt;a class=&#34;link&#34; href=&#34;https://buf.build/product/bsr&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Buf的BSR&lt;/a&gt;这样的解决方案存在，但我在“现实世界”中使用protobuf的经验……参差不齐。有一些由Google开发的开源项目，它们使用bash脚本拼凑在一起，在手动调用&lt;code&gt;protoc&lt;/code&gt;之前下载依赖项。想象一下，一个编程语言没有管理依赖项的解决方案。这太疯狂了。我认为&lt;a class=&#34;link&#34; href=&#34;https://grpc.io/blog/bazel-rules-protobuf/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Bazel&lt;/a&gt;和&lt;a class=&#34;link&#34; href=&#34;https://buf.build/docs/ecosystem/cli-overview&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Buf工具链&lt;/a&gt;很好地解决了这个问题，但我只是感到沮丧，我遇到的每个使用protobuf的仓库都以最定制化的方式解决了这个问题。社区需要团结起来改进这一点。有一个名为&lt;a class=&#34;link&#34; href=&#34;https://github.com/helsing-ai/buffrs&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Buffrs&lt;/a&gt;的开源仓库似乎正在解决这个问题。我还没有亲自使用过它，但到目前为止它看起来还不错。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kmcd.dev/posts/grpc-the-ugly-parts/build.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;关于依赖项，我想指出的是，&lt;a class=&#34;link&#34; href=&#34;https://protobuf.dev/reference/protobuf/google.protobuf/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Google的“众所周知的”protobuf类型&lt;/a&gt;享有被内置到protoc中的特权。虽然这些类型非常有用且无价，但它们的特权使得其他有用的protobuf类型库难以存在和繁荣。仅仅将这些protobuf定义内置到protoc（和其他工具链中）是对没有真正和一致的依赖管理故事的逃避。&lt;/p&gt;
&lt;h3 id=&#34;编辑器支持&#34;&gt;编辑器支持
&lt;/h3&gt;&lt;p&gt;Protobuf代码生成的编辑器集成还有很多不足之处。如果编辑器能够智能地将生成的代码链接回其protobuf源，那将非常有帮助。这将提供更无缝的体验，但工具链还不够智能。此外，我认为每个人都应该使用&lt;a class=&#34;link&#34; href=&#34;https://buf.build/docs/editor-integration&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Buf的编辑器支持&lt;/a&gt;。如今，开发者期望在编辑器中内置linter和自动格式化工具。而对于protobuf来说，有&lt;a class=&#34;link&#34; href=&#34;https://buf.build/docs/lint/rules&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;非常真实的原因&lt;/a&gt;需要遵循linter的建议。&lt;/p&gt;
&lt;p&gt;像&lt;a class=&#34;link&#34; href=&#34;https://trpc.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;tRPC&lt;/a&gt;这样的项目展示了紧密集成和意见化设计选择的好处——这是protobuf由于其性质无法完全复制的。然而，我仍然希望protobuf生态系统能够发展，提供类似的简化开发者体验。&lt;/p&gt;
&lt;h3 id=&#34;丑陋的文档&#34;&gt;丑陋的文档
&lt;/h3&gt;&lt;p&gt;我从未见过从protobuf生成的文档不是超级丑陋的。我认为，由于gRPC历来是后端服务，后端开发者从未真正努力使用protoc插件生成漂亮的文档输出。我通过&lt;a class=&#34;link&#34; href=&#34;https://github.com/sudorandom/protoc-gen-connect-openapi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;制作一个protoc插件&lt;/a&gt;解决了这个问题，该插件可以从给定的protobuf文件生成OpenAPI。然后我使用众多漂亮的工具之一来显示OpenAPI规范。这远比让我设计一个像样的文档容易得多。从protobuf生成OpenAPI的另一个附带好处是能够利用该生态系统，因为它不仅仅是文档。&lt;/p&gt;
&lt;p&gt;让我们看一个真实的例子。这是使用少数几个从protobuf生成文档的工具之一，&lt;a class=&#34;link&#34; href=&#34;https://github.com/pseudomuto/protoc-gen-doc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;protoc-gen-doc&lt;/a&gt;生成的文档：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kmcd.dev/posts/grpc-the-ugly-parts/protoc-gen-doc.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;将其与一些OpenAPI工具链进行比较。这是使用&lt;a class=&#34;link&#34; href=&#34;https://github.com/stoplightio/elements&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Elements&lt;/a&gt;生成的，但还有许多其他同样精美的替代方案：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kmcd.dev/posts/grpc-the-ugly-parts/elements.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;指责单个插件并说默认模板不如OpenAPI替代品好看有点不公平，因为实际上你确实在protoc-gen-doc中有更多的灵活性。它允许你指定自己的模板，因此它可以像你希望的那样漂亮。然而，这确实符合我的观点：在REST世界中，工具链比gRPC更完善和精致。这是一个可以解决的问题，但我们需要让前端开发者和设计师对gRPC感到兴奋，或者后端工程师需要开始磨练他们的设计技能。&lt;/p&gt;
&lt;p&gt;我还想指出，OpenAPI/Swagger接口通常有一种方法可以直接从文档网站测试端点。这在gRPC世界中的等效工具中是完全缺失的。此外，使用大多数OpenAPI文档工具，你可以清楚地看到哪些字段是必填的，并会显示具有约束的字段。因此，它不仅更漂亮，而且功能也更强大。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论
&lt;/h2&gt;&lt;p&gt;gRPC虽然在许多方面是一个强大的工具，但仍然有成长的空间。生成代码的不理想之处，加上依赖项管理和protobuf模式演变的挑战，可能会给开发者带来摩擦。缺乏直观的编辑器集成以及历史上对后端服务的关注，也阻碍了它在Web开发中的广泛采用。&lt;/p&gt;
&lt;p&gt;然而，我认为gRPC的未来是光明的，并且可以变得不那么丑陋。社区正在积极应对这些挑战，开发诸如&lt;a class=&#34;link&#34; href=&#34;https://buf.build/product/cli&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;buf CLI&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://github.com/bufbuild/protovalidate&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;protovalidate&lt;/a&gt;和&lt;a class=&#34;link&#34; href=&#34;https://github.com/sudorandom/protoc-gen-connect-openapi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;protoc-gen-connect-openapi&lt;/a&gt;等工具来弥合差距并增强开发者体验。随着gRPC的成熟和&lt;a class=&#34;link&#34; href=&#34;https://trends.google.com/trends/explore?date=all&amp;amp;q=%2Fm%2F04dzxdz,%2Fg%2F11cp5mklv8,RESTful&amp;amp;hl=en&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;其生态系统的扩展&lt;/a&gt;，我们可以期待改进的工具链、更好的编辑器支持以及更顺畅地融入前端世界。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/%E8%AF%91grpc%E4%B8%91%E9%99%8B%E7%9A%84%E9%83%A8%E5%88%86/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;本文长期链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果您觉得我的博客对你有帮助，请通过 &lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/index.xml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RSS&lt;/a&gt;订阅我。&lt;/li&gt;
&lt;li&gt;或者在&lt;a class=&#34;link&#34; href=&#34;https://x.com/@piaopiaopig&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;X&lt;/a&gt;上关注我。&lt;/li&gt;
&lt;li&gt;如果您有&lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Medium&lt;/a&gt;账号，能给我个关注嘛？我的文章第一时间都会发布在Medium。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>【译】grpc:好的部分</title>
        <link>https://huizhou92.com/zh-cn/p/%E8%AF%91grpc%E5%A5%BD%E7%9A%84%E9%83%A8%E5%88%86/</link>
        <pubDate>Wed, 12 Mar 2025 10:32:24 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/%E8%AF%91grpc%E5%A5%BD%E7%9A%84%E9%83%A8%E5%88%86/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/03/4d500118b2f1f53be2e1f5651b0a7773.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;br&gt;
原文地址: &lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/grpc-the-good-parts/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kmcd.dev/posts/grpc-the-good-parts/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虽然 REST API 仍是 Web 服务开发的主流选择，但 gRPC 正凭借其卓越的性能、效率和开发体验，受到越来越多的青睐。你可能看过我的文章《&lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/grpc-the-bad-parts/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gRPC 的不足之处&lt;/a&gt;》，其中提到了我对 gRPC 的一些不满。根据那篇文章的众多反馈，我本可以再写一篇续集来继续吐槽。但今天，我们换个角度，来探讨 gRPC &lt;strong&gt;优秀&lt;/strong&gt; 的一面。&lt;br&gt;
显然，许多人没有读完上篇文章的结尾——我曾指出，文中提到的许多问题如今已不复存在。因此，我决定专门写一篇文章，聚焦 gRPC 的优势。&lt;br&gt;
让我们深入探讨 gRPC 在现代 Web 开发中的关键价值。&lt;/p&gt;
&lt;h2 id=&#34;性能&#34;&gt;性能
&lt;/h2&gt;&lt;p&gt;这一点可能会引发争议，但 &lt;a class=&#34;link&#34; href=&#34;https://protobuf.dev/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Protocol Buffers&lt;/a&gt; 确实比 JSON 和 XML 更高效。&lt;a class=&#34;link&#34; href=&#34;https://streamdal.com/blog/ptotobuf-vs-json-for-your-event-driven-architecture/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;多项测试&lt;/a&gt;都证明了这一点。Protobuf 的高效性主要体现在以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;字段名不包含在消息中&lt;/strong&gt;：Protobuf 使用数字标识字段，而 JSON 需要存储完整的字段名。通常，Protobuf 的字段编号仅占 1-2 字节，而 JSON 的字段名可能远超这个大小。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/%E8%A7%A3%E6%9E%90go-varint-%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;VARINT 类型优化&lt;/a&gt;&lt;/strong&gt;：小整数即使声明为 int64 也只需 1 字节。在大多数应用场景中，我们很少使用大整数，这种优化能显著减少数据占用，相比 ASCII 编码的数字更加高效。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;压缩优化&lt;/strong&gt;：虽然 Protobuf 在字符串和字节数组方面并无特别优势，但 gRPC 支持数据压缩，使其至少能与 HTTP/JSON 方案持平。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在实际应用中，改用 Protobuf 编码后，我亲眼见证了数据传输量&lt;strong&gt;减少 50%&lt;/strong&gt; 的效果。&lt;br&gt;
当然，仍然有人&lt;a class=&#34;link&#34; href=&#34;https://reasonablypolymorphic.com/blog/protos-are-wrong/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;质疑 Protobuf&lt;/a&gt;。对我而言，最“致命”的缺陷是「map 的值不能是另一个 map」。从实现角度来看，这本应是可行的，但实际上并不被支持。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;MapMessage&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MapValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;values&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;MapValue&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nested&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;最令人困惑的是，我不明白为什么 &lt;code&gt;value_type&lt;/code&gt; 不能是 map。最终只能通过包装类型来嵌套 map，虽然可行，但略显繁琐。这类问题在 gRPC 中时有发生。哎，这明明是一篇夸奖 gRPC 的文章，我们回到正题。&lt;/p&gt;
&lt;p&gt;总的来说，Protobuf 在许多方面优于 JSON。当然，如果你更喜欢 JSON，&lt;a class=&#34;link&#34; href=&#34;https://protobuf.dev/programming-guides/proto3/#json&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gRPC 也完全支持 JSON&lt;/a&gt;。虽然 gRPC 消息前会有少量二进制帧字节（不可读），但如果你真的在意这些，可以参考下文 &lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/grpc-the-good-parts/#connectrpc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ConnectRPC&lt;/a&gt; 章节。&lt;/p&gt;
&lt;p&gt;此外，大多数 gRPC 实现都支持自定义编码，因此你甚至可以采用自定义的序列化方案。&lt;/p&gt;
&lt;h2 id=&#34;api-契约&#34;&gt;API 契约
&lt;/h2&gt;&lt;p&gt;告别松散的 API 类型推测。gRPC 依靠 &lt;code&gt;protobuf&lt;/code&gt; 定义，提供了严谨的客户端-服务端契约，带来诸多优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;更少错误&lt;/strong&gt;：明确的数据类型要求减少了数据不匹配的风险。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更好的代码生成&lt;/strong&gt;：支持多语言客户端/服务端代码自动生成，节省开发时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更顺畅的 API 演进&lt;/strong&gt;：有了稳定的契约，API 迭代时不易破坏已有客户端。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动化文档生成&lt;/strong&gt;：API 定义即文档，始终与实现保持同步。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;API 契约的强大之处，在我的另一篇文章《&lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/api-contracts/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;用契约构建 API&lt;/a&gt;》中有更深入的讨论。&lt;/p&gt;
&lt;h2 id=&#34;流式通信&#34;&gt;流式通信
&lt;/h2&gt;&lt;p&gt;gRPC 提供了一流的流式通信支持，消除了许多场景下的轮询需求，特别适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;实时聊天应用&lt;/strong&gt;：支持双向消息流，确保低延迟。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实时更新&lt;/strong&gt;：无需轮询，服务器可主动推送数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;需要持续通信的场景&lt;/strong&gt;：如游戏、金融数据传输等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你来自网络开发领域，可能知道基于 gRPC 的 gNMI 已取代 SNMP。通过 gNMI 订阅计数器更新，无需每分钟轮询网络设备。更多讨论可见《&lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/gnmi/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2024 年为何要选择 gNMI 而非 SNMP&lt;/a&gt;》。&lt;/p&gt;
&lt;h2 id=&#34;跨语言支持&#34;&gt;跨语言支持
&lt;/h2&gt;&lt;p&gt;gRPC 天然支持多语言，几乎涵盖所有主流编程语言。借助代码生成工具，你可以在不同技术栈之间无缝集成。&lt;/p&gt;
&lt;p&gt;这一特性极大提升了团队协作效率，也让开发者能自由选择最适合的工具。&lt;/p&gt;
&lt;h2 id=&#34;推动-http2-发展&#34;&gt;推动 HTTP/2 发展
&lt;/h2&gt;&lt;p&gt;gRPC 是 HTTP/2 普及的有力推动者，借助 HTTP/2 提供：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;多路复用&lt;/strong&gt;：单连接支持多个请求/响应，提升传输效率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;头部压缩&lt;/strong&gt;：减少冗余数据，提高传输速度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;整体性能优化&lt;/strong&gt;：HTTP/2 是更现代的 Web 通信方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http3-进展&#34;&gt;HTTP/3 进展
&lt;/h3&gt;&lt;p&gt;gRPC 正在推进对 HTTP/3 的支持。尽管官方进展缓慢，但已有多个社区实现，如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.NET 的 dotnet-grpc&lt;/li&gt;
&lt;li&gt;Rust 的 Tonic（基于 Hyper）&lt;/li&gt;
&lt;li&gt;Go 语言的 ConnectRPC 与 quic-go&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTTP/3 进一步优化了连接建立速度、解决了&lt;a class=&#34;link&#34; href=&#34;https://blog.cloudflare.com/the-road-to-quic#headoflineblocking&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;队头阻塞&lt;/a&gt;问题，并改善了丢包恢复能力。&lt;/p&gt;
&lt;h2 id=&#34;逐步替换&#34;&gt;逐步替换
&lt;/h2&gt;&lt;p&gt;若想逐步采用 gRPC 或需支持现有 REST 客户端，当前已有成熟方案：&lt;/p&gt;
&lt;h3 id=&#34;jsonhttp-转码&#34;&gt;JSON/HTTP 转码
&lt;/h3&gt;&lt;p&gt;使用 &lt;a class=&#34;link&#34; href=&#34;https://github.com/grpc-ecosystem/grpc-gateway&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gRPC-Gateway&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://cloud.google.com/endpoints&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Google Cloud Endpoints&lt;/a&gt; 或 &lt;a class=&#34;link&#34; href=&#34;https://www.envoyproxy.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Envoy&lt;/a&gt; 等工具，可以在后端享受 gRPC 优势的同时暴露 REST 风格接口。例如定义如下服务：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;service&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Greeter&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;rpc&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SayHello&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HelloRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;returns&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HelloResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;option&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;google.api.http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;/v1/greeter/{name}&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;即可通过 REST 端点访问：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl http://localhost:8080/v1/greeter/world
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这种自动转换能大幅减少支持多种 API 格式的工作量。&lt;/p&gt;
&lt;h3 id=&#34;grpc-web&#34;&gt;gRPC-Web
&lt;/h3&gt;&lt;p&gt;由于浏览器对 HTTP trailers 的支持限制，传统 gRPC 无法直接在 Web 使用。gRPC-Web 协议解决了这个问题，使浏览器也能使用 gRPC，并为仍在使用 HTTP/1.1 的平台（如某些 &lt;a class=&#34;link&#34; href=&#34;https://forum.unity.com/threads/support-for-http-2-with-unitywebrequest.1030510/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Unity&lt;/a&gt; 版本）提供支持。&lt;/p&gt;
&lt;h3 id=&#34;connectrpc&#34;&gt;ConnectRPC
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://connectrpc.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ConnectRPC&lt;/a&gt; 能够从 gRPC 定义自动生成 JSON/HTTP API，同时保持与 gRPC/gRPC-Web 兼容。&lt;a class=&#34;link&#34; href=&#34;https://connectrpc.com/docs/protocol/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Connect 协议&lt;/a&gt;更严格遵循 HTTP 标准，支持如下直观的 curl 调用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    --header &lt;span class=&#34;s2&#34;&gt;&amp;#34;Content-Type: application/json&amp;#34;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    --data &lt;span class=&#34;s1&#34;&gt;&amp;#39;{&amp;#34;name&amp;#34;: &amp;#34;world&amp;#34;}&amp;#39;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    http://localhost:8080/greeter.v1.GreeterService/SayHello
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;twirp&#34;&gt;Twirp
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://twitchtv.github.io/twirp/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Twirp&lt;/a&gt; 由 Twitch 开发，采用类似思路。&lt;a class=&#34;link&#34; href=&#34;https://twitchtv.github.io/twirp/docs/spec_v7.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;其规范&lt;/a&gt;通过 protobuf 生成更符合 HTTP 惯例的 API，但不直接支持 gRPC 协议，需要额外工作实现互操作。&lt;/p&gt;
&lt;h2 id=&#34;工具生态&#34;&gt;工具生态
&lt;/h2&gt;&lt;p&gt;虽然官方工具链仍有不足，但社区生态蓬勃发展：&lt;/p&gt;
&lt;h3 id=&#34;buf-cli&#34;&gt;Buf CLI
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://buf.build/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Buf&lt;/a&gt; 公司推出的 &lt;a class=&#34;link&#34; href=&#34;https://buf.build/product/cli&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Buf CLI&lt;/a&gt; 完全取代了官方的 protoc 编译器。它通过配置化管理 proto 文件依赖和代码生成，提供：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;lint 检查&lt;/strong&gt;：强制代码规范&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;破坏性变更检测&lt;/strong&gt;：防止协议不兼容修改&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简化工作流&lt;/strong&gt;：替代 Makefile 等临时方案&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;第三方插件与工具&#34;&gt;第三方插件与工具
&lt;/h3&gt;&lt;p&gt;gRPC 拥有丰富的插件体系，比如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/pseudomuto/protoc-gen-doc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;protoc-gen-doc&lt;/a&gt;&lt;/strong&gt;：多格式文档生成，支持自定义模板&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/sudorandom/protoc-gen-connect-openapi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;protoc-gen-connect-openapi&lt;/a&gt;&lt;/strong&gt;（作者自荐）：为 ConnectRPC 生成 OpenAPI 规范&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/bufbuild/protovalidate&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;protovalidate&lt;/a&gt;&lt;/strong&gt;：直接在 proto 中定义验证规则，期待其 &lt;a class=&#34;link&#34; href=&#34;https://github.com/bufbuild/protovalidate/issues/67&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TypeScript 支持&lt;/a&gt;实现前后端验证逻辑共享&lt;br&gt;
此外，Postman、Insomnia、k6 等主流工具都已加入 gRPC 支持阵营。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;结语&#34;&gt;结语
&lt;/h2&gt;&lt;p&gt;gRPC 以卓越的性能、强类型契约、流式通信、跨语言能力和 HTTP/2 基础，成为现代 Web 开发的强大工具。无论你是要优化 API 交互，还是构建高效可扩展的系统，gRPC 都值得一试。&lt;br&gt;
随着生态的持续发展，gRPC 的未来充满可能。如果你追求快速、可靠的 API 设计，不妨深入了解并尝试 gRPC，它或许能彻底改变你的开发方式。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/%E8%AF%91grpc%E5%A5%BD%E7%9A%84%E9%83%A8%E5%88%86/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;本文长期链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果您觉得我的博客对你有帮助，请通过 &lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/index.xml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RSS&lt;/a&gt;订阅我。&lt;/li&gt;
&lt;li&gt;或者在&lt;a class=&#34;link&#34; href=&#34;https://x.com/@piaopiaopig&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;X&lt;/a&gt;上关注我。&lt;/li&gt;
&lt;li&gt;如果您有&lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Medium&lt;/a&gt;账号，能给我个关注嘛？我的文章第一时间都会发布在Medium。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>网页图标（Icon）那些事</title>
        <link>https://huizhou92.com/zh-cn/p/%E7%BD%91%E9%A1%B5%E5%9B%BE%E6%A0%87icon%E9%82%A3%E4%BA%9B%E4%BA%8B/</link>
        <pubDate>Tue, 18 Feb 2025 11:30:38 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/%E7%BD%91%E9%A1%B5%E5%9B%BE%E6%A0%87icon%E9%82%A3%E4%BA%9B%E4%BA%8B/</guid>
        <description>&lt;img src="https://images.hxzhouh.com/blog-images/2025/02/65e64661a046efca8dcbc39b98ae2b91.png" alt="Featured image of post 网页图标（Icon）那些事" /&gt;&lt;p&gt;昨天&lt;a class=&#34;link&#34; href=&#34;https://taoshu.in/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;涛叔的博客&lt;/a&gt; 发布了一篇关于友情链接的博客，我毛遂自荐向涛叔请求添加友情链接。涛叔很快回应了我，并且在邮件中友好的提醒我，可以给博客添加一个&lt;code&gt;favicon(icon)&lt;/code&gt;，这样方便RSS订阅用户快速的区分博客。当时我心想 &lt;code&gt;favicon&lt;/code&gt; 是什么？（后端程序员伤不起）&lt;/p&gt;
&lt;!-- more--&gt;
&lt;p&gt;后面我咨询了DeepSeek:&lt;br&gt;
在网页设计中，图标（icon）是一个小而重要的元素。它不仅帮助用户快速识别网站，还能提升用户体验。&lt;/p&gt;
&lt;h3 id=&#34;常见使用场景&#34;&gt;常见使用场景：
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;浏览器标签页&lt;/strong&gt;：显示在网页标题旁边。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;书签栏&lt;/strong&gt;：用户收藏网页时显示。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主屏幕图标&lt;/strong&gt;：移动设备将网页添加到主屏幕时显示。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PWA（渐进式网页应用）&lt;/strong&gt;：作为应用图标使用。&lt;br&gt;
比如这样&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/02/6df56f22e8fad0c4fe55bffcab3ed090.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在浏览器标签页展示图标&#34;
	
	
&gt;&lt;br&gt;
在浏览器标签页展示图标。&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/02/c2530b4f9491c01730c710dcd24a325f.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在书签栏显示图标。&#34;
	
	
&gt;&lt;br&gt;
在书签栏显示图标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;甚至在安卓手机 上，使用chrome浏览器的将网页添加到主屏幕功能。可以显示icon图标。&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/02/861e9e820063fe4d7bbff32e9f8de05b.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;使用 Android Chrome 将网页添加到手机主屏幕&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;如何设置&#34;&gt;如何设置
&lt;/h2&gt;&lt;p&gt;设置icon 最简单的方式是在 网页的 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 中添加 一行。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;link&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;rel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;icon&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;image/png&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;href&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/favicon.png&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果您是使用 hugo 或者其他工具的话，可能会有favicon的设置。&lt;br&gt;
一些大型网站 比如 &lt;code&gt;google.com&lt;/code&gt;、 &lt;code&gt;apple.com&lt;/code&gt; 它们可能需要考虑的问题更多，设置也并不完全一样。&lt;/p&gt;
&lt;h2 id=&#34;一些需要注意的地方&#34;&gt;一些需要注意的地方
&lt;/h2&gt;&lt;p&gt;为了优化使用体验，在各个场景下都达到最佳的显示效果， icon的的尺寸也是有说法。&lt;/p&gt;
&lt;h3 id=&#34;常见尺寸&#34;&gt;常见尺寸：
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;16x16&lt;/strong&gt;：浏览器标签页图标。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;32x32&lt;/strong&gt;：书签栏图标。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;64x64&lt;/strong&gt;：高分辨率屏幕图标。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;180x180&lt;/strong&gt;：iOS 设备主屏幕图标。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;192x192&lt;/strong&gt; 和 &lt;strong&gt;512x512&lt;/strong&gt;：PWA 图标。&lt;br&gt;
所以我们在一些网站上会看到设置多个icon 的现象。比如 &lt;a class=&#34;link&#34; href=&#34;https://gohugo.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Hugo官网 &lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/02/4d83d2d0666f924072095b981ba2ff0e.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Hugo 官网设置了两个 icon&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现代浏览器都支持根据不同的场景，屏幕的PPI 选择不同尺寸的图标，尽量做到所有场景下都达到最好的显示效果。&lt;/p&gt;
&lt;h3 id=&#34;图标格式的选择&#34;&gt;图标格式的选择
&lt;/h3&gt;&lt;p&gt;icon 可以使用不同的图片格式，通过 type指定即可，常见的图标格式包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ICO&lt;/strong&gt;：传统格式，兼容性好，支持多尺寸。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PNG&lt;/strong&gt;：现代格式，支持透明背景，适合高分辨率屏幕。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SVG&lt;/strong&gt;：矢量格式，无限缩放不失真，适合响应式设计。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;多合一-icon&#34;&gt;多合一 Icon
&lt;/h3&gt;&lt;p&gt;如果觉得需要维护多个 icon 文件 比较麻烦的话，可以使用多合一icon（Multi-Resolution ICO 或 Multi-Size ICO）是一种包含多种尺寸和色深的图标文件。允许在一个文件中存储多个位图（BMP 或 PNG 格式）。每个位图可以具有不同的尺寸。&lt;br&gt;
ICO 文件包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;文件头&lt;/strong&gt;（Header）：定义 ICO 文件类型及包含的图像数量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;图像目录&lt;/strong&gt;（Image Directory）：描述每个图像的尺寸、色深、偏移量等信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;图像数据&lt;/strong&gt;（Image Data）：实际存储图像像素数据。&lt;br&gt;
浏览器需要一个图标时，它会从 ICO 文件中选择最合适的尺寸。缺点就是包含多个尺寸的 &lt;code&gt;.ico&lt;/code&gt; 文件可能会比单个尺寸的文件大。&lt;br&gt;
本篇文章没有继续深挖，比如 Android Chrome 独有的 &lt;code&gt;manifest.json&lt;/code&gt; 苹果设备 &lt;code&gt;apple-mobile-web-app-capable&lt;/code&gt; 等。 感兴趣的朋友可以继续深挖。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/%E7%BD%91%E9%A1%B5%E5%9B%BE%E6%A0%87icon%E9%82%A3%E4%BA%9B%E4%BA%8B/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;本文长期链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果您觉得我的博客对你有帮助，请通过 &lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/index.xml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RSS&lt;/a&gt;订阅我。&lt;/li&gt;
&lt;li&gt;或者在&lt;a class=&#34;link&#34; href=&#34;https://x.com/@piaopiaopig&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;X&lt;/a&gt;上关注我。&lt;/li&gt;
&lt;li&gt;如果您有&lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Medium&lt;/a&gt;账号，能给我个关注嘛？我的文章第一时间都会发布在Medium。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>【译】Wise工程：2025年技术栈更新</title>
        <link>https://huizhou92.com/zh-cn/p/%E8%AF%91wise%E5%B7%A5%E7%A8%8B2025%E5%B9%B4%E6%8A%80%E6%9C%AF%E6%A0%88%E6%9B%B4%E6%96%B0/</link>
        <pubDate>Thu, 13 Feb 2025 09:46:39 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/%E8%AF%91wise%E5%B7%A5%E7%A8%8B2025%E5%B9%B4%E6%8A%80%E6%9C%AF%E6%A0%88%E6%9B%B4%E6%96%B0/</guid>
        <description>&lt;p&gt;原文链接：https://medium.com/wise-engineering/wise-tech-stack-2025-update-d0e63fe718c7&lt;/p&gt;
&lt;h2 id=&#34;wise工程2025年技术栈更新&#34;&gt;Wise工程：2025年技术栈更新
&lt;/h2&gt;&lt;p&gt;截至2024财年，Wise已经为1280万活跃客户提供服务，每季度处理的跨境转账金额高达300亿英镑。超过60%的转账实现了即时到账，我们的&lt;a class=&#34;link&#34; href=&#34;https://platform.wise.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Wise平台&lt;/a&gt;为全球银行和非银行机构提供支付服务。这一成就离不开我们以技术为核心的理念、稳健的架构以及专注的工程团队。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://miro.medium.com/v2/resize:fit:1400/1*ATsu7QSH8hn5OkgrDbv3ow.jpeg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;wise的工作方式&#34;&gt;Wise的工作方式
&lt;/h2&gt;&lt;p&gt;Wise在全球主要地点拥有850多名工程师，他们被组织成独立的小组和部落。这些团队被赋予了创新和独立决策的权力，促进了透明度、信任和协作。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;本文基于我们2022年的&lt;a class=&#34;link&#34; href=&#34;https://medium.com/wise-engineering/wise-tech-stack-2022-edition-a6ac089a382f&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;技术栈&lt;/a&gt;，涵盖了Wise技术栈的最新改进，帮助我们实现无国界的资金流动——即时、便捷、透明，最终实现免费。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;使用wise转账&#34;&gt;使用Wise转账
&lt;/h2&gt;&lt;h2 id=&#34;我们的网页和移动应用&#34;&gt;我们的网页和移动应用
&lt;/h2&gt;&lt;p&gt;我们的网页应用基于CRAB（Wise特有的抽象层，构建在流行的Next.js框架之上），包含40个独立的应用程序，每个应用负责特定的产品功能，使得部署更加安全和易于管理。&lt;/p&gt;
&lt;p&gt;在测试方法上，我们最大的变化之一是引入了&lt;a class=&#34;link&#34; href=&#34;https://storybook.js.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Storybook&lt;/a&gt;，用于在开发过程中可视化单个React组件。Storybook与&lt;a class=&#34;link&#34; href=&#34;https://www.chromatic.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Chromatic&lt;/a&gt;配合使用，能够在每次更改后捕获快照，并突出组件的视觉差异。这些快照在代码更改过程中非常有效，帮助我们防止错误影响到客户。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Wise移动应用：更快、更智能、更高效&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们的&lt;strong&gt;iOS工程师&lt;/strong&gt;通过将250多个Xcode模块从Xcodegen迁移到Tuist，并将Cocoapods切换到Swift Package Manager（SPM），升级了基础设施，从而实现了构建缓存的改进。团队还提高了灵活性，将零变更&lt;strong&gt;构建时间从28秒减少到2秒&lt;/strong&gt;。借助先进的构建缓存，开发变得更加顺畅，并朝着使用SPM的Swift可组合架构方向发展。&lt;/p&gt;
&lt;p&gt;我们的&lt;strong&gt;Android工程师&lt;/strong&gt;则专注于大规模应用开发。主要Android代码库包含300多个Gradle模块和大约100万行代码，涵盖2个生产应用、6个示例应用、17个JVM模块、221个Android模块和65个多平台模块。我们提高Android开发速度的努力集中在以下几个关键领域：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用更多的&lt;a class=&#34;link&#34; href=&#34;https://blog.bitsrc.io/bff-pattern-backend-for-frontend-an-introduction-e4fa965128bf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;BFFs&lt;/a&gt;在Android、iOS和网页团队之间共享代码逻辑。&lt;/li&gt;
&lt;li&gt;基于&lt;a class=&#34;link&#34; href=&#34;https://kotlinlang.org/docs/ksp-overview.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;KSP&lt;/a&gt;构建代码生成工具。&lt;/li&gt;
&lt;li&gt;探索&lt;a class=&#34;link&#34; href=&#34;https://kotlinlang.org/docs/multiplatform.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Kotlin多平台&lt;/a&gt;的应用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在用户界面方面，我们已经全面转向Compose——首先用于设计系统，现在用于整个屏幕和导航。我们迅速采用了Kotlin 2.0和2.1版本。为了处理异步任务，我们使用协程和流，而我们的架构遵循标准的MVVM模式，并得到Google的Jetpack库的支持。&lt;/p&gt;
&lt;h2 id=&#34;后端服务&#34;&gt;后端服务
&lt;/h2&gt;&lt;p&gt;Wise总共运行超过&lt;strong&gt;1000个服务&lt;/strong&gt;。在后端，我们主要使用Java和Kotlin。自上次更新以来，我们专注于通过开发内部工具来提高自动化和效率，从而加快开发速度，并提供跨不同服务使用的标准库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更快构建优秀应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自上次更新以来，我们一直专注于&lt;strong&gt;通过自动化代码更新和可扩展的依赖管理解决方案来实现大规模工程&lt;/strong&gt;。为此，我们：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引入了一个内部微服务底层框架，基于最小配置原则构建，并作为构件发布，使我们能够更快地构建标准微服务。它配置了服务使用的常见功能，提供推荐的默认设置：安全性、可观察性、数据库通信、与Kafka的交互等，使团队能够专注于业务逻辑。&lt;/li&gt;
&lt;li&gt;通过内部Gradle插件集合改善构建管道的标准化。一个显著的例子是我们的插件，它标准化了GitHub Actions工作流。这使得通过简单的插件版本更新实现组织范围内的工作流更改变得轻而易举，使得在700多个Java代码库中推出SLSA等倡议变得轻松。&lt;/li&gt;
&lt;li&gt;引入了一种语言无关的自动化服务，使我们能够在大规模上对代码库进行复杂更改，并为拥有团队创建拉取请求进行审查。通过使用该服务，我们进一步推进了集中式Java依赖管理平台，通过自动化Java服务的依赖升级。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;直接与本地支付系统集成&#34;&gt;直接与本地支付系统集成
&lt;/h2&gt;&lt;p&gt;我们已在菲律宾上线了即时支付系统InstaPay，并获得了加入日本即时支付系统Zengin的许可。我们还获得了巴西PIX的接入权限。&lt;/p&gt;
&lt;p&gt;在Wise，我们投入了大量精力来创建尽可能一致的架构，网络通过&lt;a class=&#34;link&#34; href=&#34;https://aws.amazon.com/transit-gateway/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;AWS Transit Gateways&lt;/a&gt;集中管理。英国、匈牙利和澳大利亚的物理数据中心集成的细节存在显著差异。我们的澳大利亚数据中心是&lt;a class=&#34;link&#34; href=&#34;https://aws.amazon.com/outposts/servers/features/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;AWS Outpost Servers&lt;/a&gt;的首次部署之一，使我们能够在尽可能多的基础设施中保持一致的AWS工具。&lt;/p&gt;
&lt;h2 id=&#34;允许企业使用我们的api&#34;&gt;允许企业使用我们的API
&lt;/h2&gt;&lt;p&gt;我们的公共API允许企业直接集成Wise的跨境支付服务，使用安全的&lt;strong&gt;REST API，支持OAuth认证&lt;/strong&gt;。这为&lt;a class=&#34;link&#34; href=&#34;https://wise.com/gb/business/api&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;企业&lt;/a&gt;提供了转账、货币兑换和账户管理的功能，以及全面的文档和开发者工具，以简化集成过程。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://platform.wise.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Wise平台&lt;/a&gt;支持超过&lt;strong&gt;70种货币&lt;/strong&gt;和多种支付路线，提供无缝的全球连接解决方案。该平台包括内置的合规功能，允许在利用Wise广泛的全球基础设施的同时，实现无缝的跨境操作。&lt;/p&gt;
&lt;h2 id=&#34;扩展wise的基础设施平台&#34;&gt;扩展Wise的基础设施平台
&lt;/h2&gt;&lt;p&gt;为了适应快速增长，我们专注于重建基础设施，以确保效率和灵活性，同时减少团队的运营负担。&lt;/p&gt;
&lt;h2 id=&#34;引入我们的新kubernetes支持的计算运行时平台&#34;&gt;&lt;strong&gt;引入我们的新Kubernetes支持的计算运行时平台&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;**计算运行时平台（CRP）**是我们新的可扩展平台，利用Kubernetes，使工程团队能够轻松托管应用程序，而无需管理复杂的基础设施设置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发展我们的Kubernetes栈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自2018年以来，Wise一直依赖于使用Terraform、JSONNET和ConcourseCI构建的Kubernetes，以支持服务网格控制（Envoy）、PCI-DSS合规性和无摩擦的部署。虽然这一模型为我们提供了良好的服务，但我们需要一种更可扩展和标准化的方法。这就是我们引入CRP的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Terraform仍然负责基础设施的配置，但我们从头开始重写了代码库，以提高灵活性和可维护性。&lt;/li&gt;
&lt;li&gt;RKE2处理集群引导，Rancher管理整体集群状态。&lt;/li&gt;
&lt;li&gt;Helm取代JSONNET，以提高可维护性和上游兼容性。&lt;/li&gt;
&lt;li&gt;ArgoCD与自定义插件确保完全自动化的配置和一致性。&lt;/li&gt;
&lt;li&gt;我们的Envoy服务代理现在包括服务之间的无缝集成和发现，提高了平台的灵活性、弹性和监督。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://miro.medium.com/v2/resize:fit:1400/1*FiGHm58o_T1Cyujym01S6g.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;因此，我们的Kubernetes集群数量从6个增长到超过20个，同时保持可维护性和效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更智能的自动扩展和成本优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了更好地配置和维护基础设施的能力外，我们还通过CRP引入了效率改进：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们正在构建一个灵活的、可选择的自动扩展解决方案，以降低云成本和团队的认知负担。&lt;/li&gt;
&lt;li&gt;自动化容器CPU&lt;a class=&#34;link&#34; href=&#34;https://aws.amazon.com/blogs/opensource/right-size-your-kubernetes-applications-using-open-source-goldilocks-for-cost-optimization/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;调整大小&lt;/a&gt;（通过垂直Pod自动扩展器）现在在非生产环境中上线，并正在向非关键工作负载的生产环境推广。&lt;/li&gt;
&lt;li&gt;完全托管的边车容器（如Envoy代理）现在简化了产品团队的部署。&lt;/li&gt;
&lt;li&gt;扩展水平扩展，使用&lt;a class=&#34;link&#34; href=&#34;https://keda.sh/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;KEDA&lt;/a&gt;，根据每日和每周的流量模式优化工作负载。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对成本优化的关注使Wise更接近于&lt;a class=&#34;link&#34; href=&#34;https://wise.com/p/our-mission&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;strong&gt;零任务&lt;/strong&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;构建可扩展可靠和智能的数据基础设施&#34;&gt;构建可扩展、可靠和智能的数据基础设施
&lt;/h2&gt;&lt;p&gt;在Wise，我们的许多工作都与数据的移动和理解有关。无论是转账、更新实时仪表板，还是为后台的机器学习模型提供动力，我们的系统都在不断处理和分发大量信息。随着我们全球足迹的扩大，我们对更快、更安全和更灵活的数据处理方式的需求也在增加。以下是我们如何发展数据技术栈，以继续为客户提供可靠、便捷和高效的体验的快速概述。&lt;/p&gt;
&lt;h2 id=&#34;为我们的数据骨干提供动力&#34;&gt;&lt;strong&gt;为我们的数据骨干提供动力&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;在Wise，我们的数据库是我们所有工作的基础之一，因此我们在使其既稳健又易于管理方面投入了大量精力。在幕后，我们的数据库工程师正在解决一些引人入胜的技术挑战，推动金融数据管理的可能性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们努力将大部分MariaDB和Postgres工作负载从EC2迁移到Amazon RDS。这一转变减少了维护任务，降低了运营开销，并提供了更强大的安全功能。&lt;/li&gt;
&lt;li&gt;同样，我们正在将自托管的MongoDB迁移到MongoDB Atlas，这使我们能够专注于构建新功能，而不是与扩展作斗争。&lt;/li&gt;
&lt;li&gt;Redis继续为我们的内存工作负载提供支持。&lt;/li&gt;
&lt;li&gt;我们还在探索分布式数据库，以实现更大的关系可扩展性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://miro.medium.com/v2/resize:fit:1400/1*3bHF_ughnPcJi1epuqewLw.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;更智能的工作流编排和可观察性&#34;&gt;&lt;strong&gt;更智能的工作流编排和可观察性&lt;/strong&gt;
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我们采用了一种名为&lt;a class=&#34;link&#34; href=&#34;https://temporal.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Temporal&lt;/a&gt;的工作流引擎，以自动化关键任务，如&lt;a class=&#34;link&#34; href=&#34;https://medium.com/wise-engineering/how-wise-reduced-aws-rds-maintenance-downtimes-from-10-minutes-to-100-milliseconds-18ab69fe2346&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;切换&lt;/a&gt;和恢复测试。这有助于我们将停机时间降至最低，并保持符合严格的弹性法规。&lt;/li&gt;
&lt;li&gt;像RDS性能洞察和Percona监控与管理（PMM）这样的工具为我们提供了清晰的数据库运行状况视图，使我们能够及早解决问题。&lt;/li&gt;
&lt;li&gt;我们还在尝试使用直接的云SDK来管理我们的基础设施——逐步从Terraform Enterprise转向简化我们的配置流程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;保持数据流动&#34;&gt;&lt;strong&gt;保持数据流动&lt;/strong&gt;
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Kafka支撑着我们大多数实时数据的移动——无论是服务之间的异步消息传递、日志收集，还是分析的流式更新。&lt;/li&gt;
&lt;li&gt;我们的Kafka集群容量显著增长，并引入了诸如机架感知备用副本等功能，以提高容错能力。&lt;/li&gt;
&lt;li&gt;我们的内部数据移动服务帮助将信息从Kafka或数据库引导到Snowflake、S3 Parquet、Iceberg或其他目标。&lt;/li&gt;
&lt;li&gt;配置过程中的自动检查减少了人为错误，其日益增长的使用表明团队发现设置新管道变得更简单、更快捷。&lt;/li&gt;
&lt;li&gt;另一个内部服务，数据归档，现在在多个数据库中归档超过1000亿条记录。这不仅节省了成本，还使我们的数据库更易于备份和恢复。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;将数据转化为洞察&#34;&gt;&lt;strong&gt;将数据转化为洞察&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;Wise各团队使用我们的商业智能工具做出战略性、数据驱动的决策，以提升客户体验——从欺诈检测到个性化营销和预测分析。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽管我们仍然依赖Snowflake作为分析的核心组成部分，但我们已经在Amazon S3上建立了数据湖的基础，使用Apache Iceberg。得益于其强大的开放表格式，Apache Iceberg使我们能够更高效地在S3上存储大量数据。它允许我们在不需要重写所有数据的情况下修改表结构，从而加快查询速度并控制存储成本。此外，其活跃的开源社区不断推动改进，惠及我们的长期可扩展性。&lt;/li&gt;
&lt;li&gt;在我们的数据源和商业智能工具之间是Trino，它使我们能够在一个地方查询Iceberg表、Snowflake或甚至Kafka流。&lt;/li&gt;
&lt;li&gt;一个新的Trino网关处理工作负载分离和容错查询，而复杂的工作流仍由Airflow和dbt-core管理。有关此主题的深入了解，请观看我们数据工程师最近的会议&lt;a class=&#34;link&#34; href=&#34;https://www.youtube.com/watch?v=K5RmYtbeXAc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;演讲&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;报告和仪表板使用Looker或Superset构建——团队选择最适合的工具集。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://miro.medium.com/v2/resize:fit:1400/1*ebFu8iFjqXGSzvy1fAayvA.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;推动智能解决方案&#34;&gt;&lt;strong&gt;推动智能解决方案&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;我们的机器学习架构旨在支持探索和生产，无缝集成机器学习功能到产品中，以改善客户入职和欺诈预防，并利用负责任的人工智能技术。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们的数据科学家在Amazon SageMaker Studio中工作，选择JupyterLab或VSCode来构建实验和探索数据。&lt;/li&gt;
&lt;li&gt;大规模处理在EMR上使用Spark进行，而Airflow则协调数据收集、清理、模型训练和定期再训练，以保持每个步骤按计划进行。&lt;/li&gt;
&lt;li&gt;我们使用SageMaker特征存储来保持数百个特征在训练和推理中的同步，MLflow跟踪实验、指标和模型版本。这种设置简化了模型变体的比较或在需要时的回滚。&lt;/li&gt;
&lt;li&gt;当模型准备好投入生产时，我们通过基于Ray Serve的内部预测服务进行部署。&lt;/li&gt;
&lt;li&gt;多亏了MLflow插件，我们的数据科学家可以以最小的摩擦推出模型——加快欺诈检测、KYC或其他用例的推理时间，在这些情况下每毫秒都至关重要。&lt;/li&gt;
&lt;li&gt;自动检查有助于在数据漂移或特征不一致变成严重问题之前捕捉到它们。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://miro.medium.com/v2/resize:fit:1400/1*Rux3bEKC2spJhQ3H6sOr-g.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;解锁新的人工智能能力&#34;&gt;&lt;strong&gt;解锁新的人工智能能力&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;我们创建了一个安全的网关，连接多个大型语言模型提供商，包括Anthropic（Claude）、AWS（Bedrock）、Google（Gemini）和OpenAI（gpt和o系列）。这种方法使我们能够在不处理单独凭证或复杂合规检查的情况下实验不同的模型。一个受LangChain启发的Python库封装了这些API，以加快原型设计。&lt;/p&gt;
&lt;p&gt;对于需要引用内部文档、知识库或用户数据的情况，我们提供了一个自定义的检索增强生成（RAG）服务。它在生成响应之前从各种数据存储中提取最新信息——这是总结复杂文档或自动化客户服务工作流的便捷功能。&lt;/p&gt;
&lt;h2 id=&#34;智能数据管理&#34;&gt;&lt;strong&gt;智能数据管理&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;我们的数据架构既庞大又复杂，因此我们建立了一个全面的库存系统和专门的治理门户，以显示数据存储的位置及其分类。&lt;/p&gt;
&lt;p&gt;我们已在整个数据资产中实现了自动化数据发现，以了解创建了什么数据；谁创建了它；以及数据的类别是什么。我们正在利用我们的数据库存来支持数据删除、数据合规和数据发现的工作。这种设置不仅支持审计和法规的合规工作，还提高了开发者的生产力。&lt;/p&gt;
&lt;p&gt;随着越来越多的工程师加入治理工作，我们能够推出更严格的政策、增强的隐私检查和自动化的数据生命周期管理。&lt;/p&gt;
&lt;h2 id=&#34;开发者赋能wise的cicd演变&#34;&gt;开发者赋能——Wise的CI/CD演变
&lt;/h2&gt;&lt;p&gt;为了加强我们的交付管道和开发者体验，我们不断发展我们的CI/CD平台，以使开发者能够比以往更快、更可靠地将功能交付给客户。&lt;/p&gt;
&lt;h2 id=&#34;ci改进速度和安全性&#34;&gt;&lt;strong&gt;CI改进：速度和安全性&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;从CircleCI迁移到GitHub Actions带来了优化的新可能性。通过实施详细的指标跟踪，我们发现了构建性能的关键见解。例如，通过预填充常用容器的缓存，我们&lt;strong&gt;将构建时间缩短了15%&lt;/strong&gt;。&lt;strong&gt;在我们每月50万次构建的规模下，这相当于每月节省超过1000小时。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们一直在有条不紊地在我们的构建过程中实施&lt;a class=&#34;link&#34; href=&#34;https://slsa.dev/spec/v1.1/about&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;SLSA框架&lt;/a&gt;，逐步加强我们的供应链安全。&lt;/p&gt;
&lt;h2 id=&#34;cd转型从octopus到spinnaker&#34;&gt;&lt;strong&gt;CD转型：从Octopus到Spinnaker&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;在我们之前的&lt;a class=&#34;link&#34; href=&#34;https://medium.com/wise-engineering/state-of-our-ci-cd-pipeline-part-2-29bd17515e6f&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;文章&lt;/a&gt;中提到的CI/CD管道状态之后，我们的部署策略随着从Octopus（我们的内部工具）转向&lt;a class=&#34;link&#34; href=&#34;https://spinnaker.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Spinnaker&lt;/a&gt;而发生了变化。这不仅仅是工具的更换——它代表了一种范式转变，从将部署视为简单的事务转变为将其视为有序事件序列。&lt;/p&gt;
&lt;p&gt;这一转变使我们能够减少工程师在部署管理上花费的时间，并最小化缺陷到达客户的风险。这提高了开发者的交付速度，使我们能够更快地为客户提供服务，而不牺牲质量和稳定性。&lt;/p&gt;
&lt;h2 id=&#34;高级金丝雀测试&#34;&gt;&lt;strong&gt;高级金丝雀测试&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;Spinnaker的&lt;a class=&#34;link&#34; href=&#34;https://spinnaker.io/docs/guides/user/canary/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;自动金丝雀分析&lt;/a&gt;已成为我们部署管道的基石。该过程在其简单性中优雅而强大：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;仅5%的流量路由到新服务版本进行测试&lt;/li&gt;
&lt;li&gt;对技术和业务指标进行全面的30分钟分析&lt;/li&gt;
&lt;li&gt;对重大异常触发自动回滚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，仅在2024年，这一系统自动阻止了数百次可能导致事件的部署，节省了数千小时的工程时间。&lt;/p&gt;
&lt;p&gt;目前，Wise的超过一半服务已在Spinnaker上运行，预计到2025年中期将完成全面迁移，我们准备迈出下一步：实施托管交付，以协调整个SDLC，包括测试和数据管理。&lt;/p&gt;
&lt;h2 id=&#34;lgtm堆栈的可观察性&#34;&gt;LGTM堆栈的可观察性
&lt;/h2&gt;&lt;p&gt;我们改善了可观察性生态系统，以更好地监控、理解和优化Wise产品。可靠性工程师专注于构建一个更强大、高效和富有洞察力的可观察性平台，以应对我们快速扩展环境中的关键挑战。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://miro.medium.com/v2/resize:fit:1400/1*eH9-LcxB8IGstQdZ9N8Spg.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;专用的可观察性基础设施&#34;&gt;&lt;strong&gt;专用的可观察性基础设施&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;我们实施了专用的可观察性CRP集群。这为在不同环境中运行的服务提供了开箱即用的可观察性。因此，我们简化了监控设置，减少了手动配置的负担。&lt;/p&gt;
&lt;h2 id=&#34;统一的指标和监控堆栈&#34;&gt;&lt;strong&gt;统一的指标和监控堆栈&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;为了解决可扩展性问题，我们已从Thanos迁移到Grafana Mimir。这意味着我们现在完全运行在&lt;a class=&#34;link&#34; href=&#34;https://grafana.com/go/webinar/getting-started-with-grafana-lgtm-stack/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LGTM堆栈&lt;/a&gt;上：Loki用于日志，Grafana用于仪表板和可视化，Tempo用于跟踪，Mimir用于指标。作为我们在可观察性方面持续改进的一部分，我们正在试点测试Grafana Pyroscope，以对选定服务进行分析，探索性能洞察和优化的新维度。&lt;br&gt;
我们的指标堆栈每秒接收约600万个指标样本，并处理我们最大指标租户的1.5亿个活动系列。&lt;br&gt;
通过统一我们的堆栈，我们：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在整个技术生态系统中标准化可观察性。&lt;/li&gt;
&lt;li&gt;增强日志、指标、跟踪和仪表板之间的关联。&lt;/li&gt;
&lt;li&gt;改善监控基础设施的性能和可扩展性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;可观察性的成本优化和效率&#34;&gt;&lt;strong&gt;可观察性的成本优化和效率&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;最后，我们继续投资于优化我们的可观察性堆栈。我们能够降低运营成本，提高资源利用率，并最终拥有更可持续的长期可观察性战略。请查看我们之前的&lt;a class=&#34;link&#34; href=&#34;https://medium.com/wise-engineering/grafana-mimir-compaction-from-bottleneck-to-savings-b26c6b0125a6&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;文章&lt;/a&gt;，详细介绍了我们在这些倡议上所做的工作。&lt;/p&gt;
&lt;p&gt;这一战略演变使我们的工程团队能够获得更深入、更具可操作性的洞察，同时确保我们的可观察性基础设施既强大又具有成本效益。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论
&lt;/h2&gt;&lt;p&gt;总之，我们2025年的技术栈证明了Wise如何引领潮流，为全球1280万活跃客户提供最快、最可靠和最具成本效益的资金转移方式。对标准化和集成的高度关注意味着我们的系统旨在高效扩展，同时确保稳健的风险和合规管理。&lt;/p&gt;
&lt;p&gt;我们的工程团队继续在所有领域精炼我们的基础设施，从移动和网页应用到后端服务和机器学习。这些努力简化并加速了跨境资金流动，确保我们为当前需求和未来增长做好准备。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们致力于长期投资，构建最佳基础设施，以无缝管理您在全球范围内的资金&lt;/strong&gt;。随着每一次技术增强和与支付系统的新直接连接，我们正稳步朝着实现&lt;strong&gt;无国界资金流动&lt;/strong&gt;的愿景迈进。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Go1.24: mutex自旋优化,最大提升70%的性能</title>
        <link>https://huizhou92.com/zh-cn/p/go124-mutex%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96%E6%9C%80%E5%A4%A7%E6%8F%90%E5%8D%8770%E7%9A%84%E6%80%A7%E8%83%BD/</link>
        <pubDate>Tue, 11 Feb 2025 11:16:36 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/go124-mutex%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96%E6%9C%80%E5%A4%A7%E6%8F%90%E5%8D%8770%E7%9A%84%E6%80%A7%E8%83%BD/</guid>
        <description>&lt;img src="https://images.hxzhouh.com/blog-images/2025/02/aee1ae007540f5e7191e3ac7cd6b4f8d.png" alt="Featured image of post Go1.24: mutex自旋优化,最大提升70%的性能" /&gt;&lt;h2 id=&#34;背景&#34;&gt;背景
&lt;/h2&gt;&lt;p&gt;Rhys Hiltner 在 2024 年提出了改进互斥锁的性能优化诉求。现在这个优化已经合并到即将发布的Go1.24中，在锁竞争激烈的场景下最多会提升70%的性能。&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/02/8c658c9a0a11655b7500d13e4ad68206.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;source https://github.com/golang/go/issues/68578 &#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在基准测试 ChanContended 中，作者发现随着 &lt;code&gt;GOMAXPROCS&lt;/code&gt; 的增加，mutex 的性能明显下降。&lt;br&gt;
&lt;strong&gt;Intel i7-13700H&lt;/strong&gt; (linux/amd64)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当允许使用 4 个线程时，整个进程的吞吐量是单线程时的一半。&lt;/li&gt;
&lt;li&gt;当允许使用 8 个线程时，吞吐量再次减半。&lt;/li&gt;
&lt;li&gt;当允许使用 12 个线程时，吞吐量再次减半。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;GOMAXPROCS=20&lt;/code&gt; 时，200 次channel操作平均耗时 44 微秒，平均每 220 纳秒调用一次 unlock2，每次都有机会唤醒一个睡眠线程。&lt;br&gt;
另一个角度是考虑进程的 CPU占用时间。&lt;br&gt;
下面的数据显示，在 1.78 秒的&lt;code&gt;Wall-Clock Time&lt;/code&gt;内，&lt;strong&gt;进程的20个线程在lock2调用中总共有27.74秒处于CPU(自旋)上。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/02/19eeb4e1afc7cce66c0bc6af46dff2d6.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这些 lock2 相关的线程并没有休眠，而是一直在自旋，这将消耗大量的CPU资源。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;新提案增加spinning状态&#34;&gt;新提案：增加spinning状态
&lt;/h1&gt;&lt;p&gt;通过上述的分析，作者发现在当前的lock2实现中，虽然理论上允许线程睡眠，但实际上导致所有线程都在自旋，导致了更慢的锁传递，带来了不少的性能损耗。&lt;br&gt;
于是提出了新的设计方案&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/proposal/blob/master/design/68578-mutex-spinbit.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《Proposal: Improve scalability of runtime.lock2》&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;核心优化点&#34;&gt;核心优化点
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;mutex 的状态字添加了一个个新的标志位，称为 “spinning”&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;https&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//github.com/golang/go/blob/608acff8479640b00c85371d91280b64f5ec9594/src/runtime/lock_spinbit.go#L57&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0x001&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;mutexSleeping&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0x002&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;mutexSpinning&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0x100&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;使用这个 &lt;code&gt;spinning&lt;/code&gt;位来表示是否有一个等待的线程处于 “醒着并循环尝试获取锁” 的状态。线程之间会互相排除进入 &lt;code&gt;spinning&lt;/code&gt;状态，但它们不会因为尝试获取这个标志位而阻塞。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;metux 的介绍可以参考以前的文章&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://pub.huizhou92.com/go-source-code-sync-mutex-3082a25ef092&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pub.huizhou92.com/go-source-code-sync-mutex-3082a25ef092&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;mutex-获取锁分析&#34;&gt;Mutex 获取锁分析
&lt;/h2&gt;&lt;h3 id=&#34;1-快速路径尝试获取锁&#34;&gt;1. 快速路径尝试获取锁
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//https://github.com/golang/go/blob/adc9c455873fef97c5759e4811f0d9c8217fe27b/src/runtime/lock_spinbit.go#L160&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;k8&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;key8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;v8&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Xchg8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;k8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v8&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v8&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexSleeping&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Or8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;k8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexSleeping&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;fast 模式跟以前变化不大。如果成功(锁之前未被持有)则快速返回。这是最理想的情况，无竞争时的快速路径。&lt;/p&gt;
&lt;h3 id=&#34;2-自旋等待阶段&#34;&gt;2. 自旋等待阶段
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//https://github.com/golang/go/blob/adc9c455873fef97c5759e4811f0d9c8217fe27b/src/runtime/lock_spinbit.go#L208&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;weSpin&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexSpinning&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Casuintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexSpinning&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexSpinning&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;weSpin&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;weSpin&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atTail&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;mutexPreferLowLatency&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;spin&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;procyield&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexActiveSpinSize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;//主动自旋&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// ...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;spin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexPassiveSpinCount&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;osyield&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//被动自旋&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// ...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;如果快速路径失败，进入自旋等待阶段。&lt;/li&gt;
&lt;li&gt;通过 &lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/blob/608acff8479640b00c85371d91280b64f5ec9594/src/runtime/lock_spinbit.go#L60&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;mutexSpinning&lt;/a&gt; 标志控制&lt;strong&gt;同时只允许一个 goroutine 自旋&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;自旋分为procyield与osyield，两者的区别是:procyield会持续占有CPU，响应会更快，适合极短时间的等待，osyield会临时释放CPU，响应较慢，但是不会占用较多CPU，适用于较长时间的等待。&lt;br&gt;
这种两阶段自旋设计能够在不同竞争强度下都保持较好的性能表现。&lt;/li&gt;
&lt;li&gt;轻度竞争时主要使用主动自旋，保证低延迟&lt;/li&gt;
&lt;li&gt;重度竞争时快速进入被动自旋，避免CPU资源浪费&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;休眠等待阶段&#34;&gt;休眠等待阶段
&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//https://github.com/golang/go/blob/adc9c455873fef97c5759e4811f0d9c8217fe27b/src/runtime/lock_spinbit.go#L231&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Store the current head of the list of sleeping Ms in our gp.m.mWaitList.next field&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mWaitList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;mutexWaitListHead&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Pack a (partial) pointer to this M with the current lock state bits&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;uintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;^&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexMMask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexMMask&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexSleeping&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;weSpin&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;^&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexSpinning&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Casuintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;weSpin&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;semasleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;atTail&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mWaitList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果自旋失败，&lt;code&gt;goroutine&lt;/code&gt; 将进入休眠等待，然后将当前 M 加入等待队列(通过 mWaitList 链表)，通过信号量(&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/blob/fd050b3c6d0294b6d72adb014ec14b3e6bf4ad60/src/runtime/lock_sema_tristate.go#L106&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;semasleep&lt;/a&gt;)使当前 &lt;code&gt;goroutine&lt;/code&gt; 进入休眠，等待持有锁的 &lt;code&gt;goroutine&lt;/code&gt; 在解锁时唤醒。&lt;/p&gt;
&lt;p&gt;当某个线程解锁互斥锁时，如果发现已经有线程处于 “醒着并旋转” 的状态，就不会唤醒其他线程。在 Go 运行时的背景下，这种设计被称为 &lt;code&gt;spinbit&lt;/code&gt;。&lt;br&gt;
这个设计的核心目的是：&lt;strong&gt;通过让一个线程负责 “旋转尝试获取锁”，避免所有线程都同时竞争资源，从而减少争用和不必要的线程切换&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;效果&#34;&gt;效果
&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;goos: linux
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;goarch: amd64
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;pkg: runtime
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cpu: 13th Gen Intel&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;R&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; Core&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;TM&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; i7-13700H
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                │     old     │                  new                  │
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                │   sec/op    │    sec/op     vs base                 │
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended      3.147µ ± 0%    3.703µ ± 0%   +17.65% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-2    4.511µ ± 2%    5.280µ ± 7%   +17.06% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-3    5.726µ ± 2%   12.125µ ± 2%  +111.75% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-4    6.574µ ± 1%   13.356µ ± 4%  +103.16% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-5    7.706µ ± 1%   13.717µ ± 3%   +78.00% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-6    8.830µ ± 1%   13.674µ ± 2%   +54.85% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-7    11.07µ ± 0%    13.59µ ± 2%   +22.77% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-8    13.99µ ± 1%    14.06µ ± 1%         ~ &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.190 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-9    16.93µ ± 2%    14.04µ ± 3%   -17.04% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-10   20.12µ ± 4%    14.12µ ± 1%   -29.80% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-11   23.96µ ± 2%    14.44µ ± 3%   -39.74% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-12   29.65µ ± 6%    14.61µ ± 3%   -50.74% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-13   33.98µ ± 7%    14.69µ ± 3%   -56.76% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-14   37.90µ ± 1%    14.69µ ± 3%   -61.23% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-15   37.94µ ± 4%    14.89µ ± 5%   -60.75% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-16   39.56µ ± 0%    13.89µ ± 1%   -64.89% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-17   39.56µ ± 0%    14.45µ ± 4%   -63.47% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-18   41.24µ ± 2%    13.95µ ± 3%   -66.17% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-19   42.77µ ± 5%    13.80µ ± 2%   -67.74% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-20   44.26µ ± 2%    13.74µ ± 1%   -68.96% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;geomean            17.60µ         12.46µ        -29.22%
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/02/d218f1783388c76053bca81e0d254ffd.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;br&gt;
source &lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/68578#issuecomment-2256792628&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/golang/go/issues/68578#issuecomment-2256792628&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虽然在竞争较少的情况下，性能有降低，但是在竞争比较多的地方性能提升显著。平均来说，大约获得 29%的性能提升。期待后续能够优化这种情况吧。&lt;/p&gt;
&lt;p&gt;mutex本次修改没涉及API层面改动，所以只要等 Go1.24 正式发布就能自动使用了。该特性通过&lt;code&gt;GOEXPERIMENT=spinbitmutex&lt;/code&gt; 来控制，默认是开启的，也可以将它关闭，来使用原来的Mutex。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/go124-mutex%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96%E6%9C%80%E5%A4%A7%E6%8F%90%E5%8D%8770%E7%9A%84%E6%80%A7%E8%83%BD/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;本文长期链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果您觉得我的博客对你有帮助，请通过 &lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/index.xml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RSS&lt;/a&gt;订阅我。&lt;/li&gt;
&lt;li&gt;或者在&lt;a class=&#34;link&#34; href=&#34;https://x.com/@piaopiaopig&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;X&lt;/a&gt;上关注我。&lt;/li&gt;
&lt;li&gt;如果您有&lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Medium&lt;/a&gt;账号，能给我个关注嘛？我的文章第一时间都会发布在Medium。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
