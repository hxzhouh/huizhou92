<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>网络 on huizhou92&#39;s Blog</title>
        <link>https://huizhou92.com/zh-cn/categories/%E7%BD%91%E7%BB%9C/</link>
        <description>Recent content in 网络 on huizhou92&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>Copyright © 2023 huizhou92</copyright>
        <lastBuildDate>Fri, 14 Jun 2024 09:38:42 +0800</lastBuildDate><atom:link href="https://huizhou92.com/zh-cn/categories/%E7%BD%91%E7%BB%9C/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>QUIC 如何在速度和安全性方面取代 TCP？</title>
        <link>https://huizhou92.com/zh-cn/p/quic-%E5%A6%82%E4%BD%95%E5%9C%A8%E9%80%9F%E5%BA%A6%E5%92%8C%E5%AE%89%E5%85%A8%E6%80%A7%E6%96%B9%E9%9D%A2%E5%8F%96%E4%BB%A3-tcp/</link>
        <pubDate>Fri, 14 Jun 2024 09:38:42 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/quic-%E5%A6%82%E4%BD%95%E5%9C%A8%E9%80%9F%E5%BA%A6%E5%92%8C%E5%AE%89%E5%85%A8%E6%80%A7%E6%96%B9%E9%9D%A2%E5%8F%96%E4%BB%A3-tcp/</guid>
        <description>&lt;img src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fd0e30c17-275b-4a94-8883-74c546ead5e5_5955x3350.jpeg" alt="Featured image of post QUIC 如何在速度和安全性方面取代 TCP？" /&gt;&lt;p&gt;原文链接&lt;a class=&#34;link&#34; href=&#34;https://engineeringatscale.substack.com/p/how-quic-is-displacing-tcp-for-speed&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;how-quic-is-displacing-tcp-for-speed&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;引言&#34;&gt;引言
&lt;/h2&gt;&lt;p&gt;在过去的三十年中，&lt;strong&gt;HTTP&lt;/strong&gt;（超文本传输协议）一直是互联网的支柱。我们能够浏览网页、下载文件、流式传输电影等，都是因为HTTP。这个协议多年来不断发展，见证了重大的改进。&lt;/p&gt;
&lt;p&gt;HTTP协议是一个应用层协议，工作在&lt;strong&gt;TCP&lt;/strong&gt;（传输控制协议）之上。TCP协议有一些限制，导致网络应用程序响应性较差。&lt;/p&gt;
&lt;p&gt;谷歌开发了一种改变游戏规则的传输协议QUIC，以克服TCP的缺点。&lt;strong&gt;QUIC&lt;/strong&gt;几年前被标准化并加入到&lt;strong&gt;IETF&lt;/strong&gt;（互联网工程任务组）。&lt;/p&gt;
&lt;p&gt;在过去几年中，QUIC的采用呈指数级增长。大多数科技公司，如谷歌、Facebook、Pinterest等，已经开始采用使用QUIC作为传输层的HTTP/3.0。这些公司在使用HTTP/3.0和QUIC后，其网站性能有了显著提升。&lt;/p&gt;
&lt;p&gt;让我们开始我们的旅程，了解QUIC如何取代TCP。我们首先将了解一些基本的TCP和UDP网络概念。之后，我们将看看HTTP的演变，以及每个版本是如何克服前一个版本的限制的。然后，我们将了解QUIC是什么以及它的工作原理。我们将探讨为什么QUIC的性能比TCP高。&lt;/p&gt;
&lt;h2 id=&#34;tcp和udp是如何工作的&#34;&gt;TCP和UDP是如何工作的？
&lt;/h2&gt;&lt;p&gt;TCP（传输控制协议）和UDP（用户数据报协议）是传输层协议。这些协议管理互联网数据包流向和来自任何电子设备的过程。让我们详细了解这两个协议是如何工作的。&lt;/p&gt;
&lt;h3 id=&#34;tcp&#34;&gt;TCP
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;TCP&lt;/strong&gt;是一种基于连接的协议。客户端与服务器建立连接，然后发送数据。TCP连接是通过一种称为三次握手的机制建立的。下图展示了三次握手过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2024/06/caf726113bb8757bed09f9999ae30733.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;TCP 三次握手过程&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这个过程包括三个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;SYN - 客户端向服务器发送一个&lt;strong&gt;SYN&lt;/strong&gt;数据包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ACK - 服务器接收到&lt;strong&gt;SYN&lt;/strong&gt;后，通过&lt;strong&gt;ACK&lt;/strong&gt;数据包向客户端发送确认。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SYN-ACK - 客户端收到服务器的&lt;strong&gt;ACK&lt;/strong&gt;数据包后，最终通过&lt;strong&gt;SYN-ACK&lt;/strong&gt;向服务器发送确认。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;TCP是一个有状态和可靠的协议。它保证从一台设备到另一台设备的所有数据包的传输。此外，它允许客户端和服务器使用相同的连接进行通信。&lt;/p&gt;
&lt;h3 id=&#34;udp&#34;&gt;UDP
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;UDP&lt;/strong&gt;是一种无连接协议。与TCP不同，客户端和服务器之间没有三次握手。客户端向服务器发送数据包，不等待服务器的确认。&lt;/p&gt;
&lt;p&gt;UDP不能保证100%的数据包传输。数据包可能会丢失，可能无法到达另一台设备。UDP不像TCP那样可靠。&lt;/p&gt;
&lt;p&gt;由于没有初始握手，UDP比TCP快得多。出于性能原因，UDP主要用于流式数据应用程序，如音乐/视频。&lt;/p&gt;
&lt;p&gt;这是一个流行的互联网梗，对TCP/UDP进行了调侃：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2024/06/a3ca4b8e00d8afa0578e4417d1967428.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;TCP VS UDP 梗&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;到目前为止，我们已经了解了TCP和UDP协议是如何工作的。现在让我们探索HTTP协议，这是一个应用层协议。&lt;/p&gt;
&lt;h2 id=&#34;http的演变&#34;&gt;HTTP的演变
&lt;/h2&gt;&lt;p&gt;由&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Tim_Berners-Lee&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Tim Berners-Lee&lt;/a&gt;在&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/CERN&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CERN&lt;/a&gt;开发的HTTP的第一个版本是在1989年。从那时起，该协议经历了多次优化和性能改进。大多数现代设备使用&lt;strong&gt;HTTP 1.1&lt;/strong&gt;/ &lt;strong&gt;HTTP 2.0&lt;/strong&gt;和&lt;strong&gt;HTTP 3.0&lt;/strong&gt;。让我们回顾一下HTTP的历史，了解协议经历的重大变化。&lt;/p&gt;
&lt;h3 id=&#34;http10&#34;&gt;HTTP/1.0
&lt;/h3&gt;&lt;p&gt;在最初的HTTP/0.9版本之后，HTTP/1.0开始支持头、请求体、文本文件等。客户端每次使用HTTP从服务器获取数据时，都必须创建一个TCP连接。这导致在建立连接时显著浪费资源。&lt;/p&gt;
&lt;h3 id=&#34;http11&#34;&gt;HTTP/1.1
&lt;/h3&gt;&lt;p&gt;这个协议增加了对重用客户端和服务器之间现有TCP连接以获取新数据的支持。这是通过HTTP头&lt;code&gt;keep-alive&lt;/code&gt;实现的。&lt;/p&gt;
&lt;p&gt;如果客户端想要获取10个JavaScript文件，那么它将与服务器建立一个连接。然后，它将重用相同的连接来获取这10个文件，而不是为每个文件创建一个新连接。&lt;/p&gt;
&lt;p&gt;这导致资源浪费减少和性能提升，因为它避免了创建多余的连接。然而，一个主要的缺点是众所周知的_队头阻塞_问题。&lt;/p&gt;
&lt;p&gt;下图展示了_队头阻塞_问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2024/06/5cc7b3071e1e63fa95130aacc6ab9dda.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;队头阻塞&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;让我们通过一个例子来理解这个概念。如上图所示，你有3个文件 - 图像、文本和视频。视频文件体积较大，传输时间会更长。由于视频文件传输时间较长，它会阻塞图像和文本文件的发送。&lt;/p&gt;
&lt;h3 id=&#34;http20&#34;&gt;HTTP/2.0
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;HTTP 2.0&lt;/strong&gt;通过多路复用解决了_队头阻塞_问题。通过多路复用，多个文件可以通过同一个TCP连接发送。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2024/06/cc93f0e6a4693c17d06b65804412e8d7.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;HTTP/2.0中的多路复用&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这导致了性能提升，并解决了应用层面的队头阻塞问题。然而，在TCP层面，如果发生数据包丢失，它必须等待数据包重传。&lt;/p&gt;
&lt;p&gt;多路复用解决方案在数据包丢失的情况下并不像预期的那样有效。实际上，如果数据包丢失超过5%，HTTP 1.1的性能比HTTP 2.0更好。_队头阻塞_问题从应用层转移到了传输层。&lt;/p&gt;
&lt;p&gt;下图展示了单个数据包丢失如何导致多个流延迟：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2024/06/be1f098332879071f2909e464e139ef4.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;HTTP/2.0中的数据包丢失导致重传和流延迟&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;当一个数据包丢失时，TCP将其后续数据包存储在其缓冲区中，直到收到丢失的数据包。然后TCP使用重传来获取丢失的数据包。HTTP无法看到TCP重传。因此，在这种情况下，不同的流会看到传输延迟。&lt;/p&gt;
&lt;h2 id=&#34;什么是quic&#34;&gt;什么是QUIC？
&lt;/h2&gt;&lt;p&gt;在过去的几个部分中，我们看到了TCP有一些固有的限制，如三次握手和队头阻塞。这些限制可以通过增强TCP或用新协议替换TCP来解决。&lt;/p&gt;
&lt;p&gt;尽管增强TCP很简单，但TCP存在于最低层，与操作系统紧密耦合。简单来说，TCP的代码存在于内核层而不是用户空间。考虑到大量的设备，实施内核空间的更改将需要大量的时间才能到达所有用户。&lt;/p&gt;
&lt;p&gt;因此，谷歌提出了一种新的协议&lt;strong&gt;QUIC&lt;/strong&gt;，作为TCP的替代品。像TCP一样，QUIC也是一个传输层协议。然而，它位于用户空间而不是内核空间。这使得它容易更改和增强，与TCP不同。&lt;/p&gt;
&lt;p&gt;QUIC在UDP之上工作。它通过使用UDP克服了TCP的限制。它只是一个在UDP之上的层或包装器。该包装器添加了TCP的功能，如拥塞控制、数据包重传、多路复用等。它内部使用UDP，并在其上添加了TCP的最佳功能。&lt;/p&gt;
&lt;p&gt;下图显示了QUIC如何适应网络栈：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2024/06/0f6646bac5d36e03f7efc018abecd36e.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;带有QUIC的网络栈&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;现在我们已经了解了QUIC的基础知识，让我们深入了解这个协议的工作原理。&lt;/p&gt;
&lt;h2 id=&#34;quic是如何工作的&#34;&gt;QUIC是如何工作的？
&lt;/h2&gt;&lt;h3 id=&#34;quic握手&#34;&gt;QUIC握手
&lt;/h3&gt;&lt;p&gt;QUIC在UDP上工作，它不需要经过三次握手过程。三次握手过程增加了额外的开销，增加了延迟。因此，QUIC通过减少连接延迟来提高性能。&lt;/p&gt;
&lt;p&gt;在TCP的情况下，还有一个额外的用于TLS的握手，这也增加了延迟。QUIC将TLS握手和QUIC握手合并为一个调用。它优化了握手过程并提高了性能。&lt;/p&gt;
&lt;h3 id=&#34;可靠性&#34;&gt;可靠性
&lt;/h3&gt;&lt;p&gt;您可能会想“&lt;em&gt;既然QUIC在UDP上工作，数据包会丢失吗？&lt;/em&gt;”。答案是不。QUIC在UDP堆栈上添加了可靠性。它实现了数据包重传，以防它没有收到必要的数据包。例如：如果服务器没有收到来自客户端的第5个数据包，协议将检测到它并要求客户端重新发送相同的数据包。&lt;/p&gt;
&lt;h3 id=&#34;多路复用&#34;&gt;多路复用
&lt;/h3&gt;&lt;p&gt;与TCP类似，QUIC也实现了多路复用。客户端可以使用单个通道同时传输多个文件。QUIC为每个流（传输的文件）创建一个UUID。它使用UUID来识别流。然后，多个流通过单个通道发送。&lt;/p&gt;
&lt;p&gt;下图展示了QUIC中多路复用是如何工作的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2024/06/768ff5b9df55d625011a814cf1339e13.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;QUIC中的多路复用&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;QUIC还通过其多路复用解决了TCP面临的队头阻塞问题。如果一个流遭受数据包丢失，只有该流会受到影响。QUIC中的流是独立的，不会影响彼此的工作。&lt;/p&gt;
&lt;h3 id=&#34;安全性&#34;&gt;安全性
&lt;/h3&gt;&lt;p&gt;此外，QUIC 还支持 TLS 1.3（传输层安全性）。这保证了数据的安全性和保密性。TLS 加密了 QUIC 协议的大部分内容，例如数据包编号和连接关闭信号。&lt;/p&gt;
&lt;h2 id=&#34;为什么选择quic&#34;&gt;为什么选择QUIC？
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;降低延迟&lt;/strong&gt; - QUIC通过将TLS握手与连接建立结合起来，最小化了延迟。这也被称为&lt;strong&gt;0-RTT&lt;/strong&gt;（零往返时间）。它实现了更快的连接建立，并提高了网络应用程序的性能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多路复用&lt;/strong&gt; - 通过多路复用，QUIC可以在单个通道上发送多个数据流。这对于下载多个文件（如图像、JavaScript、CSS等）的客户端应用程序非常有用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连接迁移&lt;/strong&gt; - 使用QUIC，您可以在不出现任何问题的情况下从一种网络接口切换到另一种（例如从Wi-Fi切换到移动数据）。这对于移动设备很重要，并提高了用户体验。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高安全性&lt;/strong&gt; - QUIC使用TLS 1.3，提供更好的安全性。此外，它还加密了协议的大部分，与只加密HTTP有效载荷的TCP和TLS不同。与TCP相比，它更能抵御安全攻击。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;广泛支持&lt;/strong&gt; - 自其诞生以来，它的采用率一直在上升。这进一步加强了它的有效性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;http3和quic&#34;&gt;HTTP/3和QUIC
&lt;/h2&gt;&lt;p&gt;HTTP/3是超文本传输协议（HTTP）的最新版本。它内部使用QUIC而不是TCP。它旨在为现代网络提供更有效和安全的基础。它拥有QUIC提供的所有优势。&lt;/p&gt;
&lt;p&gt;HTTP/3由IETF标准化。今天，很大一部分互联网流量依赖于HTTP/3。以下是显示HTTP/3采用率的图表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2024/06/0fc7211ffb79567e4a515c7c0c6182f7.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;HTTP/3.0 采用率&#34;
	
	
&gt;&lt;br&gt;
从上述图表中可以看出，采用率已经飙升至30%，并逐渐超越了&lt;strong&gt;HTTP/1.1&lt;/strong&gt;。按照目前的发展速度，&lt;strong&gt;HTTP/3.0&lt;/strong&gt;将在未来几年逐渐超越&lt;strong&gt;HTTP/2.0&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论
&lt;/h2&gt;&lt;p&gt;自三十年前HTTP诞生以来，互联网已经走过了漫长的道路。HTTP的演变使在线体验更加高效和响应迅速。随着现代应用程序需求的增长，我们意识到了底层协议如TCP的固有限制。&lt;/p&gt;
&lt;p&gt;谷歌开发了改变游戏规则的协议QUIC。它利用UDP并解决了TCP的所有不足。降低延迟、多路复用、增强安全性和连接迁移是QUIC的一些显著特点。QUIC带来的创新解决了队头阻塞等问题。&lt;/p&gt;
&lt;p&gt;像谷歌和Facebook这样的大型科技公司通过在HTTP/3中采用QUIC，在性能上取得了显著提升。随着采用率的上升和日益增长的支持，HTTP/3将成为互联网通信的标准。在未来几年，互联网将发展并过渡到HTTP/3，以实现效率、可靠性和性能。&lt;/p&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.obiikriationz.com/tcp-vs-udp-meme-version.xhtml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TCP VS UDP 梗&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.apnic.net/2023/09/25/why-http-3-is-eating-the-world/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;为什么HTTP/3.0正在吞噬世界？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/pinterest-engineering/pinterest-is-now-on-http-3-608fb5581094&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Pinterest现在使用HTTP/3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://peering.google.com/#/learn-more/quic&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;与谷歌对等 - QUIC&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>了解 HTTPS：关键点和流程详解</title>
        <link>https://huizhou92.com/zh-cn/p/the-key-points-of-https/</link>
        <pubDate>Mon, 27 May 2024 18:30:32 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/the-key-points-of-https/</guid>
        <description>&lt;img src="https://images.hxzhouh.com/blog-images/2024/05/9113c36ee94b362ffe79a997b75c8efe.png" alt="Featured image of post 了解 HTTPS：关键点和流程详解" /&gt;&lt;p&gt;众所周知，HTTPS可以解决HTTP明文传输过程中的安全性问题，尤其是中间人攻击问题。其最初的全称是HTTP over SSL（或者说 http Security）。其中的SSL是指Secure Sockets Layer，后来SSL被TLS（Transport Layer Security ）所取代。今天我们就来总结一下HTTPS的要点&lt;/p&gt;
&lt;!-- more--&gt;
&lt;blockquote&gt;
&lt;p&gt;This article is first published in the medium MPP plan. If you are a medium user, please follow me in &lt;a class=&#34;link&#34; href=&#34;https://medium.hxzhouh.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;medium&lt;/a&gt;. Thank you very much.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;https-版本&#34;&gt;HTTPS 版本
&lt;/h2&gt;&lt;p&gt;当前人们一般将SSL,TLS这两个协议统称为SSL/TLS协议，但大家日常说SSL的时，默认还是指TLS协议。&lt;br&gt;
TLS 协议在版本上有1.1、1.2、1.3，其中1.2曾经是主流，现在推荐使用改进后的 TLS 1.3，它升级了HandShake和Record协议，会使得通信更加安全和高效。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2024/05/22e2063c4833a437e681f43255089763.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;图片&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安全上&lt;/strong&gt;，TLS 1.3 移除了一些在 TLS 1.2 中被认为是不安全的加密算法，如 RC4、DES、3DES、AES-CBC 和 MD5 等，这样可以减少安全漏洞的风险。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;性能上&lt;/strong&gt;，TLS 1.3 减少了握手过程中的往返次数（RTT），从而加快了连接的建立速度。在最佳情况下，TLS 1.3 只需要一次往返就可以完成握手，同时支持0-RTT扩展，而 TLS 1.2 需要两次或更多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2024/05/fa599169a9d68465dcb66b42f6e4226c.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;图片&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;当然，作为设计精良的互联网协议，TLS 1.3也通过hello握手消息的扩展协议考虑了最大化向前兼容，这点不再赘述。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2024/05/233d0bfa01e9c759211873abb971a080.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;图片&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;https-核心流程&#34;&gt;HTTPS 核心流程
&lt;/h2&gt;&lt;p&gt;依据不同版本的差异，细节流程会略有不同，不追求严谨细致的情况下，HTTPS工作流程如下。&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2024/05/1c1c9c816302b79718955b07442fc097.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;https://blog.bytebytego.com/i/53596514/how-does-https-work&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;bytebytego 的这个图非常具有表现力，展示了关键的交互和核心的加密流程。最关键的几步在于如何建立TCP链接，如何通过非对称加密协商获取对称加密的密钥，以及最后通过对称加密进行通信。&lt;/p&gt;
&lt;p&gt;HTTPS，准确来说是TLS，设计严密，其中最关键的是Record Layer和几种Protocol，前者是数据承载管道，各种子Protocol都跑在它上面 ，其中的Record是TLS数据收发传输的基本单位，类似TCP的segment，IP的Packet，这也是下面这幅图的含义。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2024/05/08895cd805cbe5719c80662f7be74df7.webp&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;图片&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上图中Protocol里最重要的是Handshake协议，针对Client Hello进行抓包后，在Wireshark中体现得会更清晰。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2024/05/9aa18213dbe2e2651ea227fe404ad6b5.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;图片&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;https-sni-扩展&#34;&gt;HTTPS SNI 扩展
&lt;/h2&gt;&lt;p&gt;互联网早期，单机服务器没那么强大，配套的HTTPS比如SSL v2也有设计缺陷。那时有一个假定，认为拥有一个IP的单台服务器只会托管一个域名服务，所以DNS解析以后，直连IP时就能非常确定要使用具体某个域名的证书。但后面云计算、虚拟主机大爆发，以及IPv4中IP的稀缺性，一台服务器托管多个域名的场景无可避免，这时服务器面临无法知道客户端到底想要访问哪个域名的SSL证书的问题，从而导致了HTTPS SNI的出现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2024/05/2af263a13abf6545b697a0dabd01785d.jpeg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;图片&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;SNI（Server Name Indication）是TLS协议的一个扩展，它允许客户端在握手过程中向服务器发送目标主机名信息。这样，服务器就可以在同一个IP地址上托管多个域名的HTTPS服务，并为每个域名提供正确的证书。&lt;/p&gt;
&lt;p&gt;这个问题看似简单，在HTTPS逐渐普及，各互联网服务商走向全站HTTPS化的早期，很多CDN厂商甚至都是不支持SNI的。当然在2024年的今天，无论是Nginx等软件生态，还是各厂商，都已经支持了的。&lt;/p&gt;
&lt;p&gt;SNI信息是通过TLS握手协议传输的，抓包示意大概是下面这样子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2024/05/632f58a2b5911fc34ca5f6716b0e9992.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;图片&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;具体到实操，可以使用openssl s_client子命令中的-servername选项来指定SNI：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;openssl s_client -connect example.com:443 -servername example.com
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果使用OpenSSL Library，也可以使用SSL_set_tlsext_host_name和BIO_set_conn_hostname等函数来在代码中设置。&lt;/p&gt;
&lt;h2 id=&#34;https-证书机制&#34;&gt;HTTPS 证书机制
&lt;/h2&gt;&lt;p&gt;HTTPS通过公钥 体系里的非对称、对称及摘要算法，实现了一系列的加解密、签名、验签等功能，基本实现了安全四大特性：机密性、完整性，身份认证和不可否认。如典型的中间人攻击（Man-in-the-middle attack，MITM），也都有了解决方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2024/05/689e0bbb76ecda3332862356747ea71d.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;图片&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这里为了解决公钥的信任问题，又引入了证书和信任链机制。证书（Certificate）是由第三方CA（Certificate Authority，证书认证机构）颁发的，本质上是一个文件，通常是.crt、.cer 或 .pem 等扩展名存储。这个文件按照一定的标准（如X.509）编码，包含了公钥、证书持有者信息、颁发机构信息、有效期和数字签名等信息。&lt;/p&gt;
&lt;p&gt;有一些世界知名的 CA 机构，比如 &lt;code&gt;DigiCert&lt;/code&gt;、&lt;code&gt;VeriSign&lt;/code&gt;、&lt;code&gt;Entrust&lt;/code&gt;、&lt;code&gt;Let’s Encrypt&lt;/code&gt; 等，它们签发的证书分 DV、OV、EV 三种，对应不同的可信程度。但CA自己也有信任问题，小CA的信任靠大CA签名认证，但逐层向上到了链条的最后，就是 Root CA，就只能用“自签名证书”（Self-Signed Certificate）或者“根证书”（Root Certificate）了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2024/05/c901e34959e328f1b9b5be02155d7f1f.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;图片&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;大部分操作系统和浏览器都内置了各大 CA 的根证书，HTTPS通信时会顺着证书链（Certificate Chain）逐层验证到根证书。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2024/05/1fe05d3e7e1932f5754b71d4c7324a2d.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;图片&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;https-软件生态&#34;&gt;HTTPS 软件生态
&lt;/h2&gt;&lt;p&gt;HTTPS，或是说TLS，生态虽然丰富，但OpenSSL一家独大。它几乎支持所有公开的加密算法和协议，已经成为了事实上的标准，许多应用软件都会使用它作为底层库来实现 TLS 功能，比如著名的 Apache、Nginx 等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2024/05/0b6cfa177e827e1d5ff6659024b945c8.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;图片&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;OpenSSL源于SSLeay，其后开枝散叶，形成众多分支，如 Google 的 BoringSSL、OpenBSD 的 LibreSSL。OpenSSL的内容也极其庞杂，可以优先使用openssl命令进行学习，具体可以参考ChatGPT。&lt;/p&gt;
&lt;h2 id=&#34;https-加速方案&#34;&gt;HTTPS 加速方案
&lt;/h2&gt;&lt;p&gt;HTTPS很美好，但美好的事物都有成本。所以关于HTTPS全站铺开后的各种优化，基本上可以写成独立的一篇文章，这里先简单提下。&lt;/p&gt;
&lt;p&gt;首先是优化RTT，这个在IO密集型的互联网场景下尤为重要，主要是通过升级协议，如升级HTTP/3，升级TLS 1.3，都可以通过不同原理来优化RTT。其次是优化单步骤性能，如增加TLS加速卡，设置单独的TLS集群或模块等，还有一些TLS session resumption等名词也可以关注。&lt;br&gt;
我以前写过一篇文章分享为什么HTTPS为什么这么慢的文章，有兴趣可以阅读一下。&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://medium.com/gitconnected/why-does-https-need-7-handshakes-and-9-times-delay-e29d0a9d046a&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Why does HTTPS need 7 handshakes and 9 times delay?&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.globalsign.com/en/blog/the-difference-between-http-and-https&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;What&amp;rsquo;s the difference between HTTP and HTTPS?&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://blog.bytebytego.com/i/53596514/how-does-https-work&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;how-does-https-work&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
