<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>huizhou92&#39;s Blog</title>
        <link>https://huizhou92.com/zh-cn/</link>
        <description>Recent content on huizhou92&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>Copyright © 2023 huizhou92</copyright>
        <lastBuildDate>Mon, 05 May 2025 16:30:26 +0800</lastBuildDate><atom:link href="https://huizhou92.com/zh-cn/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Green Tea GC: Golang 的 ZGC？</title>
        <link>https://huizhou92.com/zh-cn/p/green-tea-gc-golang-%E7%9A%84-zgc/</link>
        <pubDate>Mon, 05 May 2025 16:30:26 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/green-tea-gc-golang-%E7%9A%84-zgc/</guid>
        <description>&lt;img src="https://images.hxzhouh.com/blog-images/2025/05/fb6313678681ee8e97a05ee521bd0e20.png" alt="Featured image of post Green Tea GC: Golang 的 ZGC？" /&gt;&lt;p&gt;近年来，Go 语言的垃圾回收（GC）机制虽然经历了多个版本优化，但它的性能瓶颈，尤其在高并发与大规模内存场景下，依然是开发者关注的重点。最近，Go 官方在 GitHub 上提出的 &lt;strong&gt;Green Tea GC&lt;/strong&gt;（#73581）引发了热议：它能否进一步解决 Go GC 的耗时问题？本文将深入解析 Go GC 的设计、缺点、实测表现，并带你了解 Green Tea GC 的技术突破。&lt;/p&gt;
&lt;!-- more--&gt;
&lt;h2 id=&#34;-go-gc-的设计与实现&#34;&gt;📦 Go GC 的设计与实现
&lt;/h2&gt;&lt;p&gt;自 Go 1.5 起，Go 使用并发标记-清除（concurrent mark-sweep）算法，结合“三色标记”模型与 Yuasa 写屏障。&lt;/p&gt;
&lt;p&gt;简而言之，Go GC 会在后台并发地遍历堆内存，标记可达对象，并逐步清除未被引用的内存块。整个回收过程中，Go 追求&lt;strong&gt;低延迟、低停顿&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;✅ 并发标记、并发清除&lt;br&gt;
✅ 不会移动对象（即 no compaction）&lt;br&gt;
✅ 按 span（内存块）分批清扫，减少单次 STW（Stop-the-World）时长&lt;/p&gt;
&lt;p&gt;这种设计的直接好处是：应用大部分时间能与 GC 并行工作，最大停顿时间通常低于毫秒级。&lt;/p&gt;
&lt;h2 id=&#34;-go-gc-的已知问题&#34;&gt;🚧 Go GC 的已知问题
&lt;/h2&gt;&lt;p&gt;虽然 Go GC 的延迟表现优秀，但它在耗时和扩展性上仍有几个硬伤，尤其体现在：&lt;/p&gt;
&lt;p&gt;1️⃣ &lt;strong&gt;内存访问低效&lt;/strong&gt;&lt;br&gt;
GC 的标记阶段会跨对象跳跃，导致 CPU 频繁 cache miss、等待内存，约 35% 的 GC CPU 周期被耗在“等内存”。这在 NUMA 架构或多核大内存机器上尤为明显。&lt;/p&gt;
&lt;p&gt;2️⃣ &lt;strong&gt;缺乏分代收集&lt;/strong&gt;&lt;br&gt;
Go GC 没有分代机制，所有对象一视同仁，这在高分配率场景下显得笨重。Pinterest 工程师曾指出，内存压力一旦增大，GC 就会暴增 CPU 消耗，引发延迟激增。&lt;/p&gt;
&lt;p&gt;3️⃣ &lt;strong&gt;频繁 GC 带来的 CPU 占用&lt;/strong&gt;&lt;br&gt;
Twitch 工程团队曾报告：即便在中小堆内存下（&amp;lt;450 MiB），系统稳态下每秒会触发 8–10 次 GC，每分钟累计 400–600 次，GC 占用约 &lt;strong&gt;30% 的 CPU 时间&lt;/strong&gt;。这直接挤压了业务线程的执行空间。&lt;/p&gt;
&lt;h2 id=&#34;-性能测试gc-对-go-程序的影响&#34;&gt;📊 性能测试：GC 对 Go 程序的影响
&lt;/h2&gt;&lt;p&gt;我们来看几个实际基准的变化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Go 1.3/1.4（并发 GC 前）&lt;/strong&gt;&lt;br&gt;
大堆（10GB+）上的 GC 停顿：以秒计算。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Go 1.5（并发 GC 引入后）&lt;/strong&gt;&lt;br&gt;
相同条件下，GC 停顿压缩到 &amp;lt;1ms。&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/05/8d6a9563ad431b76e34d31077cbcd82b.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20250504161704&#34;
	
	
&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Go 1.6–1.8&lt;/strong&gt;&lt;br&gt;
最大堆 200GB，GC 停顿控制在 20ms 以下，甚至常态 1ms。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些进步非常亮眼，但注意：&lt;br&gt;
✅ 延迟控制好了&lt;br&gt;
⚠️ 总耗时和 CPU 消耗依然显著，特别是高负载或高分配场景。&lt;/p&gt;
&lt;h2 id=&#34;-green-tea-gc全新优化方案&#34;&gt;🌿 Green Tea GC：全新优化方案
&lt;/h2&gt;&lt;p&gt;面对这些问题，Go 官方提出了 Green Tea GC。它的核心优化点是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;从单对象扫描，升级为按 span（内存块）批量扫描。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小对象（≤512B）标记由单个对象粒度提升为 span 粒度。&lt;/li&gt;
&lt;li&gt;每个 span 中，只有首次标记的对象会将整个 span 推入扫描队列。&lt;/li&gt;
&lt;li&gt;GC 扫描阶段批量处理整个 span，极大提升了内存访问局部性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，Green Tea 改进了并行队列管理，采用类似 Go 调度器的工作窃取机制，进一步提高了多核扩展性。&lt;/p&gt;
&lt;h2 id=&#34;-green-tea-gc-实测表现&#34;&gt;⚡ Green Tea GC 实测表现
&lt;/h2&gt;&lt;p&gt;从初步基准来看，Green Tea GC 带来了有选择性的性能提升：&lt;/p&gt;
&lt;p&gt;✅ &lt;strong&gt;Tile38 基准（高扇出树结构）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GC 开销降低约 35%&lt;/li&gt;
&lt;li&gt;吞吐、延迟、内存使用全面优化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;⚠ &lt;strong&gt;bleve-index 基准（低扇出、频繁变异）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象分布散乱，内存局部性差&lt;/li&gt;
&lt;li&gt;Green Tea 与常规 GC 性能相近，有时略低&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结：Green Tea 并非“银弹”，但在内存局部性良好、多核扩展场景下，它展现了明显优势，并为未来 SIMD 加速等硬件优化奠定了基础。&lt;/p&gt;
&lt;h2 id=&#34;-总结&#34;&gt;🏁 总结
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;比较项&lt;/th&gt;
&lt;th&gt;当前 Go GC&lt;/th&gt;
&lt;th&gt;Green Tea GC&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;标记粒度&lt;/td&gt;
&lt;td&gt;单对象&lt;/td&gt;
&lt;td&gt;span（批量）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;内存局部性&lt;/td&gt;
&lt;td&gt;差，随机跳跃&lt;/td&gt;
&lt;td&gt;高，同 span 内批量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;多核扩展性&lt;/td&gt;
&lt;td&gt;受限&lt;/td&gt;
&lt;td&gt;改进，采用工作窃取队列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;性能提升&lt;/td&gt;
&lt;td&gt;已接近低延迟上限&lt;/td&gt;
&lt;td&gt;某些场景下 GC 耗时降 35%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;应用适用范围&lt;/td&gt;
&lt;td&gt;普通场景&lt;/td&gt;
&lt;td&gt;内存局部性好、分配密集场景&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;对于追求极限性能的开发者，Green Tea GC 提供了一个值得关注的新方向。想要试验 Green Tea，可以在 Go 1.25+ 开启实验标志体验。&lt;/p&gt;
&lt;p&gt;📝 &lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/73581&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GitHub Issue #73581&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/31684862/how-fast-is-the-go-1-5-gc-with-terabytes-of-ram&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stackoverflow.com/questions/31684862/how-fast-is-the-go-1-5-gc-with-terabytes-of-ram&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/green-tea-gc-golang-%E7%9A%84-zgc/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;本文长期链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果您觉得我的博客对你有帮助，请通过 &lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/index.xml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RSS&lt;/a&gt;订阅我。&lt;/li&gt;
&lt;li&gt;或者在&lt;a class=&#34;link&#34; href=&#34;https://x.com/@piaopiaopig&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;X&lt;/a&gt;上关注我。&lt;/li&gt;
&lt;li&gt;如果您有&lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Medium&lt;/a&gt;账号，能给我个关注嘛？我的文章第一时间都会发布在Medium。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>软件工程师的身份危机 by  Annie Vella</title>
        <link>https://huizhou92.com/zh-cn/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%BA%AB%E4%BB%BD%E5%8D%B1%E6%9C%BA-by-annie-vella/</link>
        <pubDate>Wed, 26 Mar 2025 19:17:56 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%BA%AB%E4%BB%BD%E5%8D%B1%E6%9C%BA-by-annie-vella/</guid>
        <description>&lt;img src="https://images.hxzhouh.com/blog-images/2025/03/d87dba8dde3c2ca307a2dec04a038486.png" alt="Featured image of post 软件工程师的身份危机 by  Annie Vella" /&gt;&lt;p&gt;原文地址： &lt;a class=&#34;link&#34; href=&#34;https://annievella.com/posts/the-software-engineering-identity-crisis/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://annievella.com/posts/the-software-engineering-identity-crisis/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们很多人选择成为软件工程师，是因为我们在亲手&lt;em&gt;创造&lt;/em&gt;事物中找到了自我价值——而非仅仅管理或监督已有事物。&lt;/p&gt;
&lt;p&gt;但这种身份认同正面临挑战。&lt;/p&gt;
&lt;p&gt;人工智能（AI）编码助手不仅仅改变了我们编写软件的方式，它们还在从根本上动摇了我们对自我身份的认知。我们正在从创造者转变为编排者，从建造者转变为监督者。从工程师变成了看起来非常像……管理者的人。&lt;/p&gt;
&lt;p&gt;这种讽刺意味，直击痛点：多年来，我们一直认为软件工程超越了单纯的编码。需求、设计、测试、运维——这些都被认为是我们的专业技能的一部分。然而，行业却将我们推向了相反的方向。我们将这些职责交给了专业人士——产品负责人、架构师、质量工程师、平台工程师——而我们则加倍投入到我们的编码专业知识中。我们成为了代码大师，成为了现代魔法的骄傲使用者。&lt;/p&gt;
&lt;p&gt;现在，就在我们完善这项技能的同时，人工智能正威胁着要夺走它。&lt;/p&gt;
&lt;h2 id=&#34;我们即将失去的快乐&#34;&gt;我们即将失去的快乐
&lt;/h2&gt;&lt;p&gt;让我们坦诚地谈谈这里存在着什么风险。我们中的许多人不仅仅是编写代码——我们&lt;strong&gt;热爱&lt;/strong&gt;编写代码。我们的身份融入到我们精心设计的每一个优雅的解决方案中，融入到我们通过的每一个测试中，融入到我们通过纯粹的逻辑和创造力解决的每一个问题中。这不仅仅关乎职业或技艺，而是我们身份的真实写照。&lt;/p&gt;
&lt;p&gt;想想那些充满成就感的时刻：当你最终追踪到那个困扰生产环境的难以捉摸的bug时，当你计算出如何优化那个缓慢的算法并看到响应时间从几秒降到几毫秒时，当你把一个迷宫般的遗留代码改造成干净且可维护的东西时。这些不仅仅是成就——它们是我们作为工程师的表达。它们是提醒我们为什么选择这条道路的时刻。&lt;/p&gt;
&lt;p&gt;现在想象一下人工智能接管这些精雕细琢的时刻。这些工具的创造者描绘了一幅乐观的图景——他们说我们将花更多的时间在&lt;strong&gt;定义意图&lt;/strong&gt;、&lt;strong&gt;高层架构&lt;/strong&gt;和&lt;strong&gt;系统思考&lt;/strong&gt;上。但仔细听听他们真正想说的是什么：我们将成为监督者而不是创造者，管理者而不是建造者。&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/03/d902c8a0f8ab5ac9bb58e2077195feb7.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;软件工程师正在进化为系统架构师？&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.linkedin.com/posts/ashtom_how-ai-tools-are-reshaping-the-coding-workforce-activity-7303108929264275456-O5v2&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;软件工程师正在转变为系统思考者和高层架构师吗？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这种转变引发了关于我们作为建造者的身份的重要问题：监督是驱动我们的动力吗？是它让我们早上从床上跳起来，渴望解决下一个难题吗？&lt;/p&gt;
&lt;h2 id=&#34;身份转变它已经到来&#34;&gt;身份转变：它已经到来
&lt;/h2&gt;&lt;p&gt;我们现在讨论的并不是什么理论上的未来——而是我们正在经历的现实。当谷歌最近透露人工智能&lt;a class=&#34;link&#34; href=&#34;https://arstechnica.com/ai/2024/10/google-ceo-says-over-25-of-new-google-code-is-generated-by-ai/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;生成了他们超过四分之一的新代码&lt;/a&gt;时，这仅仅是个开始。Y Combinator 的首席执行官 Garry Tan 透露，对于他们大约四分之一的初创公司来说，&lt;a class=&#34;link&#34; href=&#34;https://www.cnbc.com/2025/03/15/y-combinator-startups-are-fastest-growing-in-fund-history-because-of-ai.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;95% 的代码现在是由人工智能编写的&lt;/a&gt;——标志着一个真正意义重大的转变。我自己的硕士研究也揭示了类似的景象：77% 的人花费在编写代码上的时间变少了，几乎一半的人认为我们的核心技能可能会退居二线，让位于提示工程（prompt engineering）。想想这种转变：从设计解决方案到设计提示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://annievella.com/images/prompt-engineering-replace-coding-skills.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;提示工程会取代传统的编码技能吗？&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;提示工程会取代传统的编码技能吗？&lt;/p&gt;
&lt;p&gt;当被问及如何培养提示工程技能时，软件工程师强调要提高沟通技巧。让 AI 按照你想要的方式行事，意味着能够清晰地表达事情——提供恰到好处的上下文，并清楚地描述任务。你与生成式人工智能（Gen AI）沟通得越好，输出结果就越有可能符合你的期望。有些人甚至建议对这些工具&lt;strong&gt;礼貌&lt;/strong&gt;一些，像对待团队成员一样对待它们——好像你在引导另一个人为你做某事。&lt;/p&gt;
&lt;p&gt;这些变化如此深刻，以至于我们正在创造新的术语来描述我们正在成为什么样的人。以 &lt;strong&gt;vibe coding&lt;/strong&gt;（氛围编码，一种依赖 AI 建议进行编码的方式）为例，这是 &lt;a class=&#34;link&#34; href=&#34;https://karpathy.ai/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Andrej Karpathy&lt;/a&gt; 最近在 &lt;a class=&#34;link&#34; href=&#34;https://x.com/karpathy/status/1886192184808149383&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;推特&lt;/a&gt; 上创造的一个词。它捕捉到了我们编写软件方式的深刻转变。&lt;/p&gt;
&lt;p&gt;在这种方式的一端是传统的方式——工匠的方式。我们有目的地编写每一行代码，每一个函数名和架构决策都反映了我们对系统的深刻理解。&lt;/p&gt;
&lt;p&gt;在另一端呢？我们让 AI填补空白，与它的建议“产生共鸣”。我们关注的是“是什么”，而不是“怎么做”。正如 Karpathy 所说：“完全沉浸在氛围中，拥抱指数增长，忘记代码的存在。”&lt;/p&gt;
&lt;p&gt;最后一部分让我们停顿了一下——如果我们忘记了所有关于代码的事情，我们还是工程师吗？&lt;/p&gt;
&lt;p&gt;在最近的一次&lt;a class=&#34;link&#34; href=&#34;https://www.youtube.com/watch?v=HtqxI53h7zM&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;结对编程&lt;/a&gt;会议中，工程领域的思想领袖 &lt;a class=&#34;link&#34; href=&#34;https://itrevolution.com/author/gene-kim/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Gene Kim&lt;/a&gt; 和 &lt;a class=&#34;link&#34; href=&#34;https://steve-yegge.medium.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Steve Yegge&lt;/a&gt; 演示了这在实践中是什么样子的。他们使用 AI 编码助手，将一个 3500 行的遗留 Ruby 脚本移植到 Kotlin——这项任务通常需要一周的时间——仅用了一个小时。人工智能不仅仅翻译了代码，还改进了它，添加了他们多年来一直想要的模块化架构和单元测试，但却无法证明花费的时间是合理的。&lt;/p&gt;
&lt;p&gt;甚至连 DevOps 的教父 &lt;a class=&#34;link&#34; href=&#34;https://www.jedi.be/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Patrick Debois&lt;/a&gt; 也认为这种转变正在重塑我们的身份。在他&lt;a class=&#34;link&#34; href=&#34;https://ainativedev.io/news/the-4-patterns-of-ai-native-dev-overview&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;最近对 AI 原生开发模式的分析&lt;/a&gt;中，他概述了我们工作方式的四个根本性转变：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://annievella.com/images/patrick-debois-four-AI-native-patterns.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Patrick Debois：AI 原生开发的 4种模式&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://ainativedev.io/news/the-4-patterns-of-ai-native-dev-overview&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Patrick Debois：AI 原生开发的 4 种模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这些模式揭示了一个深刻的转变：我们正在从 AI 系统的生产者转变为管理者，从详细的实现转变为表达意图，从交付转变为通过快速实验进行发现，以及从内容创建转变为知识管理。我们的角色正在演变为将创造与组织、构建与监督相结合。&lt;/p&gt;
&lt;p&gt;总的来说，我认为可以公平地说，我们职业身份的本质正在发生核心变化。&lt;/p&gt;
&lt;h2 id=&#34;塑造我们身份的技艺&#34;&gt;塑造我们身份的技艺
&lt;/h2&gt;&lt;p&gt;要理解这种身份危机，我们需要看看编码的技艺对我们产生了多么深刻的影响。从本质上讲，编写代码是关于掌握和控制——我们花费了多年时间来完善的技能。现代编程语言比过去使用的那些语言高级得多，但它们仍然需要深厚的技术理解。如今，很少有开发人员处理指针和内存管理的细节，但我们仍然以了解事物在底层是如何运作的而自豪。即使框架承担了更多繁重的工作，我们仍然保持着我们作为工匠的身份，我们对自己的工具了如指掌。&lt;/p&gt;
&lt;p&gt;今天的编程更多的是以创造性的方式将 API、框架和库拼接在一起，以构建有意义的东西。事实上，谷歌最近的一项研究表明，软件工程中的&lt;strong&gt;创造力&lt;/strong&gt;主要集中在&lt;a class=&#34;link&#34; href=&#34;https://ieeexplore.ieee.org/document/10445159&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;巧妙的重用而不是纯粹的创新&lt;/a&gt;这一概念上。这对我来说很有意义——我经常评论说，我们现在真的都只是“集成”工程师。&lt;/p&gt;
&lt;p&gt;尽管如此，我们仍然以了解构建某些东西所需的所有奇怪语法而感到自豪。这就像一种只有我们才能理解的秘密语言。精通一门编程语言使你能够灵活驾驭、精准操控它。它非常详细——仅仅一个错误的字符就会破坏整个程序，而且可能需要大量的时间和耐心才能让它按照你想要的方式运行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先，必须完美地执行。在这方面，计算机也类似于传说中的魔法。如果一个字符，一个停顿，咒语的形式不严格正确，魔法就不会起作用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;——弗雷德里克·P·布鲁克斯，《人月神话》，第一章，Addison-Wesley，1975&lt;/p&gt;
&lt;p&gt;其他 99% 的人认为我们理解代码是魔术，而且确实，可能需要多年的刻意练习才能掌握它。那些掌握不止一种编程语言的人有幸被称为“多面手”。我们中的许多人以编写干净、优雅的代码而感到自豪。我们热情地争论不同的风格和最佳实践，而且常常对此过于认真。&lt;/p&gt;
&lt;h2 id=&#34;一位不甘心的管理者自述&#34;&gt;一位不甘心的管理者自述
&lt;/h2&gt;&lt;p&gt;让我分享一个关于身份演变的故事，它可能会引起共鸣。&lt;/p&gt;
&lt;p&gt;在做了十年个人贡献者之后，我遇到了技术职业道路上臭名昭著的天花板。“高级首席软件工程师”——这就是技术职业道路的尽头。当时 Staff+ Engineering（资深工程师之上的职级）还不存在，而我所在公司的唯一架构师职位也已有人选。我面临着一个会改变我身份的选择：继续做一名建造者，还是成为一名监督者。&lt;/p&gt;
&lt;p&gt;我选择了管理。不情愿地。这就是这条路引导我的方向。我告诉自己这仍然是工程，只是在一个不同的层面上。管理系统与管理人员并没有什么不同。我仍然可以在其他任务之间继续编写代码。&lt;/p&gt;
&lt;p&gt;听起来很熟悉吗？这其中的相似之处令人惊叹。正如我不得不将直接解决问题的工作换成会议和文档工作一样，我们现在也被要求用提示工程来代替编码。那些定义我们作为工程师的技能——掌握语法、优雅地构建我们的代码、捕获和处理边缘情况、调试复杂问题——正在被降级到人工智能。相反，我们被告知要专注于听起来非常像管理的技能：清晰的沟通、系统思考、问题定义。&lt;/p&gt;
&lt;p&gt;但这里没有人谈论的是：身份危机。当你意识到你不再用自己的双手建造东西时的那种深深的失落感。当你的技术专长变得不如你“管理”工具的能力重要时。当你的技能变成监督时。&lt;/p&gt;
&lt;p&gt;组织人工智能能给我们带来同样的身份认同感吗？一种作为建造者、创造者、问题解决者的感觉？&lt;/p&gt;
&lt;h2 id=&#34;当机器挑战我们的身份时&#34;&gt;当机器挑战我们的身份时
&lt;/h2&gt;&lt;p&gt;现在，我们身份危机的根源变得清晰起来。我们花费多年时间完善的技能——那些给予我们目标、意义和自豪感的技能——现在正被机器以更快、更便宜和更大规模的方式完成。当然，质量不如你手写的代码（但目前而言）。但是现在编写代码的速度是惊人的，企业都在争先恐后地参与进来。&lt;/p&gt;
&lt;p&gt;这就是一线希望出现的地方。还记得那种讽刺吗——我们是如何将更广泛的技能方面交给专家的？人工智能正在推动我们重新获得我们曾经知道的东西：软件工程超越了单纯的编码。这个核心真理依然存在——最终，软件工程是关于解决问题、创造解决方案、构建重要的东西。&lt;/p&gt;
&lt;p&gt;这些更广泛的技能——Addy Osmani 在他关于&lt;a class=&#34;link&#34; href=&#34;https://addyo.substack.com/p/beyond-the-70-maximizing-the-human&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;人工智能辅助编码中人类 30% 的文章&lt;/a&gt;中称之为“持久的工程技能”——一直将伟大的工程师与优秀的工程师区分开来。沟通、大局观思考、处理歧义——这些在人工智能驱动的世界中变得更加重要。&lt;/p&gt;
&lt;p&gt;然而，这种对更广泛技能的强调在我们的社区中引发了争论。对于某些人来说，这听起来很像重新包装过的管理。而且他们并没有完全错——最近的一篇 &lt;a class=&#34;link&#34; href=&#34;https://www.cio.com/article/3509174/ai-coding-assistants-wave-goodbye-to-junior-developers.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CIO 文章&lt;/a&gt; 证实，开发团队已经在进行重组，以专注于监督而不是创造。这篇文章设想未来的团队由一个产品经理、一个用户体验设计师和一个主要使用人工智能生成原型的软件架构师组成。这些架构师或高级开发人员必须“理解内容……了解客户是谁以及我们试图实现什么”——这是被重新包装成技术工作的经典管理职责。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://annievella.com/images/addy-osmani-durable-engineering-skills.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;披着技术外衣的管理&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;披着技术外衣的管理&lt;/p&gt;
&lt;p&gt;这种演变引发了关于我们作为工程师的身份的根本性问题：随着传统职业阶梯的转变，下一代软件工程师将如何发展他们的技能？我们如何在拥抱这些新工具的同时，保留塑造我们职业的深厚技术理解和技能？也许最令人不安的是——随着人工智能能力的指数级进步，我们作为工匠的角色是否会像工业革命期间的手工织布工一样过时？&lt;/p&gt;
&lt;h2 id=&#34;前进的道路&#34;&gt;前进的道路
&lt;/h2&gt;&lt;p&gt;也许答案不在于抵制这种转变，而在于通过历史的视角来理解它。这些身份危机——这些通过我们的工作来定义我们自己的根本性转变——并不是什么新鲜事。它们是技术重塑一个职业时重复出现的一种模式的一部分。&lt;/p&gt;
&lt;p&gt;在&lt;a class=&#34;link&#34; href=&#34;https://www.britannica.com/story/the-rise-of-the-machines-pros-and-cons-of-the-industrial-revolution&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;工业革命&lt;/a&gt;期间，工匠们也面临着类似的危机。他们经过几代人磨练的传统技能正在被机器取代。但接下来发生的事情令人着迷：许多人适应了，成为了可以修理和改进这些威胁要取代他们的机器的专业人士。其他人则找到了应用他们对材料和工艺的深刻理解来改进整个工厂运营的方法。&lt;/p&gt;
&lt;p&gt;如果我们把这种类比应用到我们的人工智能时代，就会出现一条类似的道路。软件工程的核心——解决问题和创造价值——仍然没有改变。我们的工具正在发展，随之而来的是有效使用它们所需的技能。&lt;/p&gt;
&lt;p&gt;问题不在于我们是否会成为机器的管理者——而在于我们是否能在这种技能的演变中找到同样的满足感。&lt;/p&gt;
&lt;h2 id=&#34;工程师的困境&#34;&gt;工程师的困境
&lt;/h2&gt;&lt;p&gt;那么，这会把我们带到哪里？我们是否注定要成为人工智能智能体的监督者，而不是代码的编写者？这是一个应该抵制还是拥抱的未来？&lt;/p&gt;
&lt;p&gt;真相，一如既往，是细致入微的。正如一些工程师自然而然地倾向于管理，而另一些工程师则更喜欢保持亲力亲为一样，我们可能会看到在如何与人工智能互动方面出现类似的范围。有些人会擅长组织人工智能系统，专注于高层设计，并使这些系统更高效和可靠——指挥一场技术交响乐，而不是进行独奏。另一些人则会在人类专业知识仍然至关重要的领域找到自己的使命——可能是在安全敏感的应用程序、人工智能缺乏训练数据的新领域，或性能和可靠性至关重要的系统中。关键不是抵制这种演变，而是在其中找到自己的位置。&lt;/p&gt;
&lt;p&gt;显而易见的是，“软件工程师”的定义正在扩大，而不是缩小。使某人有价值的技能正在多样化。这既带来了挑战，也带来了机遇。&lt;/p&gt;
&lt;p&gt;对于那些热爱编码技能的人来说，这种转变可能会让人感到威胁。但请记住，人工智能工具仍然只是工具。它们不了解代码背后的“为什么”、业务背景或所服务的人类需求。它们无法真正意义上进行创新，至少目前还不能。而且据我们所知，它们无法&lt;strong&gt;感受到&lt;/strong&gt;解决复杂问题的满足感或创造新事物的乐趣。&lt;/p&gt;
&lt;p&gt;也许在这个新领域中最有价值的技能不是提示工程或系统架构，而是&lt;strong&gt;适应性&lt;/strong&gt;——愿意进化、学习新技能，并在一个快速变化的领域中找到自己独特的位置。&lt;/p&gt;
&lt;h2 id=&#34;光明的一面&#34;&gt;光明的一面
&lt;/h2&gt;&lt;p&gt;尽管存在这些挑战，但我们需要承认一些重要的事情：这些人工智能工具可以非常强大。借助像&lt;a class=&#34;link&#34; href=&#34;https://codeium.com/windsurf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Windsurf&lt;/a&gt; 和 &lt;a class=&#34;link&#34; href=&#34;https://www.cursor.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Cursor&lt;/a&gt; 这样将软件开发提升到一个全新水平的自主智能体集成开发环境（agentic IDE），就像拥有一个始终在你身边的支持性结对编程伙伴一样，随时准备帮助你解决以前可能看起来令人望而却步的问题。&lt;/p&gt;
&lt;p&gt;对于初级开发人员或我们这些可能感到有些生疏的人来说，人工智能助手可以增强信心——在你盯着一个空白文件时帮助你入门，在你犹豫不决时验证你的方法，或者以一种对你有意义的方式解释复杂的概念。对于经验丰富的开发人员来说，它们就像拥有一个不知疲倦的助手，可以处理日常任务，而你可以专注于问题的更具挑战性的方面。&lt;/p&gt;
&lt;p&gt;如今，我们能迅速搭建原型、探索各种方法，甚至在几分钟内掌握新技术——这速度着实令人震撼。可能需要数周的研究和反复试验才能完成的事情通常可以在几小时甚至几分钟内完成。这就像拥有超能力一样——能够放大我们的能力，并比以往更快地将我们的想法变成现实。&lt;/p&gt;
&lt;h2 id=&#34;现实检验&#34;&gt;现实检验
&lt;/h2&gt;&lt;p&gt;但是，能力越大，责任越大。最近一项全面的 &lt;a class=&#34;link&#34; href=&#34;https://arc.dev/talent-blog/impact-of-ai-on-code/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GitClear 研究&lt;/a&gt; 分析了 2.11 亿行代码，揭示了一些令人担忧的趋势，因为人工智能代码生成工具变得越来越普遍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;复制粘贴的代码增加了 17.1%，这是人工智能辅助的代码重复首次超过重构（移动）的代码。&lt;/li&gt;
&lt;li&gt;重复代码块增加了 8 倍，现在有 6.66% 的提交包含重复的代码段。&lt;/li&gt;
&lt;li&gt;代码改动增加了 26%，所有代码更改中有 5.7% 在两周内被修改或删除。&lt;img src=&#34;https://annievella.com/images/gitclear-2025-trends-in-code-changes.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;GitClear：代码更改趋势&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://arc.dev/talent-blog/impact-of-ai-on-code/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GitClear：代码更改趋势&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虽然我们生成代码的速度比以往任何时候都快，但我们也花费更多的时间来修复人工智能生成的错误并处理更难维护的代码。这不仅仅是速度问题——而是关于编写可持续、可维护软件的技能。&lt;/p&gt;
&lt;h2 id=&#34;隐藏的身份危机&#34;&gt;隐藏的身份危机
&lt;/h2&gt;&lt;p&gt;然而，在这些表面上的变化之下，隐藏着一个更深层次的挑战——一个触及我们作为工程师的核心的挑战。新兴的人机协作领域正在揭示关于我们未来的令人不安的真相。&lt;a class=&#34;link&#34; href=&#34;https://www.sciencedirect.com/science/article/pii/S2352250X24000502&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2024 年的一项研究&lt;/a&gt;表明，当人类和人工智能一起工作时，结果往往达不到预期。不是因为人工智能缺乏能力，而是因为信任在机器和人类之间的运作方式不同。&lt;/p&gt;
&lt;p&gt;我们与人工智能建立信任的方式与我们与人类团队成员建立信任的方式不同。&lt;/p&gt;
&lt;p&gt;对于人类来说，信任是通过共同的成功逐渐建立起来的。一起解决的每一个问题都会加强这种联系。即使是处理得当的失败也能加深信任。对于人工智能来说，信任通常开始时很高，但会迅速瓦解。&lt;/p&gt;
&lt;p&gt;每一个不正确的回答、每一个幻觉般的错误修复、每一次放错地方的信心都会削弱我们对机器的信任。与人类关系中信任通常会随着时间的推移而增长不同，人工智能的信任通常会在早期达到顶峰并下降。&lt;/p&gt;
&lt;p&gt;当信任消失时，生产力也会下降。&lt;/p&gt;
&lt;p&gt;该研究揭示了原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;人工智能在解释我们的意图方面存在固有的不可预测性&lt;/li&gt;
&lt;li&gt;它缺乏使人类协作流畅的上下文意识&lt;/li&gt;
&lt;li&gt;它的决策通常缺乏透明度，因此一旦失去信任就很难重建&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些挑战反映了我们许多人在转变为技术领导者时所经历的事情。正如新的工程经理必须学会信任他们团队的工作而无需自己动手一样，我们现在也面临着与人工智能类似的转变——学会指导和验证，而不是自己编写每一行代码。&lt;/p&gt;
&lt;p&gt;现实是严峻的：尽管人工智能具有原始能力，但团队在有人工智能的情况下通常比没有人工智能的情况下表现更差。正如团队的生产力在无效的领导下会受到影响一样，当我们不了解如何使用我们的人工智能工具时，我们的效率也会降低。&lt;/p&gt;
&lt;h2 id=&#34;重塑你的身份&#34;&gt;重塑你的身份
&lt;/h2&gt;&lt;p&gt;从我作为一名不情愿的经理的历程以及我对这种人工智能转型的研究中，我看到了三种我们可以保留我们作为建造者身份的方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;抵制&lt;/strong&gt;——有些人会选择专注于人类创造力和深厚技术专业知识仍然至关重要的领域&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;适应&lt;/strong&gt;——另一些人会拥抱人工智能编排，成为一种新型技术交响乐的指挥家3. &lt;strong&gt;平衡&lt;/strong&gt;——还有许多人，像我一样，会寻求一条中间道路——使用人工智能来完成日常任务，同时保留直接解决问题的乐趣&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然后我意识到一个改变我观点的事实：&lt;em&gt;我们不必只选择一条道路&lt;/em&gt;。&lt;/p&gt;
&lt;h2 id=&#34;身份的钟摆&#34;&gt;身份的钟摆
&lt;/h2&gt;&lt;p&gt;也许我们身份危机的答案在于&lt;a class=&#34;link&#34; href=&#34;https://charity.wtf/2017/05/11/the-engineer-manager-pendulum/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;工程师/经理的钟摆&lt;/a&gt;。我自己在这些角色之间转换的经历教会了我一些关于身份的关键知识：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管理并没有取代我的工程师身份——它扩展了它&lt;/li&gt;
&lt;li&gt;回归亲力亲为的工作并不是倒退——而是身份的更新&lt;/li&gt;
&lt;li&gt;钟摆的摆动本身成为了我的一部分——适应性强、不断成长、不断进化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;就在那时，我突然意识到：&lt;em&gt;这正是我们需要的人工智能时代的模型&lt;/em&gt;。如果我们不必被迫成为永久的“人工智能经理”，而是可以在以下角色之间切换，那会怎么样呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;深入的技术工作，我们可以直接编写和完善代码&lt;/li&gt;
&lt;li&gt;战略编排，我们可以指导人工智能系统&lt;/li&gt;
&lt;li&gt;将这两种方法结合起来的创造性问题解决&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种平衡的方法与我从其他工程师那里听到的声音产生了深刻的共鸣。我的研究表明了一个明确的信息：保持强大的工程基础比以往任何时候都更加重要。我们需要深厚的技术知识才能有效地审查、验证和调整人工智能生成的代码——因为它通常不太正确。当被问及他们对人工智能编码助手的担忧时，软件工程师将代码质量和安全性排在工作保障之上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://annievella.com/images/ai-concerns.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;对人工智能编码助手的主要担忧&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;软件工程师对人工智能编码助手的主要担忧&lt;/p&gt;
&lt;p&gt;这告诉我一些深刻的事情：我们把自己视为工程卓越的守护者，确保人工智能生成的解决方案遵循可靠的软件工程原则。我们并不是想把我们的专业知识委托给人工智能——我们正在进化以新的方式应用我们的技能。&lt;/p&gt;
&lt;h2 id=&#34;你的行动&#34;&gt;你的行动
&lt;/h2&gt;&lt;p&gt;当我们驾驭这种转型时，一个基本的真理浮出水面：我们的身份危机实际上根本不是关于人工智能的。对人机协作的研究、与管理转型的相似之处、角色的钟摆——它们都指向更深层次的东西。除了在建造者或监督者之间做出选择之外，还存在着我们作为创造者的核心。&lt;/p&gt;
&lt;p&gt;现在我们又回到了原点：人工智能并没有抢走我们的工作，而是给了我们一个机会来重新获得我们交给专家的那些更广泛的角色方面。回到软件工程不仅仅意味着编写代码的时代。当它意味着理解整个问题空间时，从用户需求到业务影响，从系统设计到卓越运营。&lt;/p&gt;
&lt;p&gt;钟摆的比喻在这里为我们提供了智慧。正如我们中的许多人在工程和管理角色之间摇摆一样，我们可以以类似的方式拥抱人工智能的流动性。有些时候，我们会深入研究代码，体验设计优雅解决方案的快感。其他时候，我们会退一步来指导人工智能系统——不是作为监督者，而是作为了解他们技能的每一个部分的大师级建造者。就像工业革命的工人成为优化改变他们技能的机器的专家一样，我们可以掌握这些人工智能系统——使它们成为我们创造力的工具，而不是我们创造力的替代品。&lt;/p&gt;
&lt;p&gt;在人工智能时代，最重要的是保留我们本质的东西：构建事物、解决难题、使某些东西完全正确运行的纯粹乐趣。我们的工程卓越不仅仅是验证人工智能的工作——它源于对系统如此熟悉，以至于我们可以塑造它们、改进它们、改变它们。&lt;/p&gt;
&lt;p&gt;选择不是人工智能是否会改变我们的行业——它已经在改变了。真正的选择是我们如何与它一起进化。我们是会坚持对成为一名工程师的过时观念吗？还是会重新获得我们的技能，不是作为单纯的编码员，而是作为人工智能增强型系统的大师级建造者？&lt;/p&gt;
&lt;p&gt;钟摆正在摆动——你会坚守阵地，还是随之而动？&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%BA%AB%E4%BB%BD%E5%8D%B1%E6%9C%BA-by-annie-vella/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;本文长期链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果您觉得我的博客对你有帮助，请通过 &lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/index.xml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RSS&lt;/a&gt;订阅我。&lt;/li&gt;
&lt;li&gt;或者在&lt;a class=&#34;link&#34; href=&#34;https://x.com/@piaopiaopig&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;X&lt;/a&gt;上关注我。&lt;/li&gt;
&lt;li&gt;如果您有&lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Medium&lt;/a&gt;账号，能给我个关注嘛？我的文章第一时间都会发布在Medium。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>【译】：gRPC丑陋的部分</title>
        <link>https://huizhou92.com/zh-cn/p/%E8%AF%91grpc%E4%B8%91%E9%99%8B%E7%9A%84%E9%83%A8%E5%88%86/</link>
        <pubDate>Fri, 14 Mar 2025 09:59:10 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/%E8%AF%91grpc%E4%B8%91%E9%99%8B%E7%9A%84%E9%83%A8%E5%88%86/</guid>
        <description>&lt;p&gt;原文链接：https://kmcd.dev/posts/grpc-the-ugly-parts/&lt;br&gt;
这篇文章是&lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/series/grpc-the-good-and-the-bad/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gRPC：好与坏&lt;/a&gt;系列的一部分。&lt;/p&gt;
&lt;p&gt;gRPC无疑是微服务领域中的一把利器，它带来了效率和性能上的优势，但gRPC也有其丑陋的一面。作为一个在gRPC上花费了大量时间的人，我想揭示这项技术的一些不那么美好的方面。我已经讨论过gRPC的&lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/grpc-the-good-parts&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;优点&lt;/a&gt;和&lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/grpc-the-bad-parts&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;缺点&lt;/a&gt;，现在让我们来谈谈它的丑陋之处。&lt;/p&gt;
&lt;h2 id=&#34;代码生成&#34;&gt;代码生成
&lt;/h2&gt;&lt;p&gt;首先，我不得不说一下从&lt;code&gt;protobuf&lt;/code&gt;生成的代码有多么丑陋。这些代码通常很冗长、复杂且难以阅读。尽管它并不是为了手动编辑而设计的，但这会影响代码的可读性和可维护性，尤其是在将gRPC集成到大型项目中时。最近在大多数语言中，这种情况已经有所改善，但仍然存在一些粗糙的地方。&lt;/p&gt;
&lt;h3 id=&#34;语言特定的怪癖&#34;&gt;语言特定的怪癖
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;protobuf&lt;/code&gt;和&lt;code&gt;gRPC&lt;/code&gt;的初始实现常常偏离语言特定的规范，尤其是在HTTP处理方面。这在一定程度上源于强制支持&lt;code&gt;HTTP/2&lt;/code&gt;的决定，这一决定后来被证明限制了&lt;code&gt;gRPC&lt;/code&gt;在前端的应用。我们现在从&lt;code&gt;gRPC-Web&lt;/code&gt;中了解到，&lt;code&gt;trailer&lt;/code&gt;并不是像gRPC这样的协议的硬性要求。在这一决定之后，我们现在需要改进&lt;code&gt;protobuf&lt;/code&gt;和&lt;code&gt;gRPC&lt;/code&gt;的语言实现，使其更符合每种语言的习惯。&lt;/p&gt;
&lt;p&gt;对于Go语言来说，避免使用&lt;code&gt;net/http&lt;/code&gt;包是一个艰难的决定，因为这使得在与其他类型的HTTP API一起使用gRPC端点时变得更加困难，并且难以复用HTTP中间件。他们最终在grpc-go中添加了一个&lt;a class=&#34;link&#34; href=&#34;https://pkg.go.dev/google.golang.org/grpc#Server.ServeHTTP&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;ServeHTTP()&lt;/code&gt;&lt;/a&gt;接口，作为使用Go标准库中的HTTP服务器的一种实验性方法，但使用这种方法会导致&lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/benchmarking-go-grpc/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;显著的性能损失&lt;/a&gt;。也许他们这样做是出于性能考虑？如果是这样，这无疑是一个将gRPC与Go生态系统其他部分割裂的权衡。&lt;/p&gt;
&lt;p&gt;有时，语言特定的怪癖实际上会影响你如何设计protobuf类型。如果你遵循&lt;a class=&#34;link&#34; href=&#34;https://buf.build/docs/best-practices/style-guide&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Buf&lt;/a&gt;的风格建议，枚举的名称应该以枚举名的大写蛇形版本作为前缀，就像这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FooBar&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;FOO_BAR_UNSPECIFIED&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;FOO_BAR_FIRST_VALUE&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;FOO_BAR_SECOND_VALUE&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这在&lt;a class=&#34;link&#34; href=&#34;https://buf.build/docs/lint/rules#enum_value_prefix&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;buf的lint规则描述&lt;/a&gt;中有更好的解释，但这种风格指南之所以如此，是因为C++的枚举作用域规则，这使得在同一包中无法有两个具有相同枚举值名称的枚举值。虽然这种约定源于C++的作用域规则，但它影响了你应该如何设计所有的protobuf文件。为什么枚举内部的作用域不足以让C++编译器生成唯一的名称？为什么这种缺陷会影响风格指南，并进而影响所有目标语言？对我来说，这有点丑陋，因为某些语言实现的怪癖以不直观的方式冒了出来。&lt;/p&gt;
&lt;h3 id=&#34;生成的代码甚至不够快&#34;&gt;生成的代码甚至不够快
&lt;/h3&gt;&lt;p&gt;生成代码的一个好处是，你可以生成一些正常人不会写的代码，以获得一些性能优化。然而，如果你查看一些从protobuf生成的代码，你会发现大量使用了运行时反射。为什么？在某种程度上，我是在说生成的代码&lt;strong&gt;不够丑陋&lt;/strong&gt;。让我们看一个具体的例子。请注意，这将是一个非常Go特定的部分，因为我大部分关于protobuf的经验都是在Go中。然而，相同的策略已经应用于大多数语言。&lt;/p&gt;
&lt;p&gt;让我们来看一个Go中的超级简单示例。以下是protobuf：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Hello&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这是由protoc生成的类型：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Hello&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;         &lt;span class=&#34;nx&#34;&gt;protoimpl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;MessageState&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;sizeCache&lt;/span&gt;     &lt;span class=&#34;nx&#34;&gt;protoimpl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;SizeCache&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;unknownFields&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;protoimpl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;UnknownFields&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;Name&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`protobuf:&amp;#34;bytes,1,opt,name=name,proto3&amp;#34; json:&amp;#34;name,omitempty&amp;#34;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// With these methods, contents are stripped
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Reset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ProtoMessage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ProtoReflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;protoreflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Message&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;实际上，并没有为这个类型定义专门的&lt;code&gt;Marshal()&lt;/code&gt;或&lt;code&gt;Unmarshal()&lt;/code&gt;函数。这意味着序列化是通过运行时反射来实现的。反射通常被认为较慢，因为它&lt;strong&gt;确实&lt;/strong&gt;较慢。我觉得奇怪的是，没有为Go生成优化的、类型特定的序列化代码。话虽如此，你可以通过使用一个名为&lt;a class=&#34;link&#34; href=&#34;https://github.com/planetscale/vtprotobuf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vtprotobuf&lt;/a&gt;的单独protoc插件来获得这一点，该插件将为每个protobuf类型生成专门的marshal和unmarshal函数。它还允许使用类型特定的内存池，这也有助于减少分配并提高性能。根据我的&lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/benchmarking-go-grpc/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;测试&lt;/a&gt;，只需添加&lt;code&gt;vtprotobuf&lt;/code&gt;而不做任何代码更改，就可以将性能提高2-4%。这基本上是“免费”的2-4%，所以我觉得很奇怪，这竟然不是标准编译器的一部分。&lt;a class=&#34;link&#34; href=&#34;https://github.com/sudorandom/go-grpc-bench/blob/v0.0.1/gen/flex_vtproto.pb.go#L573&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;你可能不喜欢它，但这就是峰值性能的样子&lt;/a&gt;。无论如何，这个项目需要更多的关注和支持。&lt;/p&gt;
&lt;p&gt;请注意，还有其他一些项目声称在标准protobuf库的基础上取得了惊人的性能提升。他们确实通过做出一些权衡来实现这些性能提升，但很多时候，额外的复杂性是值得的。&lt;/p&gt;
&lt;p&gt;你可能会读到这一部分并想：“好吧，这会增加生成的代码量，增加二进制文件或包的大小，在某些环境中，你可能不希望这样。”这是事实，这就是为什么protobuf有一个&lt;code&gt;optimize_for&lt;/code&gt;选项，所以你可以注释以下之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;option optimize_for = SPEED;&lt;/code&gt; - 更冗长、更快的代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;option optimize_for = CODE_SIZE;&lt;/code&gt; - 更小的代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;option optimize_for = LITE_RUNTIME;&lt;/code&gt; - 旨在在较小的运行时上运行，省略了描述符和反射等功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请参阅&lt;a class=&#34;link&#34; href=&#34;https://protobuf.dev/programming-guides/proto3/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方protobuf文档&lt;/a&gt;中关于&lt;code&gt;optimize_for&lt;/code&gt;的完整描述。虽然这些选项存在，但它们实际上并没有用于大多数目标语言。将来，我完全希望看到大部分&lt;code&gt;vtprotobuf&lt;/code&gt;被整合到Go的标准protobuf编译器中，并在&lt;code&gt;optimize_for = SPEED&lt;/code&gt;时使用。将类似&lt;code&gt;vtprotobuf&lt;/code&gt;的优化整合到标准protobuf编译器中，可以为Go带来显著的性能提升，其他语言也可能存在类似的机会。&lt;/p&gt;
&lt;h2 id=&#34;必填字段&#34;&gt;必填字段
&lt;/h2&gt;&lt;p&gt;Protobuf的维护者在必填字段方面学到了一些艰难的教训。他们觉得自己犯了一个严重的错误，以至于他们推出了一个新版本的protobuf，即proto3，只是为了从规范中删除必填字段。为什么？“必填字段有害”宣言的作者在&lt;a class=&#34;link&#34; href=&#34;https://news.ycombinator.com/item?id=18190005&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;一篇冗长的Hacker News评论&lt;/a&gt;中谈到了这一点，但重要的是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现实世界的实践也表明，许多最初被认为是“必填”的字段随着时间的推移往往会变成可选的，因此有了“必填字段有害”的宣言。在实践中，你希望将所有字段声明为可选的，以便为变化提供最大的灵活性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一点在&lt;a class=&#34;link&#34; href=&#34;https://protobuf.dev/programming-guides/dos-donts/#add-required&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方protobuf风格指南&lt;/a&gt;中得到了呼应，他们建议添加注释来指示某个字段是必填的。如果我们讨论的是将消息从A传递到B，我完全同意这种思路。然而，仅仅因为某些字段被认为是“必填”的会随着时间的推移而变化，并不意味着必填字段不存在。仍然需要代码来强制执行这一要求，老实说，我不想编写这些代码。因此，我认为在不编写大量空检查的情况下处理必填字段的最佳方法是使用&lt;a class=&#34;link&#34; href=&#34;https://github.com/bufbuild/protovalidate&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;protovalidate&lt;/a&gt;或类似的库，这些库具有protobuf选项，允许你注释哪些字段是必填的。然后在服务器和/或客户端上有代码可以使用库来强制执行这些要求。在我看来，这兼具了两者的优点：你仍然可以以不会完全破坏消息完整性的方式声明必填字段。&lt;/p&gt;
&lt;p&gt;我不喜欢这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;User&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;int32&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// required.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我喜欢这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;User&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;int32&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf.validate.field&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;required&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我是&lt;a class=&#34;link&#34; href=&#34;https://github.com/bufbuild/protovalidate&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;protovalidate&lt;/a&gt;的忠实粉丝，我已经多次使用它并为其做出了贡献。一般来说，我认为protobuf字段的&lt;a class=&#34;link&#34; href=&#34;https://protobuf.dev/programming-guides/proto3/#customoptions&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;自定义选项&lt;/a&gt;是protobuf的一个未被充分利用的超能力。&lt;/p&gt;
&lt;h2 id=&#34;难以入门&#34;&gt;难以入门
&lt;/h2&gt;&lt;p&gt;尽管gRPC具有不可否认的优势，但其学习曲线可能很陡峭。对于新手来说，开始使用&lt;code&gt;protobuf&lt;/code&gt;、理解工具链以及设置必要的基础设施可能会让人望而生畏，这使得初始采用的障碍比使用更简单的基于JSON的API更高。为什么它如此陡峭？嗯，它在大多数语言中引入了非惯用的工具链。有一些语言支持的例子使得protobuf生成变得无缝。&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/en-us/aspnet/core/grpc/basics&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Grpc.Tools&lt;/a&gt; for &lt;code&gt;.NET&lt;/code&gt;就是一个闪亮的例子，展示了如何将protobuf工具链更紧密地集成到标准语言工具链中。我们需要更多这样的例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kmcd.dev/posts/grpc-the-ugly-parts/learning-curve.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;当许多使用和依赖protobuf和gRPC的人积极不希望gRPC扩展到前端，并认为推动这一方向会导致不了解情况的人侵入后端领域时，陡峭的学习曲线并没有帮助，他们认为只有他们足够聪明才能在后端工作。这是精英主义的守门行为，不幸的是，这种行业普遍存在。我相信gRPC在Web前端中与在微服务中一样有其地位。&lt;/p&gt;
&lt;p&gt;我通过帮助其他人使用protobuf学到了很多。你可能会在&lt;a class=&#34;link&#34; href=&#34;https://buf.build/links/slack&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Buf的Slack频道&lt;/a&gt;或相关讨论中看到我，因为我确实从中受益匪浅。许多文章的想法直接来自于在那里回答问题。如果我看到某个问题出现的频率足够高，我可能会写一篇文章来讨论它。我认为protobuf和gRPC社区需要更多这种态度。&lt;/p&gt;
&lt;p&gt;我相信陡峭的学习曲线（可以通过工具链来缓解），加上一些后端开发者的抵制（可以通过……同理心来缓解？），已经减缓了它在Web开发中的广泛采用。&lt;/p&gt;
&lt;h2 id=&#34;grpc有其历史&#34;&gt;gRPC有其历史
&lt;/h2&gt;&lt;p&gt;gRPC最初专注于微服务，并且与HTTP/2的紧密联系阻碍了它在Web开发中的广泛采用。即使有了&lt;a class=&#34;link&#34; href=&#34;https://grpc.io/blog/state-of-grpc-web/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gRPC-Web的出现&lt;/a&gt;，仍然有一种看法认为它在前端生态系统中并不是一等公民。与&lt;a class=&#34;link&#34; href=&#34;https://tanstack.com/query/latest&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TanStack Query&lt;/a&gt;等流行前端库缺乏强大的集成进一步巩固了这种看法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kmcd.dev/posts/grpc-the-ugly-parts/bad-blood.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;我认为通过改进工具链，有真正的机会让更多前端开发者对gRPC感到兴奋。目前，整个行业正在围绕“前端”和“后端”之间的界限进行一场巨大的讨论，我认为无论结果如何，我们都会看到更多使用gRPC的TypeScript代码。&lt;/p&gt;
&lt;h2 id=&#34;grpc中的g&#34;&gt;gRPC中的“g”
&lt;/h2&gt;&lt;p&gt;虽然&lt;a class=&#34;link&#34; href=&#34;https://grpc.io/docs/what-is-grpc/faq/#what-does-grpc-stand-for&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gRPC项目声称&lt;/a&gt; gRPC中的“g”是一个&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Backronym&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;反向缩略词&lt;/a&gt;，代表“gRPC”，但它最初代表Google，因为是Google开发并发布了protobuf和gRPC。&lt;br&gt;
&lt;img src=&#34;https://kmcd.dev/posts/grpc-the-ugly-parts/google.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;google 的墓碑&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;关于Google对gRPC和protobuf的长期承诺，始终存在一个悬而未决的问题。他们会继续投资于这些开源项目，还是会在优先级发生变化时突然撤资？请记住，Google&lt;a class=&#34;link&#34; href=&#34;https://techcrunch.com/2024/05/01/google-lays-off-staff-from-flutter-dart-python-weeks-before-its-developer-conference/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;最近裁掉了Flutter、Dart和Python团队的大部分成员&lt;/a&gt;。Protobuf社区正在发展，但它是否足够自给自足以应对这种情况？&lt;/p&gt;
&lt;h2 id=&#34;它尚未完成&#34;&gt;它尚未完成
&lt;/h2&gt;&lt;p&gt;其他人说gRPC不成熟，不是因为它的年龄，而是因为它的生态系统发展程度。我倾向于同意，因为它缺少我期望在一个成熟生态系统中看到的功能和工具。&lt;/p&gt;
&lt;h3 id=&#34;缺少包管理器&#34;&gt;缺少包管理器
&lt;/h3&gt;&lt;p&gt;在没有专门工具的情况下，跨多个项目或仓库共享protobuf定义是一个持续的挑战。虽然像&lt;a class=&#34;link&#34; href=&#34;https://bazel.build/reference/be/protocol-buffer&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Bazel&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://www.pantsbuild.org/2.21/docs/go/integrations/protobuf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Pants&lt;/a&gt;和&lt;a class=&#34;link&#34; href=&#34;https://buf.build/product/bsr&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Buf的BSR&lt;/a&gt;这样的解决方案存在，但我在“现实世界”中使用protobuf的经验……参差不齐。有一些由Google开发的开源项目，它们使用bash脚本拼凑在一起，在手动调用&lt;code&gt;protoc&lt;/code&gt;之前下载依赖项。想象一下，一个编程语言没有管理依赖项的解决方案。这太疯狂了。我认为&lt;a class=&#34;link&#34; href=&#34;https://grpc.io/blog/bazel-rules-protobuf/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Bazel&lt;/a&gt;和&lt;a class=&#34;link&#34; href=&#34;https://buf.build/docs/ecosystem/cli-overview&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Buf工具链&lt;/a&gt;很好地解决了这个问题，但我只是感到沮丧，我遇到的每个使用protobuf的仓库都以最定制化的方式解决了这个问题。社区需要团结起来改进这一点。有一个名为&lt;a class=&#34;link&#34; href=&#34;https://github.com/helsing-ai/buffrs&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Buffrs&lt;/a&gt;的开源仓库似乎正在解决这个问题。我还没有亲自使用过它，但到目前为止它看起来还不错。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kmcd.dev/posts/grpc-the-ugly-parts/build.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;关于依赖项，我想指出的是，&lt;a class=&#34;link&#34; href=&#34;https://protobuf.dev/reference/protobuf/google.protobuf/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Google的“众所周知的”protobuf类型&lt;/a&gt;享有被内置到protoc中的特权。虽然这些类型非常有用且无价，但它们的特权使得其他有用的protobuf类型库难以存在和繁荣。仅仅将这些protobuf定义内置到protoc（和其他工具链中）是对没有真正和一致的依赖管理故事的逃避。&lt;/p&gt;
&lt;h3 id=&#34;编辑器支持&#34;&gt;编辑器支持
&lt;/h3&gt;&lt;p&gt;Protobuf代码生成的编辑器集成还有很多不足之处。如果编辑器能够智能地将生成的代码链接回其protobuf源，那将非常有帮助。这将提供更无缝的体验，但工具链还不够智能。此外，我认为每个人都应该使用&lt;a class=&#34;link&#34; href=&#34;https://buf.build/docs/editor-integration&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Buf的编辑器支持&lt;/a&gt;。如今，开发者期望在编辑器中内置linter和自动格式化工具。而对于protobuf来说，有&lt;a class=&#34;link&#34; href=&#34;https://buf.build/docs/lint/rules&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;非常真实的原因&lt;/a&gt;需要遵循linter的建议。&lt;/p&gt;
&lt;p&gt;像&lt;a class=&#34;link&#34; href=&#34;https://trpc.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;tRPC&lt;/a&gt;这样的项目展示了紧密集成和意见化设计选择的好处——这是protobuf由于其性质无法完全复制的。然而，我仍然希望protobuf生态系统能够发展，提供类似的简化开发者体验。&lt;/p&gt;
&lt;h3 id=&#34;丑陋的文档&#34;&gt;丑陋的文档
&lt;/h3&gt;&lt;p&gt;我从未见过从protobuf生成的文档不是超级丑陋的。我认为，由于gRPC历来是后端服务，后端开发者从未真正努力使用protoc插件生成漂亮的文档输出。我通过&lt;a class=&#34;link&#34; href=&#34;https://github.com/sudorandom/protoc-gen-connect-openapi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;制作一个protoc插件&lt;/a&gt;解决了这个问题，该插件可以从给定的protobuf文件生成OpenAPI。然后我使用众多漂亮的工具之一来显示OpenAPI规范。这远比让我设计一个像样的文档容易得多。从protobuf生成OpenAPI的另一个附带好处是能够利用该生态系统，因为它不仅仅是文档。&lt;/p&gt;
&lt;p&gt;让我们看一个真实的例子。这是使用少数几个从protobuf生成文档的工具之一，&lt;a class=&#34;link&#34; href=&#34;https://github.com/pseudomuto/protoc-gen-doc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;protoc-gen-doc&lt;/a&gt;生成的文档：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kmcd.dev/posts/grpc-the-ugly-parts/protoc-gen-doc.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;将其与一些OpenAPI工具链进行比较。这是使用&lt;a class=&#34;link&#34; href=&#34;https://github.com/stoplightio/elements&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Elements&lt;/a&gt;生成的，但还有许多其他同样精美的替代方案：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kmcd.dev/posts/grpc-the-ugly-parts/elements.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;指责单个插件并说默认模板不如OpenAPI替代品好看有点不公平，因为实际上你确实在protoc-gen-doc中有更多的灵活性。它允许你指定自己的模板，因此它可以像你希望的那样漂亮。然而，这确实符合我的观点：在REST世界中，工具链比gRPC更完善和精致。这是一个可以解决的问题，但我们需要让前端开发者和设计师对gRPC感到兴奋，或者后端工程师需要开始磨练他们的设计技能。&lt;/p&gt;
&lt;p&gt;我还想指出，OpenAPI/Swagger接口通常有一种方法可以直接从文档网站测试端点。这在gRPC世界中的等效工具中是完全缺失的。此外，使用大多数OpenAPI文档工具，你可以清楚地看到哪些字段是必填的，并会显示具有约束的字段。因此，它不仅更漂亮，而且功能也更强大。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论
&lt;/h2&gt;&lt;p&gt;gRPC虽然在许多方面是一个强大的工具，但仍然有成长的空间。生成代码的不理想之处，加上依赖项管理和protobuf模式演变的挑战，可能会给开发者带来摩擦。缺乏直观的编辑器集成以及历史上对后端服务的关注，也阻碍了它在Web开发中的广泛采用。&lt;/p&gt;
&lt;p&gt;然而，我认为gRPC的未来是光明的，并且可以变得不那么丑陋。社区正在积极应对这些挑战，开发诸如&lt;a class=&#34;link&#34; href=&#34;https://buf.build/product/cli&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;buf CLI&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://github.com/bufbuild/protovalidate&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;protovalidate&lt;/a&gt;和&lt;a class=&#34;link&#34; href=&#34;https://github.com/sudorandom/protoc-gen-connect-openapi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;protoc-gen-connect-openapi&lt;/a&gt;等工具来弥合差距并增强开发者体验。随着gRPC的成熟和&lt;a class=&#34;link&#34; href=&#34;https://trends.google.com/trends/explore?date=all&amp;amp;q=%2Fm%2F04dzxdz,%2Fg%2F11cp5mklv8,RESTful&amp;amp;hl=en&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;其生态系统的扩展&lt;/a&gt;，我们可以期待改进的工具链、更好的编辑器支持以及更顺畅地融入前端世界。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/%E8%AF%91grpc%E4%B8%91%E9%99%8B%E7%9A%84%E9%83%A8%E5%88%86/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;本文长期链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果您觉得我的博客对你有帮助，请通过 &lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/index.xml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RSS&lt;/a&gt;订阅我。&lt;/li&gt;
&lt;li&gt;或者在&lt;a class=&#34;link&#34; href=&#34;https://x.com/@piaopiaopig&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;X&lt;/a&gt;上关注我。&lt;/li&gt;
&lt;li&gt;如果您有&lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Medium&lt;/a&gt;账号，能给我个关注嘛？我的文章第一时间都会发布在Medium。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>【译】grpc:好的部分</title>
        <link>https://huizhou92.com/zh-cn/p/%E8%AF%91grpc%E5%A5%BD%E7%9A%84%E9%83%A8%E5%88%86/</link>
        <pubDate>Wed, 12 Mar 2025 10:32:24 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/%E8%AF%91grpc%E5%A5%BD%E7%9A%84%E9%83%A8%E5%88%86/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/03/4d500118b2f1f53be2e1f5651b0a7773.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;br&gt;
原文地址: &lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/grpc-the-good-parts/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kmcd.dev/posts/grpc-the-good-parts/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虽然 REST API 仍是 Web 服务开发的主流选择，但 gRPC 正凭借其卓越的性能、效率和开发体验，受到越来越多的青睐。你可能看过我的文章《&lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/grpc-the-bad-parts/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gRPC 的不足之处&lt;/a&gt;》，其中提到了我对 gRPC 的一些不满。根据那篇文章的众多反馈，我本可以再写一篇续集来继续吐槽。但今天，我们换个角度，来探讨 gRPC &lt;strong&gt;优秀&lt;/strong&gt; 的一面。&lt;br&gt;
显然，许多人没有读完上篇文章的结尾——我曾指出，文中提到的许多问题如今已不复存在。因此，我决定专门写一篇文章，聚焦 gRPC 的优势。&lt;br&gt;
让我们深入探讨 gRPC 在现代 Web 开发中的关键价值。&lt;/p&gt;
&lt;h2 id=&#34;性能&#34;&gt;性能
&lt;/h2&gt;&lt;p&gt;这一点可能会引发争议，但 &lt;a class=&#34;link&#34; href=&#34;https://protobuf.dev/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Protocol Buffers&lt;/a&gt; 确实比 JSON 和 XML 更高效。&lt;a class=&#34;link&#34; href=&#34;https://streamdal.com/blog/ptotobuf-vs-json-for-your-event-driven-architecture/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;多项测试&lt;/a&gt;都证明了这一点。Protobuf 的高效性主要体现在以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;字段名不包含在消息中&lt;/strong&gt;：Protobuf 使用数字标识字段，而 JSON 需要存储完整的字段名。通常，Protobuf 的字段编号仅占 1-2 字节，而 JSON 的字段名可能远超这个大小。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/%E8%A7%A3%E6%9E%90go-varint-%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;VARINT 类型优化&lt;/a&gt;&lt;/strong&gt;：小整数即使声明为 int64 也只需 1 字节。在大多数应用场景中，我们很少使用大整数，这种优化能显著减少数据占用，相比 ASCII 编码的数字更加高效。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;压缩优化&lt;/strong&gt;：虽然 Protobuf 在字符串和字节数组方面并无特别优势，但 gRPC 支持数据压缩，使其至少能与 HTTP/JSON 方案持平。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在实际应用中，改用 Protobuf 编码后，我亲眼见证了数据传输量&lt;strong&gt;减少 50%&lt;/strong&gt; 的效果。&lt;br&gt;
当然，仍然有人&lt;a class=&#34;link&#34; href=&#34;https://reasonablypolymorphic.com/blog/protos-are-wrong/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;质疑 Protobuf&lt;/a&gt;。对我而言，最“致命”的缺陷是「map 的值不能是另一个 map」。从实现角度来看，这本应是可行的，但实际上并不被支持。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;MapMessage&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MapValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;values&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;MapValue&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nested&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;最令人困惑的是，我不明白为什么 &lt;code&gt;value_type&lt;/code&gt; 不能是 map。最终只能通过包装类型来嵌套 map，虽然可行，但略显繁琐。这类问题在 gRPC 中时有发生。哎，这明明是一篇夸奖 gRPC 的文章，我们回到正题。&lt;/p&gt;
&lt;p&gt;总的来说，Protobuf 在许多方面优于 JSON。当然，如果你更喜欢 JSON，&lt;a class=&#34;link&#34; href=&#34;https://protobuf.dev/programming-guides/proto3/#json&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gRPC 也完全支持 JSON&lt;/a&gt;。虽然 gRPC 消息前会有少量二进制帧字节（不可读），但如果你真的在意这些，可以参考下文 &lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/grpc-the-good-parts/#connectrpc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ConnectRPC&lt;/a&gt; 章节。&lt;/p&gt;
&lt;p&gt;此外，大多数 gRPC 实现都支持自定义编码，因此你甚至可以采用自定义的序列化方案。&lt;/p&gt;
&lt;h2 id=&#34;api-契约&#34;&gt;API 契约
&lt;/h2&gt;&lt;p&gt;告别松散的 API 类型推测。gRPC 依靠 &lt;code&gt;protobuf&lt;/code&gt; 定义，提供了严谨的客户端-服务端契约，带来诸多优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;更少错误&lt;/strong&gt;：明确的数据类型要求减少了数据不匹配的风险。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更好的代码生成&lt;/strong&gt;：支持多语言客户端/服务端代码自动生成，节省开发时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更顺畅的 API 演进&lt;/strong&gt;：有了稳定的契约，API 迭代时不易破坏已有客户端。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动化文档生成&lt;/strong&gt;：API 定义即文档，始终与实现保持同步。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;API 契约的强大之处，在我的另一篇文章《&lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/api-contracts/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;用契约构建 API&lt;/a&gt;》中有更深入的讨论。&lt;/p&gt;
&lt;h2 id=&#34;流式通信&#34;&gt;流式通信
&lt;/h2&gt;&lt;p&gt;gRPC 提供了一流的流式通信支持，消除了许多场景下的轮询需求，特别适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;实时聊天应用&lt;/strong&gt;：支持双向消息流，确保低延迟。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实时更新&lt;/strong&gt;：无需轮询，服务器可主动推送数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;需要持续通信的场景&lt;/strong&gt;：如游戏、金融数据传输等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你来自网络开发领域，可能知道基于 gRPC 的 gNMI 已取代 SNMP。通过 gNMI 订阅计数器更新，无需每分钟轮询网络设备。更多讨论可见《&lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/gnmi/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2024 年为何要选择 gNMI 而非 SNMP&lt;/a&gt;》。&lt;/p&gt;
&lt;h2 id=&#34;跨语言支持&#34;&gt;跨语言支持
&lt;/h2&gt;&lt;p&gt;gRPC 天然支持多语言，几乎涵盖所有主流编程语言。借助代码生成工具，你可以在不同技术栈之间无缝集成。&lt;/p&gt;
&lt;p&gt;这一特性极大提升了团队协作效率，也让开发者能自由选择最适合的工具。&lt;/p&gt;
&lt;h2 id=&#34;推动-http2-发展&#34;&gt;推动 HTTP/2 发展
&lt;/h2&gt;&lt;p&gt;gRPC 是 HTTP/2 普及的有力推动者，借助 HTTP/2 提供：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;多路复用&lt;/strong&gt;：单连接支持多个请求/响应，提升传输效率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;头部压缩&lt;/strong&gt;：减少冗余数据，提高传输速度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;整体性能优化&lt;/strong&gt;：HTTP/2 是更现代的 Web 通信方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http3-进展&#34;&gt;HTTP/3 进展
&lt;/h3&gt;&lt;p&gt;gRPC 正在推进对 HTTP/3 的支持。尽管官方进展缓慢，但已有多个社区实现，如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.NET 的 dotnet-grpc&lt;/li&gt;
&lt;li&gt;Rust 的 Tonic（基于 Hyper）&lt;/li&gt;
&lt;li&gt;Go 语言的 ConnectRPC 与 quic-go&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTTP/3 进一步优化了连接建立速度、解决了&lt;a class=&#34;link&#34; href=&#34;https://blog.cloudflare.com/the-road-to-quic#headoflineblocking&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;队头阻塞&lt;/a&gt;问题，并改善了丢包恢复能力。&lt;/p&gt;
&lt;h2 id=&#34;逐步替换&#34;&gt;逐步替换
&lt;/h2&gt;&lt;p&gt;若想逐步采用 gRPC 或需支持现有 REST 客户端，当前已有成熟方案：&lt;/p&gt;
&lt;h3 id=&#34;jsonhttp-转码&#34;&gt;JSON/HTTP 转码
&lt;/h3&gt;&lt;p&gt;使用 &lt;a class=&#34;link&#34; href=&#34;https://github.com/grpc-ecosystem/grpc-gateway&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gRPC-Gateway&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://cloud.google.com/endpoints&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Google Cloud Endpoints&lt;/a&gt; 或 &lt;a class=&#34;link&#34; href=&#34;https://www.envoyproxy.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Envoy&lt;/a&gt; 等工具，可以在后端享受 gRPC 优势的同时暴露 REST 风格接口。例如定义如下服务：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;service&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Greeter&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;rpc&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SayHello&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HelloRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;returns&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HelloResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;option&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;google.api.http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;/v1/greeter/{name}&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;即可通过 REST 端点访问：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl http://localhost:8080/v1/greeter/world
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这种自动转换能大幅减少支持多种 API 格式的工作量。&lt;/p&gt;
&lt;h3 id=&#34;grpc-web&#34;&gt;gRPC-Web
&lt;/h3&gt;&lt;p&gt;由于浏览器对 HTTP trailers 的支持限制，传统 gRPC 无法直接在 Web 使用。gRPC-Web 协议解决了这个问题，使浏览器也能使用 gRPC，并为仍在使用 HTTP/1.1 的平台（如某些 &lt;a class=&#34;link&#34; href=&#34;https://forum.unity.com/threads/support-for-http-2-with-unitywebrequest.1030510/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Unity&lt;/a&gt; 版本）提供支持。&lt;/p&gt;
&lt;h3 id=&#34;connectrpc&#34;&gt;ConnectRPC
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://connectrpc.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ConnectRPC&lt;/a&gt; 能够从 gRPC 定义自动生成 JSON/HTTP API，同时保持与 gRPC/gRPC-Web 兼容。&lt;a class=&#34;link&#34; href=&#34;https://connectrpc.com/docs/protocol/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Connect 协议&lt;/a&gt;更严格遵循 HTTP 标准，支持如下直观的 curl 调用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    --header &lt;span class=&#34;s2&#34;&gt;&amp;#34;Content-Type: application/json&amp;#34;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    --data &lt;span class=&#34;s1&#34;&gt;&amp;#39;{&amp;#34;name&amp;#34;: &amp;#34;world&amp;#34;}&amp;#39;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    http://localhost:8080/greeter.v1.GreeterService/SayHello
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;twirp&#34;&gt;Twirp
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://twitchtv.github.io/twirp/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Twirp&lt;/a&gt; 由 Twitch 开发，采用类似思路。&lt;a class=&#34;link&#34; href=&#34;https://twitchtv.github.io/twirp/docs/spec_v7.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;其规范&lt;/a&gt;通过 protobuf 生成更符合 HTTP 惯例的 API，但不直接支持 gRPC 协议，需要额外工作实现互操作。&lt;/p&gt;
&lt;h2 id=&#34;工具生态&#34;&gt;工具生态
&lt;/h2&gt;&lt;p&gt;虽然官方工具链仍有不足，但社区生态蓬勃发展：&lt;/p&gt;
&lt;h3 id=&#34;buf-cli&#34;&gt;Buf CLI
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://buf.build/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Buf&lt;/a&gt; 公司推出的 &lt;a class=&#34;link&#34; href=&#34;https://buf.build/product/cli&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Buf CLI&lt;/a&gt; 完全取代了官方的 protoc 编译器。它通过配置化管理 proto 文件依赖和代码生成，提供：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;lint 检查&lt;/strong&gt;：强制代码规范&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;破坏性变更检测&lt;/strong&gt;：防止协议不兼容修改&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简化工作流&lt;/strong&gt;：替代 Makefile 等临时方案&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;第三方插件与工具&#34;&gt;第三方插件与工具
&lt;/h3&gt;&lt;p&gt;gRPC 拥有丰富的插件体系，比如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/pseudomuto/protoc-gen-doc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;protoc-gen-doc&lt;/a&gt;&lt;/strong&gt;：多格式文档生成，支持自定义模板&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/sudorandom/protoc-gen-connect-openapi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;protoc-gen-connect-openapi&lt;/a&gt;&lt;/strong&gt;（作者自荐）：为 ConnectRPC 生成 OpenAPI 规范&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/bufbuild/protovalidate&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;protovalidate&lt;/a&gt;&lt;/strong&gt;：直接在 proto 中定义验证规则，期待其 &lt;a class=&#34;link&#34; href=&#34;https://github.com/bufbuild/protovalidate/issues/67&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TypeScript 支持&lt;/a&gt;实现前后端验证逻辑共享&lt;br&gt;
此外，Postman、Insomnia、k6 等主流工具都已加入 gRPC 支持阵营。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;结语&#34;&gt;结语
&lt;/h2&gt;&lt;p&gt;gRPC 以卓越的性能、强类型契约、流式通信、跨语言能力和 HTTP/2 基础，成为现代 Web 开发的强大工具。无论你是要优化 API 交互，还是构建高效可扩展的系统，gRPC 都值得一试。&lt;br&gt;
随着生态的持续发展，gRPC 的未来充满可能。如果你追求快速、可靠的 API 设计，不妨深入了解并尝试 gRPC，它或许能彻底改变你的开发方式。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/%E8%AF%91grpc%E5%A5%BD%E7%9A%84%E9%83%A8%E5%88%86/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;本文长期链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果您觉得我的博客对你有帮助，请通过 &lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/index.xml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RSS&lt;/a&gt;订阅我。&lt;/li&gt;
&lt;li&gt;或者在&lt;a class=&#34;link&#34; href=&#34;https://x.com/@piaopiaopig&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;X&lt;/a&gt;上关注我。&lt;/li&gt;
&lt;li&gt;如果您有&lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Medium&lt;/a&gt;账号，能给我个关注嘛？我的文章第一时间都会发布在Medium。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>网页图标（Icon）那些事</title>
        <link>https://huizhou92.com/zh-cn/p/%E7%BD%91%E9%A1%B5%E5%9B%BE%E6%A0%87icon%E9%82%A3%E4%BA%9B%E4%BA%8B/</link>
        <pubDate>Tue, 18 Feb 2025 11:30:38 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/%E7%BD%91%E9%A1%B5%E5%9B%BE%E6%A0%87icon%E9%82%A3%E4%BA%9B%E4%BA%8B/</guid>
        <description>&lt;img src="https://images.hxzhouh.com/blog-images/2025/02/65e64661a046efca8dcbc39b98ae2b91.png" alt="Featured image of post 网页图标（Icon）那些事" /&gt;&lt;p&gt;昨天&lt;a class=&#34;link&#34; href=&#34;https://taoshu.in/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;涛叔的博客&lt;/a&gt; 发布了一篇关于友情链接的博客，我毛遂自荐向涛叔请求添加友情链接。涛叔很快回应了我，并且在邮件中友好的提醒我，可以给博客添加一个&lt;code&gt;favicon(icon)&lt;/code&gt;，这样方便RSS订阅用户快速的区分博客。当时我心想 &lt;code&gt;favicon&lt;/code&gt; 是什么？（后端程序员伤不起）&lt;/p&gt;
&lt;!-- more--&gt;
&lt;p&gt;后面我咨询了DeepSeek:&lt;br&gt;
在网页设计中，图标（icon）是一个小而重要的元素。它不仅帮助用户快速识别网站，还能提升用户体验。&lt;/p&gt;
&lt;h3 id=&#34;常见使用场景&#34;&gt;常见使用场景：
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;浏览器标签页&lt;/strong&gt;：显示在网页标题旁边。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;书签栏&lt;/strong&gt;：用户收藏网页时显示。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主屏幕图标&lt;/strong&gt;：移动设备将网页添加到主屏幕时显示。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PWA（渐进式网页应用）&lt;/strong&gt;：作为应用图标使用。&lt;br&gt;
比如这样&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/02/6df56f22e8fad0c4fe55bffcab3ed090.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在浏览器标签页展示图标&#34;
	
	
&gt;&lt;br&gt;
在浏览器标签页展示图标。&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/02/c2530b4f9491c01730c710dcd24a325f.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在书签栏显示图标。&#34;
	
	
&gt;&lt;br&gt;
在书签栏显示图标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;甚至在安卓手机 上，使用chrome浏览器的将网页添加到主屏幕功能。可以显示icon图标。&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/02/861e9e820063fe4d7bbff32e9f8de05b.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;使用 Android Chrome 将网页添加到手机主屏幕&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;如何设置&#34;&gt;如何设置
&lt;/h2&gt;&lt;p&gt;设置icon 最简单的方式是在 网页的 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 中添加 一行。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;link&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;rel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;icon&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;image/png&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;href&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/favicon.png&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果您是使用 hugo 或者其他工具的话，可能会有favicon的设置。&lt;br&gt;
一些大型网站 比如 &lt;code&gt;google.com&lt;/code&gt;、 &lt;code&gt;apple.com&lt;/code&gt; 它们可能需要考虑的问题更多，设置也并不完全一样。&lt;/p&gt;
&lt;h2 id=&#34;一些需要注意的地方&#34;&gt;一些需要注意的地方
&lt;/h2&gt;&lt;p&gt;为了优化使用体验，在各个场景下都达到最佳的显示效果， icon的的尺寸也是有说法。&lt;/p&gt;
&lt;h3 id=&#34;常见尺寸&#34;&gt;常见尺寸：
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;16x16&lt;/strong&gt;：浏览器标签页图标。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;32x32&lt;/strong&gt;：书签栏图标。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;64x64&lt;/strong&gt;：高分辨率屏幕图标。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;180x180&lt;/strong&gt;：iOS 设备主屏幕图标。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;192x192&lt;/strong&gt; 和 &lt;strong&gt;512x512&lt;/strong&gt;：PWA 图标。&lt;br&gt;
所以我们在一些网站上会看到设置多个icon 的现象。比如 &lt;a class=&#34;link&#34; href=&#34;https://gohugo.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Hugo官网 &lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/02/4d83d2d0666f924072095b981ba2ff0e.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Hugo 官网设置了两个 icon&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现代浏览器都支持根据不同的场景，屏幕的PPI 选择不同尺寸的图标，尽量做到所有场景下都达到最好的显示效果。&lt;/p&gt;
&lt;h3 id=&#34;图标格式的选择&#34;&gt;图标格式的选择
&lt;/h3&gt;&lt;p&gt;icon 可以使用不同的图片格式，通过 type指定即可，常见的图标格式包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ICO&lt;/strong&gt;：传统格式，兼容性好，支持多尺寸。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PNG&lt;/strong&gt;：现代格式，支持透明背景，适合高分辨率屏幕。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SVG&lt;/strong&gt;：矢量格式，无限缩放不失真，适合响应式设计。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;多合一-icon&#34;&gt;多合一 Icon
&lt;/h3&gt;&lt;p&gt;如果觉得需要维护多个 icon 文件 比较麻烦的话，可以使用多合一icon（Multi-Resolution ICO 或 Multi-Size ICO）是一种包含多种尺寸和色深的图标文件。允许在一个文件中存储多个位图（BMP 或 PNG 格式）。每个位图可以具有不同的尺寸。&lt;br&gt;
ICO 文件包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;文件头&lt;/strong&gt;（Header）：定义 ICO 文件类型及包含的图像数量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;图像目录&lt;/strong&gt;（Image Directory）：描述每个图像的尺寸、色深、偏移量等信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;图像数据&lt;/strong&gt;（Image Data）：实际存储图像像素数据。&lt;br&gt;
浏览器需要一个图标时，它会从 ICO 文件中选择最合适的尺寸。缺点就是包含多个尺寸的 &lt;code&gt;.ico&lt;/code&gt; 文件可能会比单个尺寸的文件大。&lt;br&gt;
本篇文章没有继续深挖，比如 Android Chrome 独有的 &lt;code&gt;manifest.json&lt;/code&gt; 苹果设备 &lt;code&gt;apple-mobile-web-app-capable&lt;/code&gt; 等。 感兴趣的朋友可以继续深挖。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/%E7%BD%91%E9%A1%B5%E5%9B%BE%E6%A0%87icon%E9%82%A3%E4%BA%9B%E4%BA%8B/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;本文长期链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果您觉得我的博客对你有帮助，请通过 &lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/index.xml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RSS&lt;/a&gt;订阅我。&lt;/li&gt;
&lt;li&gt;或者在&lt;a class=&#34;link&#34; href=&#34;https://x.com/@piaopiaopig&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;X&lt;/a&gt;上关注我。&lt;/li&gt;
&lt;li&gt;如果您有&lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Medium&lt;/a&gt;账号，能给我个关注嘛？我的文章第一时间都会发布在Medium。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>【译】Wise工程：2025年技术栈更新</title>
        <link>https://huizhou92.com/zh-cn/p/%E8%AF%91wise%E5%B7%A5%E7%A8%8B2025%E5%B9%B4%E6%8A%80%E6%9C%AF%E6%A0%88%E6%9B%B4%E6%96%B0/</link>
        <pubDate>Thu, 13 Feb 2025 09:46:39 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/%E8%AF%91wise%E5%B7%A5%E7%A8%8B2025%E5%B9%B4%E6%8A%80%E6%9C%AF%E6%A0%88%E6%9B%B4%E6%96%B0/</guid>
        <description>&lt;p&gt;原文链接：https://medium.com/wise-engineering/wise-tech-stack-2025-update-d0e63fe718c7&lt;/p&gt;
&lt;h2 id=&#34;wise工程2025年技术栈更新&#34;&gt;Wise工程：2025年技术栈更新
&lt;/h2&gt;&lt;p&gt;截至2024财年，Wise已经为1280万活跃客户提供服务，每季度处理的跨境转账金额高达300亿英镑。超过60%的转账实现了即时到账，我们的&lt;a class=&#34;link&#34; href=&#34;https://platform.wise.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Wise平台&lt;/a&gt;为全球银行和非银行机构提供支付服务。这一成就离不开我们以技术为核心的理念、稳健的架构以及专注的工程团队。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://miro.medium.com/v2/resize:fit:1400/1*ATsu7QSH8hn5OkgrDbv3ow.jpeg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;wise的工作方式&#34;&gt;Wise的工作方式
&lt;/h2&gt;&lt;p&gt;Wise在全球主要地点拥有850多名工程师，他们被组织成独立的小组和部落。这些团队被赋予了创新和独立决策的权力，促进了透明度、信任和协作。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;本文基于我们2022年的&lt;a class=&#34;link&#34; href=&#34;https://medium.com/wise-engineering/wise-tech-stack-2022-edition-a6ac089a382f&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;技术栈&lt;/a&gt;，涵盖了Wise技术栈的最新改进，帮助我们实现无国界的资金流动——即时、便捷、透明，最终实现免费。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;使用wise转账&#34;&gt;使用Wise转账
&lt;/h2&gt;&lt;h2 id=&#34;我们的网页和移动应用&#34;&gt;我们的网页和移动应用
&lt;/h2&gt;&lt;p&gt;我们的网页应用基于CRAB（Wise特有的抽象层，构建在流行的Next.js框架之上），包含40个独立的应用程序，每个应用负责特定的产品功能，使得部署更加安全和易于管理。&lt;/p&gt;
&lt;p&gt;在测试方法上，我们最大的变化之一是引入了&lt;a class=&#34;link&#34; href=&#34;https://storybook.js.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Storybook&lt;/a&gt;，用于在开发过程中可视化单个React组件。Storybook与&lt;a class=&#34;link&#34; href=&#34;https://www.chromatic.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Chromatic&lt;/a&gt;配合使用，能够在每次更改后捕获快照，并突出组件的视觉差异。这些快照在代码更改过程中非常有效，帮助我们防止错误影响到客户。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Wise移动应用：更快、更智能、更高效&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们的&lt;strong&gt;iOS工程师&lt;/strong&gt;通过将250多个Xcode模块从Xcodegen迁移到Tuist，并将Cocoapods切换到Swift Package Manager（SPM），升级了基础设施，从而实现了构建缓存的改进。团队还提高了灵活性，将零变更&lt;strong&gt;构建时间从28秒减少到2秒&lt;/strong&gt;。借助先进的构建缓存，开发变得更加顺畅，并朝着使用SPM的Swift可组合架构方向发展。&lt;/p&gt;
&lt;p&gt;我们的&lt;strong&gt;Android工程师&lt;/strong&gt;则专注于大规模应用开发。主要Android代码库包含300多个Gradle模块和大约100万行代码，涵盖2个生产应用、6个示例应用、17个JVM模块、221个Android模块和65个多平台模块。我们提高Android开发速度的努力集中在以下几个关键领域：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用更多的&lt;a class=&#34;link&#34; href=&#34;https://blog.bitsrc.io/bff-pattern-backend-for-frontend-an-introduction-e4fa965128bf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;BFFs&lt;/a&gt;在Android、iOS和网页团队之间共享代码逻辑。&lt;/li&gt;
&lt;li&gt;基于&lt;a class=&#34;link&#34; href=&#34;https://kotlinlang.org/docs/ksp-overview.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;KSP&lt;/a&gt;构建代码生成工具。&lt;/li&gt;
&lt;li&gt;探索&lt;a class=&#34;link&#34; href=&#34;https://kotlinlang.org/docs/multiplatform.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Kotlin多平台&lt;/a&gt;的应用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在用户界面方面，我们已经全面转向Compose——首先用于设计系统，现在用于整个屏幕和导航。我们迅速采用了Kotlin 2.0和2.1版本。为了处理异步任务，我们使用协程和流，而我们的架构遵循标准的MVVM模式，并得到Google的Jetpack库的支持。&lt;/p&gt;
&lt;h2 id=&#34;后端服务&#34;&gt;后端服务
&lt;/h2&gt;&lt;p&gt;Wise总共运行超过&lt;strong&gt;1000个服务&lt;/strong&gt;。在后端，我们主要使用Java和Kotlin。自上次更新以来，我们专注于通过开发内部工具来提高自动化和效率，从而加快开发速度，并提供跨不同服务使用的标准库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更快构建优秀应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自上次更新以来，我们一直专注于&lt;strong&gt;通过自动化代码更新和可扩展的依赖管理解决方案来实现大规模工程&lt;/strong&gt;。为此，我们：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引入了一个内部微服务底层框架，基于最小配置原则构建，并作为构件发布，使我们能够更快地构建标准微服务。它配置了服务使用的常见功能，提供推荐的默认设置：安全性、可观察性、数据库通信、与Kafka的交互等，使团队能够专注于业务逻辑。&lt;/li&gt;
&lt;li&gt;通过内部Gradle插件集合改善构建管道的标准化。一个显著的例子是我们的插件，它标准化了GitHub Actions工作流。这使得通过简单的插件版本更新实现组织范围内的工作流更改变得轻而易举，使得在700多个Java代码库中推出SLSA等倡议变得轻松。&lt;/li&gt;
&lt;li&gt;引入了一种语言无关的自动化服务，使我们能够在大规模上对代码库进行复杂更改，并为拥有团队创建拉取请求进行审查。通过使用该服务，我们进一步推进了集中式Java依赖管理平台，通过自动化Java服务的依赖升级。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;直接与本地支付系统集成&#34;&gt;直接与本地支付系统集成
&lt;/h2&gt;&lt;p&gt;我们已在菲律宾上线了即时支付系统InstaPay，并获得了加入日本即时支付系统Zengin的许可。我们还获得了巴西PIX的接入权限。&lt;/p&gt;
&lt;p&gt;在Wise，我们投入了大量精力来创建尽可能一致的架构，网络通过&lt;a class=&#34;link&#34; href=&#34;https://aws.amazon.com/transit-gateway/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;AWS Transit Gateways&lt;/a&gt;集中管理。英国、匈牙利和澳大利亚的物理数据中心集成的细节存在显著差异。我们的澳大利亚数据中心是&lt;a class=&#34;link&#34; href=&#34;https://aws.amazon.com/outposts/servers/features/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;AWS Outpost Servers&lt;/a&gt;的首次部署之一，使我们能够在尽可能多的基础设施中保持一致的AWS工具。&lt;/p&gt;
&lt;h2 id=&#34;允许企业使用我们的api&#34;&gt;允许企业使用我们的API
&lt;/h2&gt;&lt;p&gt;我们的公共API允许企业直接集成Wise的跨境支付服务，使用安全的&lt;strong&gt;REST API，支持OAuth认证&lt;/strong&gt;。这为&lt;a class=&#34;link&#34; href=&#34;https://wise.com/gb/business/api&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;企业&lt;/a&gt;提供了转账、货币兑换和账户管理的功能，以及全面的文档和开发者工具，以简化集成过程。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://platform.wise.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Wise平台&lt;/a&gt;支持超过&lt;strong&gt;70种货币&lt;/strong&gt;和多种支付路线，提供无缝的全球连接解决方案。该平台包括内置的合规功能，允许在利用Wise广泛的全球基础设施的同时，实现无缝的跨境操作。&lt;/p&gt;
&lt;h2 id=&#34;扩展wise的基础设施平台&#34;&gt;扩展Wise的基础设施平台
&lt;/h2&gt;&lt;p&gt;为了适应快速增长，我们专注于重建基础设施，以确保效率和灵活性，同时减少团队的运营负担。&lt;/p&gt;
&lt;h2 id=&#34;引入我们的新kubernetes支持的计算运行时平台&#34;&gt;&lt;strong&gt;引入我们的新Kubernetes支持的计算运行时平台&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;**计算运行时平台（CRP）**是我们新的可扩展平台，利用Kubernetes，使工程团队能够轻松托管应用程序，而无需管理复杂的基础设施设置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发展我们的Kubernetes栈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自2018年以来，Wise一直依赖于使用Terraform、JSONNET和ConcourseCI构建的Kubernetes，以支持服务网格控制（Envoy）、PCI-DSS合规性和无摩擦的部署。虽然这一模型为我们提供了良好的服务，但我们需要一种更可扩展和标准化的方法。这就是我们引入CRP的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Terraform仍然负责基础设施的配置，但我们从头开始重写了代码库，以提高灵活性和可维护性。&lt;/li&gt;
&lt;li&gt;RKE2处理集群引导，Rancher管理整体集群状态。&lt;/li&gt;
&lt;li&gt;Helm取代JSONNET，以提高可维护性和上游兼容性。&lt;/li&gt;
&lt;li&gt;ArgoCD与自定义插件确保完全自动化的配置和一致性。&lt;/li&gt;
&lt;li&gt;我们的Envoy服务代理现在包括服务之间的无缝集成和发现，提高了平台的灵活性、弹性和监督。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://miro.medium.com/v2/resize:fit:1400/1*FiGHm58o_T1Cyujym01S6g.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;因此，我们的Kubernetes集群数量从6个增长到超过20个，同时保持可维护性和效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更智能的自动扩展和成本优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了更好地配置和维护基础设施的能力外，我们还通过CRP引入了效率改进：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们正在构建一个灵活的、可选择的自动扩展解决方案，以降低云成本和团队的认知负担。&lt;/li&gt;
&lt;li&gt;自动化容器CPU&lt;a class=&#34;link&#34; href=&#34;https://aws.amazon.com/blogs/opensource/right-size-your-kubernetes-applications-using-open-source-goldilocks-for-cost-optimization/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;调整大小&lt;/a&gt;（通过垂直Pod自动扩展器）现在在非生产环境中上线，并正在向非关键工作负载的生产环境推广。&lt;/li&gt;
&lt;li&gt;完全托管的边车容器（如Envoy代理）现在简化了产品团队的部署。&lt;/li&gt;
&lt;li&gt;扩展水平扩展，使用&lt;a class=&#34;link&#34; href=&#34;https://keda.sh/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;KEDA&lt;/a&gt;，根据每日和每周的流量模式优化工作负载。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对成本优化的关注使Wise更接近于&lt;a class=&#34;link&#34; href=&#34;https://wise.com/p/our-mission&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;strong&gt;零任务&lt;/strong&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;构建可扩展可靠和智能的数据基础设施&#34;&gt;构建可扩展、可靠和智能的数据基础设施
&lt;/h2&gt;&lt;p&gt;在Wise，我们的许多工作都与数据的移动和理解有关。无论是转账、更新实时仪表板，还是为后台的机器学习模型提供动力，我们的系统都在不断处理和分发大量信息。随着我们全球足迹的扩大，我们对更快、更安全和更灵活的数据处理方式的需求也在增加。以下是我们如何发展数据技术栈，以继续为客户提供可靠、便捷和高效的体验的快速概述。&lt;/p&gt;
&lt;h2 id=&#34;为我们的数据骨干提供动力&#34;&gt;&lt;strong&gt;为我们的数据骨干提供动力&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;在Wise，我们的数据库是我们所有工作的基础之一，因此我们在使其既稳健又易于管理方面投入了大量精力。在幕后，我们的数据库工程师正在解决一些引人入胜的技术挑战，推动金融数据管理的可能性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们努力将大部分MariaDB和Postgres工作负载从EC2迁移到Amazon RDS。这一转变减少了维护任务，降低了运营开销，并提供了更强大的安全功能。&lt;/li&gt;
&lt;li&gt;同样，我们正在将自托管的MongoDB迁移到MongoDB Atlas，这使我们能够专注于构建新功能，而不是与扩展作斗争。&lt;/li&gt;
&lt;li&gt;Redis继续为我们的内存工作负载提供支持。&lt;/li&gt;
&lt;li&gt;我们还在探索分布式数据库，以实现更大的关系可扩展性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://miro.medium.com/v2/resize:fit:1400/1*3bHF_ughnPcJi1epuqewLw.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;更智能的工作流编排和可观察性&#34;&gt;&lt;strong&gt;更智能的工作流编排和可观察性&lt;/strong&gt;
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我们采用了一种名为&lt;a class=&#34;link&#34; href=&#34;https://temporal.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Temporal&lt;/a&gt;的工作流引擎，以自动化关键任务，如&lt;a class=&#34;link&#34; href=&#34;https://medium.com/wise-engineering/how-wise-reduced-aws-rds-maintenance-downtimes-from-10-minutes-to-100-milliseconds-18ab69fe2346&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;切换&lt;/a&gt;和恢复测试。这有助于我们将停机时间降至最低，并保持符合严格的弹性法规。&lt;/li&gt;
&lt;li&gt;像RDS性能洞察和Percona监控与管理（PMM）这样的工具为我们提供了清晰的数据库运行状况视图，使我们能够及早解决问题。&lt;/li&gt;
&lt;li&gt;我们还在尝试使用直接的云SDK来管理我们的基础设施——逐步从Terraform Enterprise转向简化我们的配置流程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;保持数据流动&#34;&gt;&lt;strong&gt;保持数据流动&lt;/strong&gt;
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Kafka支撑着我们大多数实时数据的移动——无论是服务之间的异步消息传递、日志收集，还是分析的流式更新。&lt;/li&gt;
&lt;li&gt;我们的Kafka集群容量显著增长，并引入了诸如机架感知备用副本等功能，以提高容错能力。&lt;/li&gt;
&lt;li&gt;我们的内部数据移动服务帮助将信息从Kafka或数据库引导到Snowflake、S3 Parquet、Iceberg或其他目标。&lt;/li&gt;
&lt;li&gt;配置过程中的自动检查减少了人为错误，其日益增长的使用表明团队发现设置新管道变得更简单、更快捷。&lt;/li&gt;
&lt;li&gt;另一个内部服务，数据归档，现在在多个数据库中归档超过1000亿条记录。这不仅节省了成本，还使我们的数据库更易于备份和恢复。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;将数据转化为洞察&#34;&gt;&lt;strong&gt;将数据转化为洞察&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;Wise各团队使用我们的商业智能工具做出战略性、数据驱动的决策，以提升客户体验——从欺诈检测到个性化营销和预测分析。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽管我们仍然依赖Snowflake作为分析的核心组成部分，但我们已经在Amazon S3上建立了数据湖的基础，使用Apache Iceberg。得益于其强大的开放表格式，Apache Iceberg使我们能够更高效地在S3上存储大量数据。它允许我们在不需要重写所有数据的情况下修改表结构，从而加快查询速度并控制存储成本。此外，其活跃的开源社区不断推动改进，惠及我们的长期可扩展性。&lt;/li&gt;
&lt;li&gt;在我们的数据源和商业智能工具之间是Trino，它使我们能够在一个地方查询Iceberg表、Snowflake或甚至Kafka流。&lt;/li&gt;
&lt;li&gt;一个新的Trino网关处理工作负载分离和容错查询，而复杂的工作流仍由Airflow和dbt-core管理。有关此主题的深入了解，请观看我们数据工程师最近的会议&lt;a class=&#34;link&#34; href=&#34;https://www.youtube.com/watch?v=K5RmYtbeXAc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;演讲&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;报告和仪表板使用Looker或Superset构建——团队选择最适合的工具集。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://miro.medium.com/v2/resize:fit:1400/1*ebFu8iFjqXGSzvy1fAayvA.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;推动智能解决方案&#34;&gt;&lt;strong&gt;推动智能解决方案&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;我们的机器学习架构旨在支持探索和生产，无缝集成机器学习功能到产品中，以改善客户入职和欺诈预防，并利用负责任的人工智能技术。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们的数据科学家在Amazon SageMaker Studio中工作，选择JupyterLab或VSCode来构建实验和探索数据。&lt;/li&gt;
&lt;li&gt;大规模处理在EMR上使用Spark进行，而Airflow则协调数据收集、清理、模型训练和定期再训练，以保持每个步骤按计划进行。&lt;/li&gt;
&lt;li&gt;我们使用SageMaker特征存储来保持数百个特征在训练和推理中的同步，MLflow跟踪实验、指标和模型版本。这种设置简化了模型变体的比较或在需要时的回滚。&lt;/li&gt;
&lt;li&gt;当模型准备好投入生产时，我们通过基于Ray Serve的内部预测服务进行部署。&lt;/li&gt;
&lt;li&gt;多亏了MLflow插件，我们的数据科学家可以以最小的摩擦推出模型——加快欺诈检测、KYC或其他用例的推理时间，在这些情况下每毫秒都至关重要。&lt;/li&gt;
&lt;li&gt;自动检查有助于在数据漂移或特征不一致变成严重问题之前捕捉到它们。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://miro.medium.com/v2/resize:fit:1400/1*Rux3bEKC2spJhQ3H6sOr-g.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;解锁新的人工智能能力&#34;&gt;&lt;strong&gt;解锁新的人工智能能力&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;我们创建了一个安全的网关，连接多个大型语言模型提供商，包括Anthropic（Claude）、AWS（Bedrock）、Google（Gemini）和OpenAI（gpt和o系列）。这种方法使我们能够在不处理单独凭证或复杂合规检查的情况下实验不同的模型。一个受LangChain启发的Python库封装了这些API，以加快原型设计。&lt;/p&gt;
&lt;p&gt;对于需要引用内部文档、知识库或用户数据的情况，我们提供了一个自定义的检索增强生成（RAG）服务。它在生成响应之前从各种数据存储中提取最新信息——这是总结复杂文档或自动化客户服务工作流的便捷功能。&lt;/p&gt;
&lt;h2 id=&#34;智能数据管理&#34;&gt;&lt;strong&gt;智能数据管理&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;我们的数据架构既庞大又复杂，因此我们建立了一个全面的库存系统和专门的治理门户，以显示数据存储的位置及其分类。&lt;/p&gt;
&lt;p&gt;我们已在整个数据资产中实现了自动化数据发现，以了解创建了什么数据；谁创建了它；以及数据的类别是什么。我们正在利用我们的数据库存来支持数据删除、数据合规和数据发现的工作。这种设置不仅支持审计和法规的合规工作，还提高了开发者的生产力。&lt;/p&gt;
&lt;p&gt;随着越来越多的工程师加入治理工作，我们能够推出更严格的政策、增强的隐私检查和自动化的数据生命周期管理。&lt;/p&gt;
&lt;h2 id=&#34;开发者赋能wise的cicd演变&#34;&gt;开发者赋能——Wise的CI/CD演变
&lt;/h2&gt;&lt;p&gt;为了加强我们的交付管道和开发者体验，我们不断发展我们的CI/CD平台，以使开发者能够比以往更快、更可靠地将功能交付给客户。&lt;/p&gt;
&lt;h2 id=&#34;ci改进速度和安全性&#34;&gt;&lt;strong&gt;CI改进：速度和安全性&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;从CircleCI迁移到GitHub Actions带来了优化的新可能性。通过实施详细的指标跟踪，我们发现了构建性能的关键见解。例如，通过预填充常用容器的缓存，我们&lt;strong&gt;将构建时间缩短了15%&lt;/strong&gt;。&lt;strong&gt;在我们每月50万次构建的规模下，这相当于每月节省超过1000小时。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们一直在有条不紊地在我们的构建过程中实施&lt;a class=&#34;link&#34; href=&#34;https://slsa.dev/spec/v1.1/about&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;SLSA框架&lt;/a&gt;，逐步加强我们的供应链安全。&lt;/p&gt;
&lt;h2 id=&#34;cd转型从octopus到spinnaker&#34;&gt;&lt;strong&gt;CD转型：从Octopus到Spinnaker&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;在我们之前的&lt;a class=&#34;link&#34; href=&#34;https://medium.com/wise-engineering/state-of-our-ci-cd-pipeline-part-2-29bd17515e6f&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;文章&lt;/a&gt;中提到的CI/CD管道状态之后，我们的部署策略随着从Octopus（我们的内部工具）转向&lt;a class=&#34;link&#34; href=&#34;https://spinnaker.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Spinnaker&lt;/a&gt;而发生了变化。这不仅仅是工具的更换——它代表了一种范式转变，从将部署视为简单的事务转变为将其视为有序事件序列。&lt;/p&gt;
&lt;p&gt;这一转变使我们能够减少工程师在部署管理上花费的时间，并最小化缺陷到达客户的风险。这提高了开发者的交付速度，使我们能够更快地为客户提供服务，而不牺牲质量和稳定性。&lt;/p&gt;
&lt;h2 id=&#34;高级金丝雀测试&#34;&gt;&lt;strong&gt;高级金丝雀测试&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;Spinnaker的&lt;a class=&#34;link&#34; href=&#34;https://spinnaker.io/docs/guides/user/canary/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;自动金丝雀分析&lt;/a&gt;已成为我们部署管道的基石。该过程在其简单性中优雅而强大：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;仅5%的流量路由到新服务版本进行测试&lt;/li&gt;
&lt;li&gt;对技术和业务指标进行全面的30分钟分析&lt;/li&gt;
&lt;li&gt;对重大异常触发自动回滚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，仅在2024年，这一系统自动阻止了数百次可能导致事件的部署，节省了数千小时的工程时间。&lt;/p&gt;
&lt;p&gt;目前，Wise的超过一半服务已在Spinnaker上运行，预计到2025年中期将完成全面迁移，我们准备迈出下一步：实施托管交付，以协调整个SDLC，包括测试和数据管理。&lt;/p&gt;
&lt;h2 id=&#34;lgtm堆栈的可观察性&#34;&gt;LGTM堆栈的可观察性
&lt;/h2&gt;&lt;p&gt;我们改善了可观察性生态系统，以更好地监控、理解和优化Wise产品。可靠性工程师专注于构建一个更强大、高效和富有洞察力的可观察性平台，以应对我们快速扩展环境中的关键挑战。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://miro.medium.com/v2/resize:fit:1400/1*eH9-LcxB8IGstQdZ9N8Spg.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;专用的可观察性基础设施&#34;&gt;&lt;strong&gt;专用的可观察性基础设施&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;我们实施了专用的可观察性CRP集群。这为在不同环境中运行的服务提供了开箱即用的可观察性。因此，我们简化了监控设置，减少了手动配置的负担。&lt;/p&gt;
&lt;h2 id=&#34;统一的指标和监控堆栈&#34;&gt;&lt;strong&gt;统一的指标和监控堆栈&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;为了解决可扩展性问题，我们已从Thanos迁移到Grafana Mimir。这意味着我们现在完全运行在&lt;a class=&#34;link&#34; href=&#34;https://grafana.com/go/webinar/getting-started-with-grafana-lgtm-stack/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LGTM堆栈&lt;/a&gt;上：Loki用于日志，Grafana用于仪表板和可视化，Tempo用于跟踪，Mimir用于指标。作为我们在可观察性方面持续改进的一部分，我们正在试点测试Grafana Pyroscope，以对选定服务进行分析，探索性能洞察和优化的新维度。&lt;br&gt;
我们的指标堆栈每秒接收约600万个指标样本，并处理我们最大指标租户的1.5亿个活动系列。&lt;br&gt;
通过统一我们的堆栈，我们：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在整个技术生态系统中标准化可观察性。&lt;/li&gt;
&lt;li&gt;增强日志、指标、跟踪和仪表板之间的关联。&lt;/li&gt;
&lt;li&gt;改善监控基础设施的性能和可扩展性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;可观察性的成本优化和效率&#34;&gt;&lt;strong&gt;可观察性的成本优化和效率&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;最后，我们继续投资于优化我们的可观察性堆栈。我们能够降低运营成本，提高资源利用率，并最终拥有更可持续的长期可观察性战略。请查看我们之前的&lt;a class=&#34;link&#34; href=&#34;https://medium.com/wise-engineering/grafana-mimir-compaction-from-bottleneck-to-savings-b26c6b0125a6&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;文章&lt;/a&gt;，详细介绍了我们在这些倡议上所做的工作。&lt;/p&gt;
&lt;p&gt;这一战略演变使我们的工程团队能够获得更深入、更具可操作性的洞察，同时确保我们的可观察性基础设施既强大又具有成本效益。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论
&lt;/h2&gt;&lt;p&gt;总之，我们2025年的技术栈证明了Wise如何引领潮流，为全球1280万活跃客户提供最快、最可靠和最具成本效益的资金转移方式。对标准化和集成的高度关注意味着我们的系统旨在高效扩展，同时确保稳健的风险和合规管理。&lt;/p&gt;
&lt;p&gt;我们的工程团队继续在所有领域精炼我们的基础设施，从移动和网页应用到后端服务和机器学习。这些努力简化并加速了跨境资金流动，确保我们为当前需求和未来增长做好准备。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们致力于长期投资，构建最佳基础设施，以无缝管理您在全球范围内的资金&lt;/strong&gt;。随着每一次技术增强和与支付系统的新直接连接，我们正稳步朝着实现&lt;strong&gt;无国界资金流动&lt;/strong&gt;的愿景迈进。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Go1.24: mutex自旋优化,最大提升70%的性能</title>
        <link>https://huizhou92.com/zh-cn/p/go124-mutex%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96%E6%9C%80%E5%A4%A7%E6%8F%90%E5%8D%8770%E7%9A%84%E6%80%A7%E8%83%BD/</link>
        <pubDate>Tue, 11 Feb 2025 11:16:36 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/go124-mutex%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96%E6%9C%80%E5%A4%A7%E6%8F%90%E5%8D%8770%E7%9A%84%E6%80%A7%E8%83%BD/</guid>
        <description>&lt;img src="https://images.hxzhouh.com/blog-images/2025/02/aee1ae007540f5e7191e3ac7cd6b4f8d.png" alt="Featured image of post Go1.24: mutex自旋优化,最大提升70%的性能" /&gt;&lt;h2 id=&#34;背景&#34;&gt;背景
&lt;/h2&gt;&lt;p&gt;Rhys Hiltner 在 2024 年提出了改进互斥锁的性能优化诉求。现在这个优化已经合并到即将发布的Go1.24中，在锁竞争激烈的场景下最多会提升70%的性能。&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/02/8c658c9a0a11655b7500d13e4ad68206.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;source https://github.com/golang/go/issues/68578 &#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在基准测试 ChanContended 中，作者发现随着 &lt;code&gt;GOMAXPROCS&lt;/code&gt; 的增加，mutex 的性能明显下降。&lt;br&gt;
&lt;strong&gt;Intel i7-13700H&lt;/strong&gt; (linux/amd64)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当允许使用 4 个线程时，整个进程的吞吐量是单线程时的一半。&lt;/li&gt;
&lt;li&gt;当允许使用 8 个线程时，吞吐量再次减半。&lt;/li&gt;
&lt;li&gt;当允许使用 12 个线程时，吞吐量再次减半。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;GOMAXPROCS=20&lt;/code&gt; 时，200 次channel操作平均耗时 44 微秒，平均每 220 纳秒调用一次 unlock2，每次都有机会唤醒一个睡眠线程。&lt;br&gt;
另一个角度是考虑进程的 CPU占用时间。&lt;br&gt;
下面的数据显示，在 1.78 秒的&lt;code&gt;Wall-Clock Time&lt;/code&gt;内，&lt;strong&gt;进程的20个线程在lock2调用中总共有27.74秒处于CPU(自旋)上。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/02/19eeb4e1afc7cce66c0bc6af46dff2d6.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这些 lock2 相关的线程并没有休眠，而是一直在自旋，这将消耗大量的CPU资源。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;新提案增加spinning状态&#34;&gt;新提案：增加spinning状态
&lt;/h1&gt;&lt;p&gt;通过上述的分析，作者发现在当前的lock2实现中，虽然理论上允许线程睡眠，但实际上导致所有线程都在自旋，导致了更慢的锁传递，带来了不少的性能损耗。&lt;br&gt;
于是提出了新的设计方案&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/proposal/blob/master/design/68578-mutex-spinbit.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《Proposal: Improve scalability of runtime.lock2》&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;核心优化点&#34;&gt;核心优化点
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;mutex 的状态字添加了一个个新的标志位，称为 “spinning”&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;https&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//github.com/golang/go/blob/608acff8479640b00c85371d91280b64f5ec9594/src/runtime/lock_spinbit.go#L57
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0x001&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;mutexSleeping&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0x002&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;mutexSpinning&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0x100&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;使用这个 &lt;code&gt;spinning&lt;/code&gt;位来表示是否有一个等待的线程处于 “醒着并循环尝试获取锁” 的状态。线程之间会互相排除进入 &lt;code&gt;spinning&lt;/code&gt;状态，但它们不会因为尝试获取这个标志位而阻塞。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;metux 的介绍可以参考以前的文章&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://pub.huizhou92.com/go-source-code-sync-mutex-3082a25ef092&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pub.huizhou92.com/go-source-code-sync-mutex-3082a25ef092&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;mutex-获取锁分析&#34;&gt;Mutex 获取锁分析
&lt;/h2&gt;&lt;h3 id=&#34;1-快速路径尝试获取锁&#34;&gt;1. 快速路径尝试获取锁
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//https://github.com/golang/go/blob/adc9c455873fef97c5759e4811f0d9c8217fe27b/src/runtime/lock_spinbit.go#L160
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;k8&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;key8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;v8&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Xchg8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;k8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v8&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v8&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexSleeping&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Or8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;k8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexSleeping&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;fast 模式跟以前变化不大。如果成功(锁之前未被持有)则快速返回。这是最理想的情况，无竞争时的快速路径。&lt;/p&gt;
&lt;h3 id=&#34;2-自旋等待阶段&#34;&gt;2. 自旋等待阶段
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//https://github.com/golang/go/blob/adc9c455873fef97c5759e4811f0d9c8217fe27b/src/runtime/lock_spinbit.go#L208
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;weSpin&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexSpinning&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Casuintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexSpinning&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexSpinning&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;weSpin&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;weSpin&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atTail&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;mutexPreferLowLatency&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;spin&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;procyield&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexActiveSpinSize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;//主动自旋
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;spin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexPassiveSpinCount&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;osyield&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//被动自旋
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;如果快速路径失败，进入自旋等待阶段。&lt;/li&gt;
&lt;li&gt;通过 &lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/blob/608acff8479640b00c85371d91280b64f5ec9594/src/runtime/lock_spinbit.go#L60&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;mutexSpinning&lt;/a&gt; 标志控制&lt;strong&gt;同时只允许一个 goroutine 自旋&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;自旋分为procyield与osyield，两者的区别是:procyield会持续占有CPU，响应会更快，适合极短时间的等待，osyield会临时释放CPU，响应较慢，但是不会占用较多CPU，适用于较长时间的等待。&lt;br&gt;
这种两阶段自旋设计能够在不同竞争强度下都保持较好的性能表现。&lt;/li&gt;
&lt;li&gt;轻度竞争时主要使用主动自旋，保证低延迟&lt;/li&gt;
&lt;li&gt;重度竞争时快速进入被动自旋，避免CPU资源浪费&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;休眠等待阶段&#34;&gt;休眠等待阶段
&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//https://github.com/golang/go/blob/adc9c455873fef97c5759e4811f0d9c8217fe27b/src/runtime/lock_spinbit.go#L231
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Store the current head of the list of sleeping Ms in our gp.m.mWaitList.next field
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mWaitList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;mutexWaitListHead&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Pack a (partial) pointer to this M with the current lock state bits
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;uintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;^&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexMMask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexMMask&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexSleeping&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;weSpin&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;^&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexSpinning&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Casuintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;weSpin&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;semasleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;atTail&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mWaitList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果自旋失败，&lt;code&gt;goroutine&lt;/code&gt; 将进入休眠等待，然后将当前 M 加入等待队列(通过 mWaitList 链表)，通过信号量(&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/blob/fd050b3c6d0294b6d72adb014ec14b3e6bf4ad60/src/runtime/lock_sema_tristate.go#L106&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;semasleep&lt;/a&gt;)使当前 &lt;code&gt;goroutine&lt;/code&gt; 进入休眠，等待持有锁的 &lt;code&gt;goroutine&lt;/code&gt; 在解锁时唤醒。&lt;/p&gt;
&lt;p&gt;当某个线程解锁互斥锁时，如果发现已经有线程处于 “醒着并旋转” 的状态，就不会唤醒其他线程。在 Go 运行时的背景下，这种设计被称为 &lt;code&gt;spinbit&lt;/code&gt;。&lt;br&gt;
这个设计的核心目的是：&lt;strong&gt;通过让一个线程负责 “旋转尝试获取锁”，避免所有线程都同时竞争资源，从而减少争用和不必要的线程切换&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;效果&#34;&gt;效果
&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;goos: linux
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;goarch: amd64
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;pkg: runtime
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cpu: 13th Gen Intel&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;R&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; Core&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;TM&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; i7-13700H
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                │     old     │                  new                  │
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                │   sec/op    │    sec/op     vs base                 │
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended      3.147µ ± 0%    3.703µ ± 0%   +17.65% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-2    4.511µ ± 2%    5.280µ ± 7%   +17.06% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-3    5.726µ ± 2%   12.125µ ± 2%  +111.75% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-4    6.574µ ± 1%   13.356µ ± 4%  +103.16% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-5    7.706µ ± 1%   13.717µ ± 3%   +78.00% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-6    8.830µ ± 1%   13.674µ ± 2%   +54.85% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-7    11.07µ ± 0%    13.59µ ± 2%   +22.77% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-8    13.99µ ± 1%    14.06µ ± 1%         ~ &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.190 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-9    16.93µ ± 2%    14.04µ ± 3%   -17.04% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-10   20.12µ ± 4%    14.12µ ± 1%   -29.80% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-11   23.96µ ± 2%    14.44µ ± 3%   -39.74% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-12   29.65µ ± 6%    14.61µ ± 3%   -50.74% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-13   33.98µ ± 7%    14.69µ ± 3%   -56.76% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-14   37.90µ ± 1%    14.69µ ± 3%   -61.23% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-15   37.94µ ± 4%    14.89µ ± 5%   -60.75% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-16   39.56µ ± 0%    13.89µ ± 1%   -64.89% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-17   39.56µ ± 0%    14.45µ ± 4%   -63.47% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-18   41.24µ ± 2%    13.95µ ± 3%   -66.17% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-19   42.77µ ± 5%    13.80µ ± 2%   -67.74% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ChanContended-20   44.26µ ± 2%    13.74µ ± 1%   -68.96% &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.000 &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;geomean            17.60µ         12.46µ        -29.22%
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/02/d218f1783388c76053bca81e0d254ffd.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;br&gt;
source &lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/68578#issuecomment-2256792628&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/golang/go/issues/68578#issuecomment-2256792628&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虽然在竞争较少的情况下，性能有降低，但是在竞争比较多的地方性能提升显著。平均来说，大约获得 29%的性能提升。期待后续能够优化这种情况吧。&lt;/p&gt;
&lt;p&gt;mutex本次修改没涉及API层面改动，所以只要等 Go1.24 正式发布就能自动使用了。该特性通过&lt;code&gt;GOEXPERIMENT=spinbitmutex&lt;/code&gt; 来控制，默认是开启的，也可以将它关闭，来使用原来的Mutex。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/go124-mutex%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96%E6%9C%80%E5%A4%A7%E6%8F%90%E5%8D%8770%E7%9A%84%E6%80%A7%E8%83%BD/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;本文长期链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果您觉得我的博客对你有帮助，请通过 &lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/index.xml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RSS&lt;/a&gt;订阅我。&lt;/li&gt;
&lt;li&gt;或者在&lt;a class=&#34;link&#34; href=&#34;https://x.com/@piaopiaopig&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;X&lt;/a&gt;上关注我。&lt;/li&gt;
&lt;li&gt;如果您有&lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Medium&lt;/a&gt;账号，能给我个关注嘛？我的文章第一时间都会发布在Medium。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>go_fix 自动化代码迁移的全新利器</title>
        <link>https://huizhou92.com/zh-cn/p/go_fix-%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BB%A3%E7%A0%81%E8%BF%81%E7%A7%BB%E7%9A%84%E5%85%A8%E6%96%B0%E5%88%A9%E5%99%A8/</link>
        <pubDate>Sat, 08 Feb 2025 15:05:21 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/go_fix-%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BB%A3%E7%A0%81%E8%BF%81%E7%A7%BB%E7%9A%84%E5%85%A8%E6%96%B0%E5%88%A9%E5%99%A8/</guid>
        <description>&lt;img src="https://images.hxzhouh.com/blog-images/2025/02/69886f43f924640d4703312dc480bdca.png" alt="Featured image of post go_fix 自动化代码迁移的全新利器" /&gt;&lt;p&gt;œ&lt;br&gt;
随着项目规模不断扩大，代码库的维护与更新变得越来越繁琐。每当某个函数、常量或包路径需要替换时，手动查找和修改不仅费时费力，还容易出错。幸运的是，Go 语言在不断进步，最新接受的提案 &lt;a class=&#34;link&#34; href=&#34;https://go.dev/issue/32816&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;go:fix&lt;/a&gt;工具为开发者提供了一种自动化迁移的解决方案。本文将带你从浅入深地了解 go:fix 的原理、应用场景以及具体使用示例。&lt;/p&gt;
&lt;h2 id=&#34;一gofix-背景简介&#34;&gt;一、go:fix 背景简介
&lt;/h2&gt;&lt;p&gt;在日常开发过程中，API 的弃用与替换是不可避免的。举例来说，当一个函数被标记为弃用时，我们可能希望所有对该函数的调用都替换为新的实现；当一个常量被重命名或迁移到其他包中时，我们也希望工具能够自动更新所有引用。 &lt;a class=&#34;link&#34; href=&#34;https://go.dev/issue/32816&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;#32816&lt;/a&gt; 提出的这一方案正是为了实现这样的目标——通过在代码中添加特定指令，实现简单弃用项的自动迁移。&lt;/p&gt;
&lt;p&gt;go:fix 工具主要通过两种机制完成自动化迁移：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;函数内联（Inlining）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;常量转发（Forwarding）&lt;/strong&gt;&lt;br&gt;
接下来，我们将详细介绍这两种机制及其使用示例。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;二函数内联与常量转发&#34;&gt;二、函数内联与常量转发
&lt;/h2&gt;&lt;h3 id=&#34;1-函数内联inline-functions&#34;&gt;1. 函数内联（Inline Functions）
&lt;/h3&gt;&lt;p&gt;当一个函数被标记为需要内联时（例如通过 &lt;code&gt;//go:fix inline&lt;/code&gt; 注释），go:fix 会自动将对该函数的调用替换为其函数体内的实现。这种机制常用于两种场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;弃用函数的替换&lt;/strong&gt;：当某个函数不再推荐使用时，可以直接将其内部逻辑迁移到新函数。例如：
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Deprecated: prefer Pow(x, 2).
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//go:fix inline
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Square&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Pow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果代码中存在对 &lt;code&gt;Square&lt;/code&gt; 的调用，工具会自动替换为 &lt;code&gt;Pow(x, 2)&lt;/code&gt;，从而逐步淘汰旧函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;包迁移&lt;/strong&gt;：在包升级或重构过程中，可能需要将原先某个包中的函数调用替换为新包中的实现。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pkg&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pkg2&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;pkg/v2&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//go:fix inline
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;pkg2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这样，调用 &lt;code&gt;pkg.F()&lt;/code&gt; 的代码将自动更新为 &lt;code&gt;pkg2.F(nil)&lt;/code&gt;，简化包路径更新的过程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-常量转发forward-constants&#34;&gt;2. 常量转发（Forward Constants）
&lt;/h3&gt;&lt;p&gt;常量转发机制适用于常量重命名或跨包迁移的场景。只需在常量定义前添加 &lt;code&gt;//go:fix forward&lt;/code&gt; 注释，工具便能将所有对该常量的引用替换为其目标常量。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;example&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//go:fix forward
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Ptr&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果其他地方有如下调用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;example&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;运行 go:fix 工具后，该调用会被替换为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;example&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;此机制不仅支持单个常量，也可以对常量组同时生效。&lt;/p&gt;
&lt;h2 id=&#34;三-gofix-的优势与挑战&#34;&gt;三 go:fix 的优势与挑战
&lt;/h2&gt;&lt;h3 id=&#34;优势&#34;&gt;优势
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;低风险迁移&lt;/strong&gt;：自动替换确保新旧代码行为一致，降低因手动修改引入错误的风险。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高开发效率&lt;/strong&gt;：通过自动化工具处理重复性修改任务，开发者可以将更多精力投入到核心业务逻辑中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性更新&lt;/strong&gt;：确保代码库中所有弃用项都被统一更新，避免遗漏。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无缝集成&lt;/strong&gt;：GoFix 与 gopls（Go 语言服务器协议）等工具紧密集成，提供实时反馈，方便开发者及时发现和修正问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;挑战&#34;&gt;挑战
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;复杂场景处理&lt;/strong&gt;：对于一些特殊情况（例如常量组、iota 的用法）需要特别处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跨包依赖&lt;/strong&gt;：当替换项来自不同包时，可能涉及更多细节问题，需要确保新包的导入和引用正确。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非确定性行为&lt;/strong&gt;：工具在处理 map 遍历等非确定性场景时，需要特别注意替换的一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四结语&#34;&gt;四、结语
&lt;/h2&gt;&lt;p&gt;go:fix 的引入为Go语言的自动化代码迁移带来了新的可能性。通过简单的注释指令（如 &lt;code&gt;//go:fix inline&lt;/code&gt;、&lt;code&gt;//go:fix forward&lt;/code&gt; ），开发者可以轻松实现对弃用函数、常量甚至包路径的自动替换，从而保持代码库的现代性和一致性。无论是大规模重构，还是逐步淘汰旧 API，go:fix 都能为你的项目维护工作提供极大的便利。&lt;/p&gt;
&lt;p&gt;随着工具的不断完善和更多社区反馈的积累，相信未来 go:fix 能够覆盖更多复杂场景，进一步提升 Go 开发的生产力。如果你也在为手动修改代码而烦恼，不妨期待一下这款新工具，体验自动化带来的高效与便捷。&lt;/p&gt;
&lt;h2 id=&#34;五参考资料&#34;&gt;五、参考资料
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/32816&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/golang/go/issues/32816&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/tools/blob/master/gopls/internal/analysis/gofix/doc.go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/golang/tools/blob/master/gopls/internal/analysis/gofix/doc.go&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/go_fix-%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BB%A3%E7%A0%81%E8%BF%81%E7%A7%BB%E7%9A%84%E5%85%A8%E6%96%B0%E5%88%A9%E5%99%A8/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;本文长期链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果您觉得我的博客对你有帮助，请通过 &lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/index.xml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RSS&lt;/a&gt;订阅我。&lt;/li&gt;
&lt;li&gt;或者在&lt;a class=&#34;link&#34; href=&#34;https://x.com/@piaopiaopig&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;X&lt;/a&gt;上关注我。&lt;/li&gt;
&lt;li&gt;如果您有&lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Medium&lt;/a&gt;账号，能给我个关注嘛？我的文章第一时间都会发布在Medium。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>【译】如何通过 Google Spanner 实现万亿级数据存储与5个九的高可用性</title>
        <link>https://huizhou92.com/zh-cn/p/%E8%AF%91%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-google-spanner-%E5%AE%9E%E7%8E%B0%E4%B8%87%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E5%E4%B8%AA%E4%B9%9D%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/</link>
        <pubDate>Thu, 06 Feb 2025 10:01:23 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/%E8%AF%91%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-google-spanner-%E5%AE%9E%E7%8E%B0%E4%B8%87%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E5%E4%B8%AA%E4%B9%9D%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/</guid>
        <description>&lt;p&gt;原始链接 &lt;a class=&#34;link&#34; href=&#34;https://blog.bytebytego.com/p/how-google-spanner-powers-trillions&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.bytebytego.com/p/how-google-spanner-powers-trillions&lt;/a&gt; | 作者 &lt;a class=&#34;link&#34; href=&#34;https://substack.com/@bytebytego399569&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ByteByteGo&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;免责声明：本文中的所有细节均来源于 Google 博客和研究论文，所有技术细节的原始版权均归 Google 工程团队所有。文末附有原始文章的链接。我们对这些细节进行了分析并提供了我们的解读。如果您发现任何不准确或遗漏之处，请留言，我们会尽力修正。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Google Cloud Spanner 是 Google 开发的一款革命性数据库系统，它巧妙地将传统关系型数据库的优势与 NoSQL 系统通常具备的可扩展性相结合。&lt;/p&gt;
&lt;p&gt;专为跨多个区域处理海量工作负载而设计，Cloud Spanner 提供了一个全球分布、强一致性且高可用的数据管理平台。其独特之处在于，它既支持 SQL 查询和关系型数据结构，同时又实现了水平扩展能力，使其能够满足现代高负载应用的需求。&lt;/p&gt;
&lt;!-- more--&gt;
&lt;h2 id=&#34;cloud-spanner-的主要特性&#34;&gt;Cloud Spanner 的主要特性
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;多版本数据库&lt;/strong&gt; 采用同步复制技术，即使在区域故障的情况下也能保证数据的持久性与可用性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TrueTime 技术&lt;/strong&gt; 整合了 GPS 和原子钟，&lt;strong&gt;提供全球一致的时间线&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简化数据管理&lt;/strong&gt; 提供熟悉的 SQL 接口，同时在后台处理分布式数据处理的复杂性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据切分与动态分片&lt;/strong&gt; 将数据按照连续的键范围（称为 splits）进行分区，并根据负载或数据量动态调整分片以优化性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总体而言，Google Spanner 为需要支持全球规模操作，同时保持传统关系型系统的稳健性和可靠性的企业提供了一种极具竞争力的数据库解决方案。&lt;/p&gt;
&lt;p&gt;在本文中，我们将深入探讨 Google Cloud Spanner 的架构，以及它如何支持构成这一出色数据库选项的各项能力。&lt;/p&gt;
&lt;h2 id=&#34;cloud-spanner-架构概述&#34;&gt;Cloud Spanner 架构概述
&lt;/h2&gt;&lt;p&gt;Spanner 的架构旨在支持其作为一个全球分布、强一致性及高可用性数据库的角色。&lt;/p&gt;
&lt;p&gt;在最高层次上，Spanner 被组织为一个被称为 “Universe” 的逻辑实体，该实体跨越多个物理或逻辑位置，这些位置被称为“区域（zones）”。&lt;/p&gt;
&lt;p&gt;每个区域都具有一定的独立性，并包含专用的 &lt;strong&gt;spanservers&lt;/strong&gt;。这些服务器负责数据存储和事务处理，基于 Google 早期分布式存储系统 Bigtable 的概念，并在此基础上进行了增强以支持复杂事务和多版本数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc13e917f-5771-43be-ad01-2b27e24c6707_1600x970.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;架构图&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;关键架构组件&#34;&gt;关键架构组件
&lt;/h2&gt;&lt;p&gt;Cloud Spanner 通过将数据划分成更小的单元来进行管理，这些单元称为 &lt;strong&gt;tablets&lt;/strong&gt;，并分布在多个 spanservers 上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Tablets&lt;/strong&gt;：每个 tablet 存储键值对数据，并附带时间戳用于版本控制。这种结构使得 Spanner 成为一个多版本数据库，能够根据需要访问数据的旧版本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Colossus 文件系统&lt;/strong&gt;：Tablets 存储在 Colossus 上，这是 Google 的分布式文件系统。Colossus 提供了容错性和高性能存储，使得 Spanner 能够实现存储与计算资源的独立扩展。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Splits&lt;/strong&gt;：表中的数据依据连续的键值范围进行划分，这些范围称为 splits。当某个 split 变得过大或流量过高时，系统会自动将其分割成更小的部分并重新分布到不同的 spanservers，这一过程称为动态分片（dynamic sharding）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跨区域复制&lt;/strong&gt;：每个 split 都会在多个区域间进行复制，以实现冗余和故障容错。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了保证数据一致性，Spanner 采用了 &lt;code&gt;Paxos 共识算法&lt;/code&gt;来管理跨区域的复制。每个 split 都有多个副本，Paxos 算法确保这些副本保持一致性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Leader选举&lt;/strong&gt;：在这些副本中，一个副本被选为领导者，负责处理该 split 的所有写事务，确保更新以一致的顺序进行。如果领导者出现故障，Paxos 会自动选举出新的领导者，从而在无需人工干预的情况下保持系统可用性。同时，非领导者副本可以处理读操作，从而减轻领导者的负载并提高扩展性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa0bf8a26-ea4d-4084-a107-2b2cf55786d7_1600x913.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;数据分片与复制&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Spanner 实例通常跨越某一地区内的多个区域，并将副本分布在这些区域中。这样的架构提高了系统的可用性，因为即便某个区域发生故障，其他区域仍能继续处理请求。对于全球部署，还可以将数据复制到不同大陆，以便为全球用户提供低延迟访问。&lt;/p&gt;
&lt;p&gt;所有数据均存储在 Colossus 上，该系统为分布式、复制的文件存储而设计，通过在多台物理机器间复制数据来确保高耐久性，从而在硬件故障时能够恢复数据。文件系统与计算资源分离，使得数据库可以独立扩展并高效运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F42c83ab5-6e93-46d4-8c56-36519687168e_1600x1095.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Colossus 文件系统&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;paxos-共识机制&#34;&gt;Paxos 共识机制
&lt;/h2&gt;&lt;p&gt;Paxos 是 Spanner 架构中的核心组件之一。其基本原理是通过分布式共识，让一组副本（称为 Paxos 组）就一个值（例如某事务的提交或负责更新的领导者）达成一致。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F673e7076-2212-44c0-bae5-503f82bf7318_1600x970.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Paxos 架构图&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;领导者分配机制&#34;&gt;领导者分配机制
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;每个数据 split（即连续键范围）都关联有一个横跨多个区域的 Paxos 组。&lt;/li&gt;
&lt;li&gt;在 Paxos 组中，一个副本被指定为领导者，该领导者负责处理该 split 的所有写操作，从而保证更新协调一致。&lt;/li&gt;
&lt;li&gt;其他副本作为跟随者，不仅帮助分担读操作的负载，还为系统的扩展性做出贡献。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Paxos 领导者的主要职责包括：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;处理写操作&lt;/strong&gt;：领导者接收写请求，并确保这些请求在多数副本确认后才进行提交，从而确保数据的持久性和一致性，即便部分副本出现故障。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;维护顺序&lt;/strong&gt;：通过 TrueTime 为事务分配时间戳，确保写操作按照全局一致的顺序执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;与跟随者通信&lt;/strong&gt;：领导者向跟随者广播提案，并收集确认信息来协调更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即使在分布式系统中不可避免会出现故障，Paxos 机制也能确保 Spanner 在面对这些问题时依旧保持可用性与一致性。若当前领导者因机器或区域故障而失效，Paxos 组将检测到这一情况并选举出新的领导者，从而避免系统停机。&lt;/p&gt;
&lt;h2 id=&#34;事务处理机制&#34;&gt;事务处理机制
&lt;/h2&gt;&lt;p&gt;Cloud Spanner 使用强大而稳健的事务处理方法，确保数据一致性、可靠性和高性能。下面介绍写事务和读事务的工作原理：&lt;/p&gt;
&lt;h3 id=&#34;写事务&#34;&gt;写事务
&lt;/h3&gt;&lt;p&gt;写事务确保了原子性（全有或全无）和一致性（所有副本数据一致），由 Paxos 领导者协调处理，即便在出现故障时也能保证数据完整性。其基本步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;加锁&lt;/strong&gt;：在修改数据之前，负责该 split 的 Paxos 领导者会对相关行加写锁。如果另一事务已持有冲突锁，则当前事务需等待锁释放。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通过 TrueTime 分配时间戳&lt;/strong&gt;：利用 TrueTime 为事务分配全局一致的时间戳，该时间戳总是大于之前任何已提交事务的时间戳，从而保证时间顺序的一致性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多数副本复制保证持久性&lt;/strong&gt;：领导者在加锁并分配时间戳后，会将事务细节发送给 Paxos 组中超过半数的副本。只有在多数副本确认后，事务才被认为已提交，确保即便部分副本故障，数据也能得到持久保存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提交等待&lt;/strong&gt;：领导者会等待一个短暂的时段，确保提交时间戳对所有副本均已生效，然后再最终提交事务，使得后续所有读取操作都能反映该变更。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于单个 split 内的写操作，例如用户希望在表中添加一个 ID 为 7、值为 “Seven” 的行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spanner API 会确定 ID 7 所在的 split，并将请求发送至该 split 的 Paxos 领导者。&lt;/li&gt;
&lt;li&gt;领导者对 ID 7 加锁、分配时间戳，并将变更复制给多数副本。&lt;/li&gt;
&lt;li&gt;在确保时间戳生效后，事务提交，所有副本应用该变更。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而对于涉及多个 split 的写操作（例如修改多个 split 中的 ID 2000、3000 和 4000），Spanner 则采用两阶段提交协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个参与的 split 都成为事务的参与者，其中一个 split 的领导者担当协调者角色。&lt;/li&gt;
&lt;li&gt;协调者确保所有参与者都已加锁并同意提交事务，然后再进行下一步操作。&lt;/li&gt;
&lt;li&gt;在所有参与者确认后，协调者提交事务，并通知其他参与者应用变更。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;读事务&#34;&gt;读事务
&lt;/h3&gt;&lt;p&gt;读事务经过优化，可在高负载下提供高性能的强一致性读取，同时无需加锁。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;强一致性读取&lt;/strong&gt;：这类读取始终返回最新的已提交数据。系统通过 TrueTime 检查数据最新的时间戳，确保返回的数据是最新状态。例如，当客户端请求读取 ID 为 1000 的行时，系统会路由该请求至某个副本，并在返回结果前与领导者确认数据的最新性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;陈旧读取&lt;/strong&gt;：允许在一定程度上返回稍微过时的数据（例如最多延迟 10 秒），以换取更低的延迟。客户端在请求时，可以直接从副本读取数据，而无需等待领导者确认，从而加速响应。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面的图示展示了强一致性读取的场景：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff7819b45-937e-4e3f-9e23-ab2cfb52ce75_1600x923.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;强一致性读取&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;而下图则展示了陈旧读取的场景：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5909c950-6524-4088-9519-5719b4d7a528_1600x923.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;陈旧读取&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;为了避免死锁——即多个事务相互等待释放锁的情况——Spanner 采用了 &lt;strong&gt;wound-wait 算法&lt;/strong&gt;。其基本规则如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果一个较晚启动的（年轻的）事务请求被较早启动（较老）的事务所持有的锁，则该年轻事务等待。&lt;/li&gt;
&lt;li&gt;如果较老事务请求较年轻事务所持有的锁，则较年轻事务会被 “wound” （即中止），以便较老事务继续执行。&lt;/li&gt;
&lt;li&gt;这种策略确保事务始终能够推进，避免形成死锁循环。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Spanner 的设计确保了数据即使在故障情况下也能保持一致性和可用性。所有写操作的数据均存储于 Google 的 Colossus 分布式文件系统中，该系统通过将数据复制到多台物理机器上，即使部分机器或区域出现故障，也能从其他副本中恢复数据。TrueTime 则确保了在分布式环境中事务的全局一致排序，保证一旦某事务对一个客户端可见，则对所有客户端均可见。&lt;/p&gt;
&lt;h2 id=&#34;truetime-技术&#34;&gt;TrueTime 技术
&lt;/h2&gt;&lt;p&gt;TrueTime 是 Cloud Spanner 的一项关键创新，使其能够作为一个全球分布、强一致性的数据库运行。TrueTime 解决了分布式系统中最具挑战性的问题之一：如何在分布于多个区域和数据中心的节点间提供全球同步和一致的时间视图。&lt;/p&gt;
&lt;p&gt;TrueTime 基于原子钟和 GPS 时钟的组合工作，二者协同提供高度准确和可靠的时间同步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原子钟&lt;/strong&gt;：基于原子振动频率计时，提供极高精度、漂移极小的时间测量。在 GPS 信号中断或不准确时，原子钟能保证时间的准确性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GPS 时钟&lt;/strong&gt;：依靠卫星信号提供准确的全球同步时间。但 GPS 系统可能会遇到干扰、天线故障，甚至伪造攻击的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TrueTime 不将时间表示为单一的点，而是表示为一个时间区间，明确体现了分布式系统中固有的不确定性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;TTInterval&lt;/strong&gt;：TrueTime 提供一个时间范围 [earliest, latest]，保证实际的全球时间落在此区间内。区间宽度由时钟漂移和网络延迟等因素决定。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;误差范围与同步&lt;/strong&gt;：通过大约每 30 秒与时间主机（原子钟和 GPS 时钟）同步一次，系统可将不确定性区间保持在一个较小的范围内（通常在 10 毫秒以内）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TrueTime 具有以下重要特性，使其在分布式数据库中发挥关键作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全局外部一致性&lt;/strong&gt;：确保所有副本中事务以相同的全局顺序进行序列化。例如，如果某事务提交早于另一事务开始，TrueTime 能保证时间戳反映这种全局顺序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无锁读取事务&lt;/strong&gt;：允许 Spanner 执行无锁的只读请求，这些事务可以在不加锁的情况下访问数据的一致快照，从而提升系统扩展性和性能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原子模式更新&lt;/strong&gt;：在分布式系统中，模式更改（如修改表结构）通常十分复杂。TrueTime 将模式更新视为具有特定时间戳的事务，确保所有服务器一致地应用更改。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;历史数据读取&lt;/strong&gt;：TrueTime 允许基于指定时间戳读取数据的一致快照，方便进行审计或调试。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结
&lt;/h2&gt;&lt;p&gt;Google Spanner 在数据库工程领域是一项重大突破，它完美地将传统关系型数据库的可靠性和结构性与 NoSQL 系统的可扩展性和全球可用性相结合。通过创新的架构设计，依靠 Paxos 共识机制以及 TrueTime 技术，Spanner 能够高效地处理分布式事务、保证外部一致性，并在全球范围内保持高性能运行。&lt;/p&gt;
&lt;p&gt;Google Spanner 正在重新定义分布式数据库系统的可能性，为可扩展性、可靠性和创新设定了新的标准。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://static.googleusercontent.com/media/research.google.com/en//archive/spanner-osdi2012.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Spanner: Google’s Globally-Distributed Database&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://cloud.google.com/spanner/docs/whitepapers/life-of-reads-and-writes&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Life of Spanner Reads and Writes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://cloud.google.com/blog/topics/developers-practitioners/what-cloud-spanner&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;What is Cloud Spanner?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/%E8%AF%91%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-google-spanner-%E5%AE%9E%E7%8E%B0%E4%B8%87%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E5%E4%B8%AA%E4%B9%9D%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Long Time Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;If you find my blog helpful, please subscribe to me via &lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/index.xml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RSS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Or follow me on &lt;a class=&#34;link&#34; href=&#34;https://x.com/@piaopiaopig&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;X&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;If you have a &lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Medium&lt;/a&gt; account, follow me there. My articles will be published there as soon as possible.&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>DeepSeek：AI 竞赛中的黑天鹅</title>
        <link>https://huizhou92.com/zh-cn/p/deepseekai-%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E9%BB%91%E5%A4%A9%E9%B9%85zh-cn/</link>
        <pubDate>Tue, 04 Feb 2025 18:22:30 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/deepseekai-%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E9%BB%91%E5%A4%A9%E9%B9%85zh-cn/</guid>
        <description>&lt;img src="https://images.hxzhouh.com/blog-images/2025/02/2a985170a85b4e9ac863fdbcfc54deb2.png" alt="Featured image of post DeepSeek：AI 竞赛中的黑天鹅" /&gt;&lt;blockquote&gt;
&lt;p&gt;本文是最近一次关于DeepSeek在线讨论的总结，感兴趣的读者可以可以观看在线会议。&lt;br&gt;
录像录制文件：https://meeting.tencent.com/crm/Nxg95wna26  密码：2PBC&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近，DeepSeek 在 AI 领域引发了广泛讨论。作为一个 AI 模型，其性能表现让整个行业为之一震，甚至被称为“AI 领域的拼多多”。这次技术突破不仅挑战了英伟达和 OpenAI 等巨头的传统叙事，也让全球 AI 产业重新评估开源模型的竞争力。&lt;/p&gt;
&lt;p&gt;在这篇文章中，我们将深入探讨 DeepSeek 的核心技术、其带来的产业冲击，以及未来 AI 发展可能的路径。&lt;/p&gt;
&lt;!-- more--&gt;
&lt;h2 id=&#34;一推理效率的革命从硬件优化到算法创新&#34;&gt;一、推理效率的革命：从硬件优化到算法创新
&lt;/h2&gt;&lt;p&gt;近期AI领域最引人注目的进展之一，是推理效率的显著提升。通过&lt;strong&gt;KV缓存压缩&lt;/strong&gt;、&lt;strong&gt;低精度计算（FP8)&lt;/strong&gt; 等技术，模型的推理成本被压缩至传统方法的十分之一以下。这一突破并非依赖算力的简单堆砌，而是通过算法与硬件的协同设计实现。例如，动态剪裁冗余的中间状态生成、基于规则验证的奖励机制（Verifiable Reward），使得模型在长上下文推理中减少重复探索，显著提升有效token利用率。实验表明，优化后的模型在相同硬件条件下，推理速度可提升6-7倍，且错误率未出现显著波动。&lt;/p&gt;
&lt;p&gt;这一趋势对行业产生深远影响：&lt;strong&gt;边缘设备部署&lt;/strong&gt;成为可能（如手机端运行复杂COT任务），同时倒逼闭源模型重新评估其商业逻辑——当开源模型以&lt;strong&gt;1/10&lt;/strong&gt; 的成本实现&lt;strong&gt;95%&lt;/strong&gt; 性能时，&amp;ldquo;算力霸权&amp;quot;叙事面临挑战。&lt;/p&gt;
&lt;h2 id=&#34;二蒸馏技术的双刃剑捷径还是天花板&#34;&gt;二、蒸馏技术的双刃剑：捷径还是天花板？
&lt;/h2&gt;&lt;p&gt;蒸馏（Distillation）作为追赶闭源模型的核心手段，其本质是通过模仿教师模型的输出分布快速提升小模型性能。然而会议揭示了两大隐患：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;多样性丧失&lt;/strong&gt;：过度依赖蒸馏会导致模型陷入&amp;quot;参考答案陷阱&amp;rdquo;，放弃独立探索能力。例如在数学推理中，模型可能通过记忆高频解题路径而非真正理解逻辑来&amp;quot;欺骗&amp;quot;评测指标；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;能力天花板&lt;/strong&gt;：蒸馏数据的质量直接受限于教师模型的能力边界。当闭源模型转向新一代架构（如非Transformer设计）时，蒸馏路径可能因底层能力不匹配而失效。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有趣的是，部分团队通过&lt;strong&gt;混合训练策略&lt;/strong&gt;找到了平衡点：使用蒸馏数据冷启动模型，再通过强化学习（RL）注入自主探索能力。这种&amp;quot;先模仿后创新&amp;quot;的路径，或将成为追赶者的标准范式。&lt;/p&gt;
&lt;h2 id=&#34;三开源vs闭源生态博弈的新平衡&#34;&gt;三、开源VS闭源：生态博弈的新平衡
&lt;/h2&gt;&lt;p&gt;开源模型的爆发（如DeepSeek-R1）正在重构行业格局。其核心价值不仅在于技术透明性，更在于&lt;strong&gt;开发范式的根本转变&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;场景定制化&lt;/strong&gt;：开发者可通过微调小模型（如7B参数级别）在垂直领域达到商用级表现，而无需依赖闭源API的通用能力；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;硬件去中心化&lt;/strong&gt;：配合AMD MI300等异构计算架构，开源模型在非英伟达生态中展现出惊人适配性，打破算力垄断的潜在威胁；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;安全可控性&lt;/strong&gt;：闭源模型因数据隐私和监管风险，在金融、医疗等敏感领域的落地受阻，而开源方案提供了自主可控的替代路径。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但闭源阵营并非被动：OpenAI等头部玩家正通过&lt;strong&gt;超级算力押注（如500B StarGate项目)&lt;/strong&gt;,探索下一代架构，试图在智能边界上拉开代际差距。这场竞赛的本质，是&amp;quot;工程优化红利&amp;quot;与&amp;quot;原始创新风险&amp;quot;的博弈。&lt;/p&gt;
&lt;h2 id=&#34;四算力需求的再思考短期扰动与长期确定性&#34;&gt;四、算力需求的再思考：短期扰动与长期确定性
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;尽管高效模型降低了单次训练成本，但行业对算力的渴求并未减弱，而是呈现结构性分化：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;探索者&lt;/strong&gt;：仍需投入天量算力验证新架构（如非Transformer模型）、多模态融合等高风险方向，单次实验成本可达千万美元级；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;追赶者&lt;/strong&gt;：通过算法改进（如MoE动态路由、数据筛选流水线）将同等性能的模型训练成本压缩80%，但需持续投入以应对闭源模型的代际跃迁；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用层&lt;/strong&gt;：推理算力需求呈指数增长，尤其是在实时Agent、多模态交互场景中，模型需在百毫秒内完成复杂决策链。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Meta等公司的资本开支指引（2025年同比增长60%）印证了这一点：算力投入正从&amp;quot;军备竞赛&amp;quot;转向&amp;quot;精准打击&amp;quot;，更强调单位算力的智能产出效率。&lt;/p&gt;
&lt;h2 id=&#34;五中国团队的启示小米加步枪的破局之道&#34;&gt;五、中国团队的启示：小米加步枪的破局之道
&lt;/h2&gt;&lt;p&gt;中国AI团队的技术突破揭示了一条独特路径——&lt;strong&gt;在算力约束下极致优化工程能力&lt;/strong&gt;。典型案例包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据效率革命&lt;/strong&gt;：通过奖励验证机制（如数学问题可自动评判），将强化学习的数据需求量降低90%；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;训练流水线创新&lt;/strong&gt;：采用&amp;quot;预训练-蒸馏-强化学习&amp;quot;三阶段Pipeline，在2000张GPU集群上实现对标万卡规模的效果；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;硬件异构适配&lt;/strong&gt;：与国产芯片厂商深度合作，探索FPGA、ASIC等定制化方案替代通用GPU。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种&amp;quot;压强式创新&amp;quot;虽难以突破绝对技术边界，却在应用落地上构建了独特优势。当行业进入&amp;quot;拼落地&amp;quot;阶段时，这种能力可能比单纯的技术领先更具杀伤力。&lt;/p&gt;
&lt;h2 id=&#34;六未来展望智能进化的下一站&#34;&gt;六、未来展望：智能进化的下一站
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;推理与训练的边界消融&lt;/strong&gt;：AlphaGo式的蒙特卡洛树搜索（MCTS）可能被引入语言模型，实现&amp;quot;动态思考-验证-迭代&amp;quot;的闭环推理；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;过程奖励的突破&lt;/strong&gt;：当前结果导向的奖励机制将被过程质量评估取代，如同围棋中对每一步棋的胜率预测；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多模态的本质价值&lt;/strong&gt;：视觉-语言联合训练并非为了生成炫酷的图片，而是通过空间推理能力提升抽象问题解决水平（如几何证明）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;DeepSeek 的成功并非偶然，它代表了一种 AI 发展路线的变革，即更高效、低成本的 AI 训练方法。这场技术革命的核心矛盾，始终是&lt;strong&gt;探索者与追赶者的共生关系&lt;/strong&gt;。 尽管短期内它无法彻底改变 AI 产业的格局，但其所引发的行业讨论，可能会对未来 AI 发展方向产生深远影响。&lt;strong&gt;开源 VS 闭源&lt;/strong&gt;、&lt;strong&gt;高效优化 VS 极端算力&lt;/strong&gt;派，这些问题将在未来几年持续主导 AI 产业的发展。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/deepseekai-%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E9%BB%91%E5%A4%A9%E9%B9%85zh-cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;本文长期链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果您觉得我的博客对你有帮助，请通过 &lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/index.xml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RSS&lt;/a&gt;订阅我。&lt;/li&gt;
&lt;li&gt;或者在&lt;a class=&#34;link&#34; href=&#34;https://x.com/@piaopiaopig&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;X&lt;/a&gt;上关注我。&lt;/li&gt;
&lt;li&gt;如果您有&lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Medium&lt;/a&gt;账号，能给我个关注嘛？我的文章第一时间都会发布在Medium。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
