<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>huizhou92&#39;s Blog</title>
        <link>https://huizhou92.com/zh-cn/</link>
        <description>Recent content on huizhou92&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>Copyright © 2023 huizhou92</copyright>
        <lastBuildDate>Thu, 13 Nov 2025 16:58:54 +0800</lastBuildDate><atom:link href="https://huizhou92.com/zh-cn/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Go 1.26 黑科技：跳过 GC 直接释放内存，性能飙升 200%</title>
        <link>https://huizhou92.com/zh-cn/p/go-1.26-%E9%BB%91%E7%A7%91%E6%8A%80%E8%B7%B3%E8%BF%87-gc-%E7%9B%B4%E6%8E%A5%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E6%80%A7%E8%83%BD%E9%A3%99%E5%8D%87-200/</link>
        <pubDate>Thu, 13 Nov 2025 16:58:54 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/go-1.26-%E9%BB%91%E7%A7%91%E6%8A%80%E8%B7%B3%E8%BF%87-gc-%E7%9B%B4%E6%8E%A5%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E6%80%A7%E8%83%BD%E9%A3%99%E5%8D%87-200/</guid>
        <description>&lt;!-- more--&gt;
&lt;p&gt;最近，Go 语言社区围绕一个全新的内存管理提案展开了激烈讨论：&lt;strong&gt;在不依赖垃圾回收 (GC) 的情况下直接释放并重用内存&lt;/strong&gt;。&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/74299&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;#74299&lt;/a&gt; 引入了 &lt;code&gt;runtime.free&lt;/code&gt; 及相关机制，试图让编译器和标准库在特定场景下安全地跳过 GC，对短命的内存对象进行即时回收利用&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/74299#:~:text=Note%20that%20runtime,called%20directly%20by%20end%20users&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;github.com&lt;/a&gt;&lt;a class=&#34;link&#34; href=&#34;https://go.googlesource.com/proposal/&amp;#43;/refs/changes/55/700255/14/design/74299-runtime-free.md#:~:text=1,Challenges%20here%20include&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;go.googlesource.com&lt;/a&gt;。此举被认为可能为 Go 带来一次&lt;strong&gt;性能上的革命&lt;/strong&gt;：初步原型显示，在 &lt;code&gt;strings.Builder&lt;/code&gt; 这样的场景中，利用该机制&lt;strong&gt;性能提升可达 2 倍&lt;/strong&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/74299#:~:text=%28In%20short%2C%20currently%20,more%20allocations%20per%20benchmark%20loop&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;github.com&lt;/a&gt;。本文将回顾 Go 内存管理领域从 &lt;em&gt;arena&lt;/em&gt; 实验到 &lt;em&gt;memory region&lt;/em&gt; 构想，再到 &lt;em&gt;runtime.free&lt;/em&gt; 提案的探索之旅，并剖析这一新提案的技术细节、产生的意义、演化过程，以及对普通开发者的影响。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;runtime.free 将在 Golang1.26 中 以 GOEXPERIMENT 的方式提供实验性支持。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;背景一场关于手动内存管理的漫长探索&#34;&gt;背景：一场关于“手动”内存管理的漫长探索
&lt;/h2&gt;&lt;p&gt;自 Go 语言诞生以来，自动垃圾回收（GC）就是其核心特性之一。然而在&lt;strong&gt;对性能极度敏感&lt;/strong&gt;的场景（如高吞吐的服务端程序）中，GC 带来的开销始终让开发者有所顾虑。为了进一步降低 GC 负担，Go 团队近年开始了一系列关于“手动”或“半自动”内存管理的探索尝试。&lt;/p&gt;
&lt;h3 id=&#34;arena-实验--强大却难以融合&#34;&gt;Arena 实验 —— 强大却难以融合
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Arena&lt;/strong&gt; 实验&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/51317&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;#51317&lt;/a&gt;是 Go 团队在 2022 年迈出的大胆一步。它引入了一个新的 &lt;code&gt;arena&lt;/code&gt; 包和 &lt;code&gt;Arena&lt;/code&gt; 类型，允许开发者将一组生命周期相同的对象分配到一个独立的内存区域中，并在不需要时&lt;strong&gt;一次性释放整个区域&lt;/strong&gt; 这一做法类似其他语言的 &lt;em&gt;region-based memory management&lt;/em&gt; 思想：大量对象集中分配、集中释放，从而降低常规分配/回收的成本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Arena 的优点&lt;/strong&gt;在某些场景下非常显著：所有对象统一释放，大幅减少了 GC 扫描和回收的工作量，谷歌内部测试显示对大型应用最高可节省约15%的 CPU 和内存开销。但是，Arena 随即暴露出严重的问题——&lt;strong&gt;API 侵入性&lt;/strong&gt;太强。为了使用 Arena，几乎每个相关函数都不得不增加一个 &lt;code&gt;arena.Arena&lt;/code&gt; 参数，这导致这种用法具有“&lt;strong&gt;病毒式&lt;/strong&gt;”传播效应，破坏了 Go 一贯强调的简洁与可组合性。另外，Arena 在与 Go 现有特性（如隐式接口、逃逸分析）配合时也出现了诸多不兼容之处。最终，由于 API 难以融入生态，Go 官方在 2023 年初宣布 &lt;strong&gt;无限期搁置 Arena 提案&lt;/strong&gt;，并明确表示 &lt;code&gt;GOEXPERIMENT=arena&lt;/code&gt; 仅供实验、不建议在生产中使用。&lt;/p&gt;
&lt;h3 id=&#34;memory-region-构想--优雅但实现复杂&#34;&gt;Memory Region 构想 —— 优雅但实现复杂
&lt;/h3&gt;&lt;p&gt;吸取了 Arena 的教训，Go 团队接着提出了更贴合 Go 哲学的概念：&lt;strong&gt;内存区域（Memory Region&lt;/strong&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/70257&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;#70257&lt;/a&gt;）它设想引入一种更&lt;strong&gt;透明&lt;/strong&gt;的机制——例如通过一个 &lt;code&gt;region.Do(func(){ ... })&lt;/code&gt; 调用，将某段函数作用域内的所有内存分配&lt;strong&gt;隐式绑定&lt;/strong&gt;到一个临时区域。当这段代码执行完毕时，该区域内分配的所有对象都可以一并释放。&lt;/p&gt;
&lt;p&gt;Memory Region 的&lt;strong&gt;优点&lt;/strong&gt;在于：对开发者而言几乎是透明的，无需修改函数签名或显式传递 Arena 对象。另外，通过运行时的巧妙设计，它依然能保持&lt;strong&gt;内存安全&lt;/strong&gt;。具体来说，如果区域中的某个对象被外部保留（“逃逸”出了区域作用域），运行时会&lt;strong&gt;自动将该对象挪回全局堆&lt;/strong&gt;由 GC 管理，从而避免类似 Arena 那样可能出现的 use-after-free 错误。这一设计既有手动内存管理的性能，又尽可能避免了手动管理常见的安全隐患。&lt;/p&gt;
&lt;p&gt;然而，Memory Region 的&lt;strong&gt;问题在于实现极其复杂&lt;/strong&gt;。要支持这种“区域化”的内存管理，需要对运行时和 GC 做重大改造。例如，开启区域时可能需要一个特殊的低开销写屏障来追踪对象逃逸情况，这增加了垃圾回收机制的复杂性和运行成本。虽然理论上可行，但要让这一方案高效稳健地落地，无疑是一项长期且充满不确定性的研究课题。迄今为止，Memory Region 仍停留在讨论和原型阶段，没有迅速融入 Go 主线。&lt;/p&gt;
&lt;h3 id=&#34;最终的焦点runtimefree&#34;&gt;最终的焦点：runtime.free
&lt;/h3&gt;&lt;p&gt;在 Arena 的侵入性和 Memory Region 的复杂性之间，Go 团队终于找到了一条&lt;strong&gt;更务实、工程上可行的中间路线&lt;/strong&gt;——这就是本次的 &lt;strong&gt;runtime.free 提案&lt;/strong&gt;。相比之前“大包大揽”的方案，&lt;code&gt;runtime.free&lt;/code&gt; 走的是&lt;strong&gt;精细化局部优化&lt;/strong&gt;的路子：与其让开发者手动管理整片内存，不如让更了解代码细节的&lt;strong&gt;编译器&lt;/strong&gt;和&lt;strong&gt;底层标准库&lt;/strong&gt;来决定何时安全地释放特定的堆内存。换言之，runtime.free 旨在像一把手术刀，&lt;strong&gt;精准切除&lt;/strong&gt;那些生命周期短暂且已确定不再使用的内存块，减少 GC 不必要的工作。&lt;/p&gt;
&lt;p&gt;这种方法极大地缓解了 Arena 的可组合性难题（因为开发者不需要改动代码、一切由编译器和运行时自动处理），也避开了 Memory Region 那种对 GC 全局机制的大改动。更重要的是，它为解决 Go 长期存在的性能**“鸡与蛋”困局&lt;strong&gt;提供了新的思路：许多优化（例如更激进的逃逸分析）过去之所以收效甚微，是因为即便消除了某个原因，内存对象仍可能由于&lt;/strong&gt;另一原因&lt;a class=&#34;link&#34; href=&#34;https://go.googlesource.com/proposal/&amp;#43;/refs/changes/55/700255/14/design/74299-runtime-free.md#:~:text=For%20example%2C%20,to%20eliminate%20the%20first%20reason&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;**逃逸到堆上，最终并未减少 GC 负担&lt;/a&gt;。而 runtime.free 的出现，相当于提供了一把钥匙，可以&lt;strong&gt;打破这种循环&lt;/strong&gt;——一旦对象在运行时被判定“确实不再需要”，就立即释放，从而&lt;a class=&#34;link&#34; href=&#34;https://go.googlesource.com/proposal/&amp;#43;/refs/changes/55/700255/14/design/74299-runtime-free.md#:~:text=In%20other%20words%2C%20a%20runtime,valuable%2C%20including%20in%20escape%20analysis&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;真正实现减少 GC 压力的初衷&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;runtimefree-的实现机制编译器自动化--标准库配合&#34;&gt;runtime.free 的实现机制：编译器自动化 + 标准库配合
&lt;/h2&gt;&lt;p&gt;需要强调的是，runtime.free &lt;strong&gt;并不&lt;/strong&gt;打算提供给普通开发者一个手工调用 &lt;code&gt;free&lt;/code&gt; 的新玩具。相反，它采取高度受控的“双管齐下”策略，通过&lt;strong&gt;编译器&lt;/strong&gt;和&lt;strong&gt;标准库&lt;/strong&gt;的改进来实现内存释放优化，同时不向 Go 程序员暴露额外的复杂度。&lt;/p&gt;
&lt;h3 id=&#34;编译器自动释放-runtimefreetracked&#34;&gt;编译器自动释放 (runtime.freetracked)
&lt;/h3&gt;&lt;p&gt;首先，也是整个提案最令人兴奋的部分：&lt;strong&gt;编译器将自动插入内存释放逻辑&lt;/strong&gt;。具体而言，当编译器检测到某些场景下分配的内存可以安全提前回收时，就会在编译阶段悄悄地产生额外的代码来跟踪并释放这些内存：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;识别阶段：&lt;/strong&gt; 对于典型的 &lt;code&gt;make([]T, size)&lt;/code&gt; 切片分配，如果编译器发现该切片虽然因为长度或容量未知而必须逃逸到堆上，但它的使用范围不超过当前函数（例如不会被保存到全局或返回给调用者），那么编译器将把这次分配标记为&lt;a class=&#34;link&#34; href=&#34;https://go.googlesource.com/proposal/&amp;#43;/refs/changes/55/700255/14/design/74299-runtime-free.md#:~:text=2,in%20a%20loop&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;“&lt;strong&gt;可跟踪释放&lt;/strong&gt;”&lt;/a&gt;。这种情况下，会调用一个特殊的分配函数（如 &lt;code&gt;makeslicetracked64&lt;/code&gt;）来分配对象，并将该对象的指针记录到当前函数栈上的一个&lt;a class=&#34;link&#34; href=&#34;https://go.googlesource.com/proposal/&amp;#43;/refs/changes/55/700255/14/design/74299-runtime-free.md#:~:text=The%20second%20API%20,as%20a%20scope%20is%20exited&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;strong&gt;追踪列表&lt;/strong&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;跟踪阶段：&lt;/strong&gt; 编译器在栈上维护一个 &lt;code&gt;freeables&lt;/code&gt; 数组（或切片），收集所有被标记为可释放的堆对象。当有新的可释放对象分配时，其指针会被追加到这个列表中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;释放阶段：&lt;/strong&gt; 在函数返回前，编译器会自动插入一行类似 &lt;code&gt;defer runtime.freeTracked(&amp;amp;freeables)&lt;/code&gt; 的调用&lt;a class=&#34;link&#34; href=&#34;https://tonybai.com/2025/09/18/go-runtime-free-proposal/#:~:text=1.%20%E8%AF%86%E5%88%AB%EF%BC%9A%E5%BD%93%E7%BC%96%E8%AF%91%E5%99%A8%E9%81%87%E5%88%B0%E4%B8%80%E4%B8%AA%20make%28,%E8%87%AA%E5%8A%A8%E9%87%8D%E5%86%99%20%E4%B8%BA%E4%B8%8D%E4%BA%A7%E7%94%9F%20GC%20%E5%8E%8B%E5%8A%9B%E7%9A%84%E7%89%88%E6%9C%AC%EF%BC%8C%E8%80%8C%E5%BC%80%E5%8F%91%E8%80%85%E5%AF%B9%E6%AD%A4%20%E5%AE%8C%E5%85%A8%E6%97%A0%E6%84%9F%E3%80%82&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;tonybai.com&lt;/a&gt;。这样，当函数退出时，这个延迟调用将执行，通知运行时回收 &lt;code&gt;freeables&lt;/code&gt; 列表中记录的所有堆对象。这种做法确保了在&lt;strong&gt;作用域结束&lt;/strong&gt;时，临时分配的对象立即被释放，而无需等待下一轮 GC。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/11/2b6c0d576255984f33c9aa53a40d8187.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;未命名&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;对于开发者来说，这一切都是&lt;strong&gt;透明&lt;/strong&gt;的：你完全可以像往常一样编写代码，而编译器在背后已经将其“悄悄优化”为一个更少堆分配、更少 GC 压力的版本。举个简单例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 开发者原始代码&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;buf&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;byte&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 可能逃逸到堆上&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// ... 使用 buf&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 编译器优化后的等效代码（概念示意）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;freeables&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;buf&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;runtime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;makeslicetracked64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freeables&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 分配受跟踪的 slice&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// ... 使用 buf&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;runtime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;freeTracked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freeables&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 函数退出时释放 buf 对应的内存&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;经过这种改写，原本可能需要 GC 扫描回收的 &lt;code&gt;buf&lt;/code&gt; 内存，将在函数结束时&lt;strong&gt;立即归还&lt;/strong&gt;给运行时可用的内存池。因此，未来我们编写的一些看似会产生大量堆分配的代码，有望在&lt;strong&gt;不改变任何源码&lt;/strong&gt;的情况下，由编译器替我们转换成“零 GC 压力”的高效版本——开发者对此&lt;strong&gt;毫无感知&lt;/strong&gt;，但程序性能却因此获益。&lt;/p&gt;
&lt;h3 id=&#34;标准库协助释放-runtimefreesized&#34;&gt;标准库协助释放 (runtime.freesized)
&lt;/h3&gt;&lt;p&gt;另一方面，对于 Go &lt;strong&gt;标准库中少数性能关键的组件&lt;/strong&gt;，开发团队也在尝试手动加入 &lt;code&gt;runtime.free&lt;/code&gt; 的调用。这并不是要把手动内存管理强加给所有库，而是利用标准库对自身情况的了解，在&lt;strong&gt;极有限&lt;/strong&gt;的热点场景显式地释放内存，以追求极致性能。提案中提到的主要目标包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;strings.Builder&lt;/code&gt; / &lt;code&gt;bytes.Buffer&lt;/code&gt;&lt;/strong&gt; 的扩容：当内部缓冲区需要增长时，旧的缓冲区实际上已经不再使用，完全可以当场释放，避免占用堆并减轻后续 GC 压力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;map&lt;/code&gt; 的扩容&lt;/strong&gt;：Go 的 map 在扩容和重新哈希（rehash）时会分配新的底层数组，此时旧的 buckets 数组事实上已死，同样可以立即回收。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;slices.Collect&lt;/code&gt; 等&lt;/strong&gt;切片收集/拼接的操作：在构造最终结果过程中产生的大量中间切片，仅用于过渡，也可以及时释放。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于这些场景，runtime.free 提供了一个内部运行时函数 &lt;code&gt;runtime.freeSized(ptr, size, noscan)&lt;/code&gt;（提案原型中使用的是 &lt;code&gt;freesized&lt;/code&gt;），允许在知道一个对象指针 &lt;code&gt;ptr&lt;/code&gt; 及其大小后，立刻释放对应内存。这种调用仅限于&lt;strong&gt;非常底层&lt;/strong&gt;且对内存使用有精确认知的代码。例如 Go 作者们在实验中修改了 &lt;code&gt;strings.Builder&lt;/code&gt; 的代码，在扩容逻辑中加入对旧缓冲区的 &lt;code&gt;runtime.freeSized&lt;/code&gt; 调用。结果表明：&lt;strong&gt;对于执行多次扩容的场景，新版 &lt;code&gt;strings.Builder&lt;/code&gt; 性能提升了约 45%～55%&lt;/strong&gt;，几乎&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/74299#:~:text=BuildString_Builder%2F10Write_36Bytes_NoGrow,55.71%25%20%28p%3D0.000%20n%3D20&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;strong&gt;快了一倍&lt;/strong&gt;&lt;/a&gt;！换句话说，通过在正确的时机手动释放内存，可以实打实地换来巨大性能收益。&lt;/p&gt;
&lt;p&gt;需要注意的是，这种手动调用只会出现在&lt;strong&gt;少数标准库&lt;/strong&gt;内部。Go 团队并不打算在诸如 &lt;code&gt;net/http&lt;/code&gt; 这样的高级库里遍地插入 &lt;code&gt;runtime.free&lt;/code&gt; —— 毕竟那样又回到了“到处手动管理内存”的老路上。这一步更多是为了验证：&lt;strong&gt;在哪些特殊场景下，提前释放内存能够带来明显收益&lt;/strong&gt;。如果证明效果显著，我们也许会在未来看到这些改进融入正式版本中；如果收益不大或风险高，也可以根据讨论再决定是否采纳。&lt;/p&gt;
&lt;h2 id=&#34;性能影响与收益&#34;&gt;性能影响与收益
&lt;/h2&gt;&lt;p&gt;让 GC “少管一些事”听起来很美好，但也要评估此举本身的性能代价。插入额外的跟踪和释放逻辑，会不会拖慢常规代码的速度？根据目前的原型测试结果，答案是&lt;strong&gt;几乎可以忽略&lt;/strong&gt;。对比启用 &lt;code&gt;runtimefree&lt;/code&gt; 实验前后的基准数据表明：*&lt;em&gt;在没有可释放对象的普通分配场景下，新机制对性能的影响在 -1.5% 到 +2.2% 之间，几何平均值几乎为零。也就是说，如果你的代码并不存在那些可以提前释放的内存对象，启用这个功能对性能既不会造成明显负担，也几乎不会带来益处——它基本是&lt;/em&gt;“零成本”（pay-for-what-you-use）*的。&lt;/p&gt;
&lt;p&gt;而在命中了优化路径的情况下，&lt;strong&gt;收益则是多方面的&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;减少 GC 的 CPU 消耗：&lt;/strong&gt; 这是最直接的好处。部分内存由运行时立即回收，意味着 GC 每次需要标记、扫描的对象变少，从而降低了 GC 自身的CPU占用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拉长 GC 间隔、缩短写屏障时间：&lt;/strong&gt; 垃圾变少了，GC 自然可以更久运行一次。对于 Go 程序来说，这意味着更多时间处于&lt;strong&gt;无 GC 干扰&lt;/strong&gt;的状态，写屏障（write barrier）启用的总时间减少，进而让应用代码本身跑得更快。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高缓存局部性：&lt;/strong&gt; 被 &lt;code&gt;runtime.free&lt;/code&gt; 释放的对象立即回收到对应大小类的空闲链表中，下一个相同大小的新对象分配&lt;strong&gt;很可能重用这块内存&lt;/strong&gt;。 这样一来，内存分配/释放形成类似&lt;strong&gt;栈式（LIFO）&lt;/strong&gt; 的模式，新分配的内存地址往往与刚释放的相同，对 CPU 缓存非常友好。相比任由 GC 随机回收、重新从堆中找内存，这种局部性有望进一步提升运行效率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;减少 GC 停顿和辅助操作：&lt;/strong&gt; 总体上，GC 工作量变小后，STW（stop-the-world）暂停的时间和 GC &lt;strong&gt;辅助运行&lt;/strong&gt;（assist）的触发频率都会降低，让应用更平稳&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外，新的垃圾回收器 &lt;code&gt;Green Tea&lt;/code&gt; 也可能从这种优化中受益——例如更高的每个span内存利用率，等等。尽管这方面还是推测，但&lt;strong&gt;runtime.free&lt;/strong&gt; 提案的出现显然为未来 GC 和内存优化的融合创造了更多可能。&lt;/p&gt;
&lt;h2 id=&#34;意义与展望开发者获得什么&#34;&gt;意义与展望：开发者获得什么？
&lt;/h2&gt;&lt;p&gt;从开发者的角度来看，runtime.free &lt;em&gt;究竟意味着什么&lt;/em&gt;？一言以蔽之：&lt;strong&gt;性能提升，几乎无需额外付出&lt;/strong&gt;。对于普罗大众的 Go 开发者来说，这个提案&lt;strong&gt;不会改变&lt;/strong&gt;我们日常编码的方式——没有新语法、也无需调用新的 API。所有魔法都发生在幕后：&lt;strong&gt;编译器&lt;/strong&gt;变得更聪明，&lt;strong&gt;运行时/标准库&lt;/strong&gt;替我们多做了一些工作。然而，它的影响可能是深远的：&lt;/p&gt;
&lt;p&gt;首先，这标志着 Go 的内存管理正在探索 &lt;strong&gt;“自动 GC”之外的第三条道路&lt;/strong&gt;。传统上，我们有完全自动的 GC（简单易用但性能牺牲）和手工的内存管理（复杂易出错但性能可控）。而 Go 的 runtime.free 尝试证明，两者并非水火不容：语言运行时本身可以变得更智能，&lt;strong&gt;在保证内存安全的前提下&lt;/strong&gt;，帮我们完成一些人工才能做到的优化。从某种意义上说，Go 正在尝试“靠自己”变得更快，而不是把负担转嫁给开发者。&lt;/p&gt;
&lt;p&gt;其次，对性能敏感的Go程序将直接受益于此。在未来的版本（提案目前计划针对 Go 1.26），当这一实验正式上线后，你或许会发现&lt;strong&gt;某些场景下 GC 压力突然降低&lt;/strong&gt;了。例如，大量使用临时切片进行计算的函数，不再生成那么多短命的垃圾；频繁扩容的 &lt;code&gt;bytes.Buffer&lt;/code&gt;、构建巨型 slice 的代码，在新版标准库里跑得飞快。这些性能改进都是 &lt;strong&gt;“开箱即得”&lt;/strong&gt; 的，开发者甚至不需要知道 runtime.free 的存在，就已经享受到了它的好处。&lt;/p&gt;
&lt;p&gt;当然，runtime.free 仍处于试验和完善阶段。它目前通过 &lt;code&gt;GOEXPERIMENT=runtimefree&lt;/code&gt; 提供，说明官方也在审慎评估其效果和风险。接下来社区会继续打磨细节，确保不会引入难以预料的错误（比如要严格杜绝“提前释放仍在用的对象”这种灾难性情况）。好消息是，到目前为止初步验证并未发现不可逾越的技术障碍，核心团队成员也给予了正面反馈。&lt;/p&gt;
&lt;p&gt;总体而言，runtime.free 提案代表了 Go 内存管理上&lt;strong&gt;务实而具有前瞻性&lt;/strong&gt;的一步。它不追求颠覆性的架构重写，而是聚焦于具体的瓶颈问题，寻求切实的优化突破；它也不牺牲类型安全和简洁性，将复杂度限定在编译器和运行时内部。这种思路一旦被证明行之有效，未来完全可以推广到更多模式（例如&lt;a class=&#34;link&#34; href=&#34;https://go.googlesource.com/proposal/&amp;#43;/refs/changes/55/700255/14/design/74299-runtime-free.md#:~:text=4.%20Recognizing%20,does%20not%20otherwise%20become%20aliased&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;识别更多 &lt;code&gt;append&lt;/code&gt; 循环的场景等&lt;/a&gt;），进一步减少 Go 程序的内存开销和 GC 次数。&lt;/p&gt;
&lt;p&gt;对于普通开发者来说，这意味着&lt;strong&gt;更快的程序&lt;/strong&gt;和&lt;strong&gt;更少的垃圾回收停顿&lt;/strong&gt;，而你依然可以像过去一样专注于业务逻辑，无需为手动内存管理操碎心。随着编译器与运行时不断进化，Go 有望在保持“一键爽跑”的易用性的同时，在性能上再攀新高峰——这一切，值得我们拭目以待。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引用资料：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Go Issue 【74299】“runtime, cmd/compile: add runtime.free, runtime.freetracked and GOEXPERIMENT=runtimefree”&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/74299#:~:text=updated%20manually%20to%20start%2C%20which,to%20automatically%20recognize%20its%20pattern&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;github.com&lt;/a&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/74299#:~:text=%28In%20short%2C%20currently%20,more%20allocations%20per%20benchmark%20loop&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;github.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Go Proposal 设计文档 “Directly freeing user memory to reduce GC work”&lt;a class=&#34;link&#34; href=&#34;https://go.googlesource.com/proposal/&amp;#43;/refs/changes/55/700255/14/design/74299-runtime-free.md#:~:text=For%20example%2C%20,to%20eliminate%20the%20first%20reason&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;go.googlesource.com&lt;/a&gt;&lt;a class=&#34;link&#34; href=&#34;https://go.googlesource.com/proposal/&amp;#43;/refs/changes/55/700255/14/design/74299-runtime-free.md#:~:text=1,Challenges%20here%20include&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;go.googlesource.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Go Issue 【&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/51317#:~:text=Note%2C%202023,recommend%20its%20use%20in%20production&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;#51317&lt;/a&gt;】“proposal: arena: new package providing memory arenas”（已被标记 hold)&lt;/li&gt;
&lt;li&gt;Go Discussions 【70257】“memory regions” (内存区域管理的讨论线程)&lt;/li&gt;
&lt;li&gt;Stack Overflow: &lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/72471052/how-to-free-memory-manually-in-golang&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;How to free memory manually in golang&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>HTTP/3：看似无处不在，实则难觅踪影</title>
        <link>https://huizhou92.com/zh-cn/p/http3%E7%9C%8B%E4%BC%BC%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8%E5%AE%9E%E5%88%99%E9%9A%BE%E8%A7%85%E8%B8%AA%E5%BD%B1/</link>
        <pubDate>Tue, 11 Nov 2025 18:57:08 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/http3%E7%9C%8B%E4%BC%BC%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8%E5%AE%9E%E5%88%99%E9%9A%BE%E8%A7%85%E8%B8%AA%E5%BD%B1/</guid>
        <description>&lt;img src="https://httptoolkit.com/images/header-images/http-toolkit-assets/h-sign-opt-640.WEBP" alt="Featured image of post HTTP/3：看似无处不在，实则难觅踪影" /&gt;&lt;p&gt;HTTP/3 的研发至少可追溯至 2016 年，而其底层传输协议 QUIC 更是由 Google 在 2013 年率先提出。如今这两项技术均已确立国际标准：&lt;a class=&#34;link&#34; href=&#34;https://caniuse.com/http3&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;strong&gt;获得 95% 浏览器的支持&lt;/strong&gt;&lt;/a&gt;，**Cloudflare 处理的 HTTP 请求中已有 &lt;a class=&#34;link&#34; href=&#34;https://radar.cloudflare.com/adoption-and-usage&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;32% 采用该协议**&lt;/a&gt;，并且在 HTTP Archive 数据集中，有 &lt;strong&gt;&lt;a class=&#34;link&#34; href=&#34;https://almanac.httparchive.org/en/2024/http#discovering-http3-support&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;35% 的网站&lt;/a&gt;&lt;/strong&gt; 宣称支持HTTP/3 (通过 alt-svc 或 DNS）。&lt;/p&gt;
&lt;p&gt;我们不仅成功开发出全新一代 HTTP 协议，更已将超三分之一的网络流量迁移至该协议——这堪称里程碑式的进展。&lt;/p&gt;
&lt;p&gt;然而矛盾的是，包括 Node.js、Go、Rust、Python 和 Ruby 在内的主流编程语言，其标准库均未内置对 QUIC 或 HTTP/3 的支持。Curl 虽然近期&lt;a class=&#34;link&#34; href=&#34;https://curl.se/docs/http3.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;新增了相关功能&lt;/a&gt;，但仍标记为实验性质且在大多数发行版中默认禁用。某些语言虽有第三方实现库，但均处于实验阶段，且无法与核心网络 API 协同工作。更值得注意的是，尽管移动网络是 HTTP/3 的关键应用场景，Android 主流 HTTP 库 OkHttp &lt;a class=&#34;link&#34; href=&#34;https://github.com/square/okhttp/blob/59cbf64f6ba98e2c8f95bf9db41dc47ad2232f94/okhttp/src/commonJvmAndroid/kotlin/okhttp3/Protocol.kt#L86-L94&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;仍明确不支持该协议&lt;/a&gt;。Nginx 仅提供&lt;a class=&#34;link&#34; href=&#34;https://nginx.org/en/docs/quic.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;实验性模块&lt;/a&gt;且默认关闭，Apache 既无支持计划也未公布路线图，而 Kubernetes 最流行的反向代理 Ingress-Nginx 更是&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes/ingress-nginx/issues/4760&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;完全放弃了支持计划&lt;/a&gt;，将相关功能移交至尚未发布的新一代项目。&lt;/p&gt;
&lt;p&gt;事实上，目前几乎找不到能完整支持 HTTP/3 的流行开源工具——这项技术的推广部署仍处于萌芽阶段。&lt;/p&gt;
&lt;p&gt;这种矛盾现象背后究竟隐藏着什么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;本文假设读者已了解 HTTP/1.1、HTTP/2 与 HTTP/3 的核心差异。如需入门资料，curl 创始人 Daniel Stenberg 撰写的 &lt;a class=&#34;link&#34; href=&#34;https://http2-explained.haxx.se/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http2-explained&lt;/a&gt; 与 &lt;a class=&#34;link&#34; href=&#34;https://http3-explained.haxx.se/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http3-explained&lt;/a&gt; 是绝佳参考。&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;让我们回溯根本：为什么这很重要？如果浏览器和大型 CDN 已支持 HTTP/3，其他客户端或服务端实现是否还有必要跟进？&lt;/p&gt;
&lt;p&gt;有观点认为，&lt;a class=&#34;link&#34; href=&#34;https://byroot.github.io/ruby/performance/2025/02/24/http2-past-the-load-balancer.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;在负载均衡器之后使用 HTTP/2 意义有限&lt;/a&gt;。其核心论点是：H&lt;strong&gt;TTP/2 的多路复用主要解决延迟与&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Head-of-line_blocking&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;队头阻塞 (Head-of-line blocking)&lt;/a&gt; 问题，但在延迟极低的内部网络中，通过长连接即可规避这些问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这个论点同样适用于 HTTP/3：它对高延迟、多请求的 浏览器-CDN 场景有益，但对其他场景价值有限。但即使只考虑 HTTP/1.1 与 HTTP/2，多路复用优势的现实情况也更加复杂：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;响应延迟不仅来自网络传输：服务端处理缓慢同样会阻塞 TCP 连接&lt;/li&gt;
&lt;li&gt;负载均衡器常与后端服务异地部署（例如通过全球 CDN 提供服务时，动态请求仍需回源至独立后端）&lt;/li&gt;
&lt;li&gt;长连接 TCP 连接并不可靠：即使在数据中心内，网络故障也时有发生，“保持连接”只是理想状态。HTTP 协议本身也会强制中断连接（如响应体传输中途失败时）&lt;/li&gt;
&lt;li&gt;流量波动会导致 TCP 连接数失衡：要么长期维持冗余连接池，要么在峰值时建立新连接，面临慢启动、往返延迟与 TLS 握手开销&lt;/li&gt;
&lt;li&gt;非网站类流量（移动应用、API 服务、物联网设备）同样面临网络延迟与服务端阻塞问题，这些场景都能从 HTTP/2/3 中获益&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除多路复用外，HTTP/2 还有更多跨场景优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;头部压缩（HTTP/2 的 &lt;a class=&#34;link&#34; href=&#34;https://blog.cloudflare.com/hpack-the-silent-killer-feature-of-http-2/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;HPACK&lt;/a&gt; 与 HTTP/3 的 &lt;a class=&#34;link&#34; href=&#34;https://datatracker.ietf.org/doc/rfc9204/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;QPACK&lt;/a&gt;）显著减少传输数据量，对内部长连接效果尤为明显&lt;/li&gt;
&lt;li&gt;双向流通信（仅 HTTP/2/3 支持）开启全新交互模式，gRPC 即基于此特性构建，类似 WebSocket 但完全兼容 HTTP 语义&lt;/li&gt;
&lt;li&gt;请求优先级控制允许服务端优化资源分配，这对负载均衡器与后端通信同样重要&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTTP/3 更在以下方面实现突破：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过取消 TCP 严格包序，使单个流独立传输，避免流间阻塞&lt;/li&gt;
&lt;li&gt;结合 TLS 1.3 与 QUIC 实现 &lt;a class=&#34;link&#34; href=&#34;https://blog.cloudflare.com/even-faster-connection-establishment-with-quic-0-rtt-resumption/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;0RTT 握手&lt;/a&gt;，首次请求无需等待 TLS 握手完成&lt;/li&gt;
&lt;li&gt;降低传输开销与连接数，减少客户端能耗与服务端资源消耗&lt;/li&gt;
&lt;li&gt;支持&lt;a class=&#34;link&#34; href=&#34;https://pulse.internetsociety.org/blog/how-quic-helps-you-seamlessly-connect-to-different-networks&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;连接迁移&lt;/a&gt;，IP 变更时保持会话连续性，未来甚至支持多路径传输&lt;/li&gt;
&lt;li&gt;采用 &lt;a class=&#34;link&#34; href=&#34;https://research.google/pubs/bbr-congestion-based-congestion-control-2/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;BBR 拥塞控制&lt;/a&gt;等先进算法，提升网络适应能力&lt;/li&gt;
&lt;li&gt;为 &lt;a class=&#34;link&#34; href=&#34;https://github.com/w3c/webtransport/blob/main/explainer.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WebTransport&lt;/a&gt; 提供基础，实现低延迟双向通信的同时解决 WebSocket 的队头阻塞等问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际测试数据同样佐证其价值。RequestMetric 的&lt;a class=&#34;link&#34; href=&#34;https://requestmetrics.com/web-performance/http3-is-fast/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;基准测试&lt;/a&gt;显示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://httptoolkit.com/images/posts/http-toolkit-assets/requestmetrics-http3-opt-1080.WEBP&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;各类网站在 HTTP/1.1、2、3 下的加载时间对比，显示 HTTP/3 显著提速&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Fastly 也在实际环境中观测到首字节时间的大幅优化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://httptoolkit.com/images/posts/http-toolkit-assets/fastly-http3-opt-1080.WEBP&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Fastly 实测 HTTP/3 降低首字节时间 18%&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;显然，这是一项&lt;strong&gt;具有实质价值&lt;/strong&gt;的技术。&lt;/p&gt;
&lt;p&gt;既然 HTTP/3 已完成标准化、获得广泛支持并经过实践检验，没理由不让所有开发者都能通过常用开发工具链享受这些技术红利。&lt;/p&gt;
&lt;h2 id=&#34;割裂的网络&#34;&gt;割裂的网络
&lt;/h2&gt;&lt;p&gt;现实却截然相反：尽管技术优势明显且网络流量占比显著，大多数开发者仍难以端到端部署 HTTP/3。这种现象折射出互联网长期存在的分层现状。如今的网络流量已分化为两种形态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;超大规模流量&lt;/strong&gt;：主流浏览器与特定移动应用通过精心调优的客户端，与少数科技巨头的自有基础设施或大型 CDN 通信&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;长尾流量&lt;/strong&gt;：后端服务、中小型应用、物联网设备、学术研究等多样化场景，依赖开源生态与共享技术栈&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两大阵营的核心差异包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;长尾流量规模更大： &lt;a class=&#34;link&#34; href=&#34;https://almanac.httparchive.org/en/2024/cdn#cdn-adoption&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;67%&lt;/a&gt; 的网页请求直连源站，Cloudflare 2024 年数据表明其 &lt;a class=&#34;link&#34; href=&#34;https://blog.cloudflare.com/application-security-report-2024-update/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;30% 流量来自自动化程序，60% 属于 API 调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;长尾生态天然碎片化，主要依赖志愿维护的开源项目&lt;/li&gt;
&lt;li&gt;超大规模阵营由少数利益相关方主导，能快速协调标准制定与落地&lt;/li&gt;
&lt;li&gt;商业动机高度集中：性能毫秒级提升直接关联企业收益&lt;/li&gt;
&lt;li&gt;长尾完全依赖开源实现，而超大规模玩家拥有自研定制的实力与资源&lt;/li&gt;
&lt;li&gt;版本迭代速度差异巨大：长尾工具注重稳定性，超大规模阵营追求快速迭代&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种分化并非善恶对立——从工程角度，HTTP/3 正是跨组织协作的卓越成果。但问题在于：当下一代网络技术由少数群体定义并优先服务自身需求时，大多数开发者只能通过购买 CDN 服务间接获取技术红利，这无疑限制了创新生态的健康发展。&lt;/p&gt;
&lt;h2 id=&#34;openssl-与-quic-的兼容困局&#34;&gt;OpenSSL 与 QUIC 的兼容困局
&lt;/h2&gt;&lt;p&gt;这种分化最具体的体现就是 OpenSSL 对 QUIC 的支持策略。作为最基础的 TLS 库，OpenSSL 的态度直接影响整个开源生态。事件脉络如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BoringSSL 2018 年即提供 QUIC API&lt;/li&gt;
&lt;li&gt;OpenSSL 长期缺失该功能，催生 QuicTLS 等兼容分支&lt;/li&gt;
&lt;li&gt;现有 HTTP/3 实现生态（Quiche、msh3、nghttp3 等）均基于 BoringSSL 或分支构建&lt;/li&gt;
&lt;li&gt;OpenSSL 3.2 起采用不兼容的实现方案，导致生态分裂&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;curl 的项目现状图清晰展现了这种割裂：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://httptoolkit.com/images/posts/http-toolkit-assets/http3-components-in-curl-opt-1080.WEBP&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;curl 支持的 HTTP/3 组件体系，现有实现均构建于 OpenSSL 替代方案之上&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;对大多数项目而言，放弃 OpenSSL 转向其他方案成本过高，这导致它们至今无法原生支持 QUIC。Node.js 曾&lt;a class=&#34;link&#34; href=&#34;https://github.com/nodejs/node/issues/57379&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;讨论切换方案&lt;/a&gt;，但考虑到系统兼容性、长期支持等现实因素，最终难以实施。&lt;/p&gt;
&lt;p&gt;这正是双层网络差异的典型体现：&lt;strong&gt;开源工具必须保持向后兼容，而超大规模玩家可以为了技术先进性承担更大变更成本&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;未来走向&#34;&gt;未来走向
&lt;/h2&gt;&lt;p&gt;组织架构差异正在导致互联网技术栈的分裂。虽然长尾场景未必急需 HTTP/3，但若放任不管，可能导致：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性能差距扩大：超大规模网站在移动网络环境下体验优势加剧&lt;/li&gt;
&lt;li&gt;工具链分化：前端框架等基础设施逐渐以 HTTP/3 为默认假设&lt;/li&gt;
&lt;li&gt;技术壁垒形成：缺乏 HTTP/3 支持可能成为被限流或验证的依据&lt;/li&gt;
&lt;li&gt;生态恶性循环：长尾需求逐渐被技术演进忽略&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有这些都还有一段距离，而且是相当假设性的！我怀疑其中一些假设会在某种程度上发生，但可能性范围很广。不过值得注意的是，这不仅仅适用于 HTTP/3：少数 CDN 和网络客户端的这种集中和协调很容易在许多其他类型的技术改进中也以类似的方式发生。&lt;/p&gt;
&lt;p&gt;至少对于 HTTP/3 而言，我希望这里能有一个愉快的解决方案来及时改善这种分裂，尽管我不知道它是否会足够快以避免明显的后果。许多 QUIC 和 HTTP/3 的外部库和实验性实现会随着时间的推移而成熟，而且我认为最终 (我真的非常希望) OpenSSL QUIC API 的分裂将得到解决，从而为 许多基于 OpenSSL 的环境中的 QUIC 支持打开大门，要么通过适配器支持这两种方法，要么通过直接支持 OpenSSL 模型的新 HTTP/3 和 QUIC 堆栈。&lt;br&gt;
然而，所有这一切都不会在今天发生，因此不幸的是，如果您想在您的应用程序中端到端地使用 HTTP/3，您可能还需要经历一段时间的艰难时期。敬请关注。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/http3%E7%9C%8B%E4%BC%BC%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8%E5%AE%9E%E5%88%99%E9%9A%BE%E8%A7%85%E8%B8%AA%E5%BD%B1/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;本文长期链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果您觉得我的博客对你有帮助，请通过 &lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/index.xml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RSS&lt;/a&gt;订阅我。&lt;/li&gt;
&lt;li&gt;或者在&lt;a class=&#34;link&#34; href=&#34;https://x.com/@piaopiaopig&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;X&lt;/a&gt;上关注我。&lt;/li&gt;
&lt;li&gt;如果您有&lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Medium&lt;/a&gt;账号，能给我个关注嘛？我的文章第一时间都会发布在Medium。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>浏览器的地址栏除了输入网址还能干什么？——玩贪吃蛇</title>
        <link>https://huizhou92.com/zh-cn/p/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E6%A0%8F%E9%99%A4%E4%BA%86%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%98%E8%83%BD%E5%B9%B2%E4%BB%80%E4%B9%88-%E7%8E%A9%E8%B4%AA%E5%90%83%E8%9B%87/</link>
        <pubDate>Thu, 02 Oct 2025 14:53:26 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E6%A0%8F%E9%99%A4%E4%BA%86%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%98%E8%83%BD%E5%B9%B2%E4%BB%80%E4%B9%88-%E7%8E%A9%E8%B4%AA%E5%90%83%E8%9B%87/</guid>
        <description>&lt;img src="https://images.hxzhouh.com/blog-images/2025/10/fad79b711c6e6b7146a52d42897cf268.png" alt="Featured image of post 浏览器的地址栏除了输入网址还能干什么？——玩贪吃蛇" /&gt;&lt;h1 id=&#34;浏览器的地址栏除了输入网址还能干什么玩贪吃蛇&#34;&gt;浏览器的地址栏除了输入网址还能干什么？——玩贪吃蛇
&lt;/h1&gt;&lt;h2 id=&#34;当一个十年前的疯狂创意重新走红它揭示了互联网正在失去的东西&#34;&gt;当一个十年前的疯狂创意重新走红，它揭示了互联网正在失去的东西
&lt;/h2&gt;&lt;p&gt;打开Chrome浏览器，在地址栏输入 &lt;a class=&#34;link&#34; href=&#34;https://demian.ferrei.ro/snake#&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://demian.ferrei.ro/snake#&lt;/a&gt; ，然后 你就看到一串奇怪的符号。&lt;br&gt;
是的，你没看错。就盯着你的地址栏，在用箭头键或WASD控制方向。&lt;br&gt;
你会看到一条由奇怪符号组成的小蛇（░░░░░░░⠠⠤⠄⡀░░）在地址栏里爬行，吃掉食物，越长越长。整个游戏就在那个你平时只用来输入网址的细长文本框里运行。&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/10/5ea3b9a9457de17c348e4a8631605888.gif&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Area&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;没错，这是一个完整的贪吃蛇游戏，运行在浏览器的URL地址栏里。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上周，这个十年前的项目突然在Hacker News上爆红，获得840个点赞和数百条评论。人们的第一反应都是：&amp;ldquo;这太疯狂了，你们是怎么想出来的？&amp;rdquo;&lt;/p&gt;
&lt;p&gt;但更疯狂的是这个游戏背后的故事——以及它揭示的关于现代互联网的真相。&lt;/p&gt;
&lt;h2 id=&#34;一次偶然的好奇心引发了一场技术冒险&#34;&gt;一次偶然的好奇心，引发了一场技术冒险
&lt;/h2&gt;&lt;p&gt;创作者Francisco Uzo回忆起项目的起源时说：&amp;ldquo;我想知道盲文系统是怎么工作的。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;这就是极客精神的起点——&lt;strong&gt;不是为了解决问题，而是纯粹的好奇。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当他深入研究盲文时，发现了一个迷人的规律：每个盲文符号由2x4的点阵组成，8个点位，每个点有&amp;quot;凸起&amp;quot;或&amp;quot;平坦&amp;quot;两种状态，正好产生2^8=256种可能的组合。而Unicode系统完整收录了所有这256个盲文字符。&lt;/p&gt;
&lt;p&gt;某天的凌晨三点，他突然意识到：&lt;strong&gt;&amp;ldquo;等等，这不就是一个现成的8位像素字符集吗？&amp;rdquo;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种顿悟的瞬间，正是每个极客最享受的时刻——当两个看似无关的知识点在脑海中碰撞，迸发出创意的火花。&lt;/p&gt;
&lt;p&gt;然后就是典型的极客行为模式：&lt;strong&gt;不管有没有用，先做出来再说&lt;/strong&gt;。&lt;br&gt;
整个实现充满了黑客思维：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将游戏世界映射到盲文字符网格——每个字符就是一个2x4像素块&lt;/li&gt;
&lt;li&gt;蛇的身体用实心点（⣿）表示，空白区域用空盲文（⠀）表示&lt;/li&gt;
&lt;li&gt;使用JavaScript的&lt;code&gt;history.replaceState()&lt;/code&gt;API实时更新URL而不污染历史记录&lt;/li&gt;
&lt;li&gt;每帧刷新，整个游戏画面就在地址栏里流畅运行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Francisco的透明度也很&amp;quot;极客&amp;quot;：&amp;ldquo;源代码没有任何压缩或混淆处理。Ctrl+U就能看到全部代码。&amp;ldquo;整个实现只用了几百行JavaScript，简洁而巧妙。&lt;strong&gt;在真正的极客眼中，代码本身就应该是可读的、可学习的、可启发的。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;等等我的游戏怎么看起来乱七八糟的&#34;&gt;等等，我的游戏怎么看起来乱七八糟的？
&lt;/h2&gt;&lt;p&gt;如果你现在打开这个游戏，很可能会看到一堆奇怪的&lt;code&gt;%20&lt;/code&gt;、反斜杠和乱码。游戏勉强能玩，但画面支离破碎。或者根本不能动起来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这不是你的问题，也不是代码的问题。问题在于：十年过去了，浏览器变了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Francisco在讨论中坦言：&amp;ldquo;这个项目是为十年前的浏览器设计的。自那以后，浏览器进行了一些所谓的&amp;rsquo;安全改进&amp;rsquo;，严重削弱了基于地址栏的游戏能力。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;最致命的改变是：&lt;strong&gt;现代浏览器开始强制转义URL中的所有空格字符。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在游戏的设计中，空盲文字符（⠀）代表空白区域。但现代浏览器把它们转义成&lt;code&gt;%20&lt;/code&gt;或其他字符，导致画面变形。Francisco甚至开发了一套基于Canvas的字体测量系统来检测和替换被转义的字符，但效果仍然有限。&lt;/p&gt;
&lt;p&gt;他在浏览器的问题追踪器中提出了申诉。开发者表示理解和同情，但最终的决定是：&lt;strong&gt;&amp;ldquo;安全性照例压倒了趣味性。&amp;rdquo;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户报告的游戏体验差异巨大：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有人在Chrome上轻松得到2144分&lt;/li&gt;
&lt;li&gt;有人在Firefox上看到满屏乱码&lt;/li&gt;
&lt;li&gt;有人在移动Safari上根本看不到游戏&lt;/li&gt;
&lt;li&gt;有人的浏览历史被每一帧都污染了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同一个代码，在不同浏览器上的表现天差地别。这就是现代Web开发的现实。&lt;/p&gt;
&lt;h2 id=&#34;那些年我们在浏览器里玩过的花样&#34;&gt;那些年，我们在浏览器里玩过的花样
&lt;/h2&gt;&lt;p&gt;地址栏贪吃蛇不是唯一一个这类创意项目。Hacker News的讨论中，大家开始回忆起一整个&amp;quot;非常规浏览器游戏&amp;quot;的黄金时代。&lt;/p&gt;
&lt;h3 id=&#34;url里的2048游戏&#34;&gt;&lt;strong&gt;URL里的2048游戏&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;有人分享了 &lt;a class=&#34;link&#34; href=&#34;https://aquova.net/games/2048/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://aquova.net/games/2048/&lt;/a&gt; ——将风靡一时的2048益智游戏移植到地址栏中。同样的盲文字符技巧，同样的实时URL更新。&lt;/p&gt;
&lt;h3 id=&#34;浏览器标题栏的贪吃蛇&#34;&gt;&lt;strong&gt;浏览器标题栏的贪吃蛇&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;Francisco提到，Reddit上最近有人发布了新版本——把游戏渲染在浏览器标签页的标题里。虽然这是一种&amp;quot;认输方案&amp;rdquo;（放弃了在地址栏显示的坚持），但它确实避免了URL转义的问题。&lt;/p&gt;
&lt;h3 id=&#34;tinyjs贪吃蛇&#34;&gt;&lt;strong&gt;TinyJS贪吃蛇&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;2023年，另一个开发者用不同的技术路径实现了类似的&lt;a class=&#34;link&#34; href=&#34;https://danielgjackson.github.io/tinyjs#snake&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;项目&lt;/a&gt;。那时浏览器的限制还没有这么严格。&lt;/p&gt;
&lt;h3 id=&#34;地址栏3d漫游&#34;&gt;&lt;strong&gt;地址栏3D漫游&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;有人分享了一个更疯狂的项目：&lt;a class=&#34;link&#34; href=&#34;https://matthew.rayfield.world/articles/games-and-graphics-in-popup-url-bars/#:~:text=The%203D%20Room%ef%bc%89&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;用非常规方式在浏览器中实现交互式3D世界&lt;/a&gt;&lt;br&gt;
评论者说：&amp;ldquo;虽然不是Doom，但你可以在3D世界里四处走动。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;这些项目有什么共同点？&lt;strong&gt;它们都是程序员纯粹出于好奇心和乐趣的创造。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;没有商业价值，没有实际用途，甚至算不上&amp;quot;最佳实践&amp;rdquo;。但它们代表了早期互联网的一种精神：&lt;strong&gt;这是一个可以玩耍、可以实验、可以突破界限的地方。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;为什么这些项目现在越来越难做了&#34;&gt;为什么这些项目现在越来越难做了？
&lt;/h2&gt;&lt;p&gt;问题不只是空格转义。过去十年，浏览器经历了大量&amp;quot;&lt;strong&gt;安全改进&lt;/strong&gt;&amp;quot;：&lt;/p&gt;
&lt;h3 id=&#34;历史api的限制&#34;&gt;&lt;strong&gt;历史API的限制&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;Francisco最初使用&lt;code&gt;history.replaceState()&lt;/code&gt;来更新URL而不创建历史记录。但现代浏览器对这个API的调用频率有严格限制。当游戏帧率太高时，系统被迫降级到&lt;code&gt;location.hash&lt;/code&gt;方案——结果是你的浏览历史被每一帧游戏都污染了。&lt;/p&gt;
&lt;p&gt;一位用户吐槽：&amp;ldquo;我最烦的就是这个。访问某些网站后查看历史记录，发现被我输入的每个按键都创建了条目。这一切都是以&amp;rsquo;用户体验&amp;rsquo;的名义。&amp;rdquo;&lt;/p&gt;
&lt;h3 id=&#34;url长度限制&#34;&gt;&lt;strong&gt;URL长度限制&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;不同浏览器对URL长度有不同的限制，从2000字符到几万字符不等。对于需要在URL中编码整个游戏状态的项目来说，这是个硬性天花板。&lt;/p&gt;
&lt;h3 id=&#34;字符集限制&#34;&gt;&lt;strong&gt;字符集限制&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;越来越多的特殊Unicode字符被标记为&amp;quot;不安全&amp;quot;，在URL中被自动转义或过滤。这直接打击了所有基于Unicode艺术的创意项目。&lt;/p&gt;
&lt;h3 id=&#34;移动端兼容性&#34;&gt;&lt;strong&gt;移动端兼容性&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;许多移动浏览器根本不显示完整的URL，或者在用户滚动时隐藏地址栏。这让地址栏游戏变得不可玩。&lt;/p&gt;
&lt;p&gt;Francisco总结道：&amp;ldquo;自那以后，浏览器的许多改变都让这类项目越来越难实现。我在浏览器问题追踪器中得到了一些同情，但安全性总是优先的。&amp;rdquo;&lt;/p&gt;
&lt;h2 id=&#34;当安全性扼杀了互联网的乐趣&#34;&gt;当安全性扼杀了互联网的乐趣
&lt;/h2&gt;&lt;p&gt;这里出现了一个根本性的矛盾。&lt;/p&gt;
&lt;p&gt;**没人会反对浏览器安全性的提升。**URL注入攻击、跨站脚本漏洞、钓鱼网站——这些是真实存在的威胁，影响着数十亿用户。浏览器开发者有责任保护用户安全。&lt;/p&gt;
&lt;p&gt;但与此同时，每一次&amp;quot;安全改进&amp;quot;都关闭了某些创造性实验的大门。&lt;/p&gt;
&lt;p&gt;Francisco的游戏十年前完美运行，今天却在大多数浏览器上支离破碎。不是因为代码有问题，而是因为浏览器&amp;quot;进化&amp;quot;了。这种&amp;quot;进化&amp;quot;让用户更安全，但也让互联网变得更加统一、更加受控、更加&amp;hellip;&amp;hellip;无聊。&lt;/p&gt;
&lt;h3 id=&#34;失去的不仅仅是游戏&#34;&gt;&lt;strong&gt;失去的不仅仅是游戏&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;在Hacker News的讨论中，有人提出了尖锐的批评：&amp;ldquo;为什么人们不去做有用的事情？别滥用互联网。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;这个评论遭到了社区的集体反驳：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;制作这类项目的学习价值是巨大的&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;创造性休息和技能开发同样重要&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;这就是我来Hacker News的原因——100%的黑客精神&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;ChatGPT发明不出这个。我爱这种创造力&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最精辟的回应来自一位用户：&amp;ldquo;对普通人来说这可能不算什么，但对我来说这太疯狂了。你们是怎么想出这些东西的？&amp;rdquo;&lt;/p&gt;
&lt;p&gt;**这就是问题的核心。**这些项目的价值不在于&amp;quot;有用&amp;quot;，而在于它们代表了一种纯粹的创造冲动——因为好奇而探索，因为有趣而创造，因为&amp;quot;为什么不试试&amp;quot;而突破界限。&lt;/p&gt;
&lt;p&gt;当我们为了安全而设置越来越多的限制，我们不只是在关闭安全漏洞，我们也在关闭创新的可能性。&lt;/p&gt;
&lt;h3 id=&#34;权衡是必要的但我们应该意识到代价&#34;&gt;&lt;strong&gt;权衡是必要的，但我们应该意识到代价&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;这不是在指责浏览器开发者。他们面对的是极其艰难的权衡决策：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;允许灵活的URL编码 vs. 防止注入攻击&lt;/li&gt;
&lt;li&gt;支持高频API调用 vs. 避免性能问题&lt;/li&gt;
&lt;li&gt;显示任意Unicode字符 vs. 防止钓鱼欺诈&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;没有完美的答案。&lt;/strong&gt; 每个决定都有其代价。&lt;/p&gt;
&lt;p&gt;但我们至少应该意识到并讨论这些代价。当我们说&amp;quot;安全第一&amp;quot;时，我们应该问：&amp;ldquo;我们因此失去了什么？&amp;ldquo;当我们说&amp;quot;用户体验优化&amp;quot;时，我们应该问：&amp;ldquo;这优化了谁的体验？&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Francisco在浏览器问题追踪器中得到的回复是典型的：&amp;ldquo;我理解你的困扰，但安全性必须优先。&amp;ldquo;这个回答在技术层面无可指摘，但它也代表了一种更广泛的趋势：&lt;strong&gt;在现代互联网上，控制和安全正在系统性地压倒创造和乐趣。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;在ai时代这种人类创造更加珍贵&#34;&gt;在AI时代，这种人类创造更加珍贵
&lt;/h2&gt;&lt;p&gt;当讨论转向AI时，Francisco说了一句发人深省的话：&lt;/p&gt;
&lt;p&gt;&amp;ldquo;这个游戏已经存在十年了，所以很可能在这些AI的训练数据中。机器人也许能复制它，但它们肯定无法享受它！（至少现在还不能）&amp;rdquo;&lt;/p&gt;
&lt;p&gt;这句话触及了当前技术文化的核心焦虑。在ChatGPT可以瞬间生成代码、Copilot可以自动补全函数的时代，什么样的编程项目还值得人类去做？&lt;/p&gt;
&lt;p&gt;答案可能就在这个地址栏贪吃蛇里。&lt;/p&gt;
&lt;p&gt;AI可以看到盲文字符，可以理解Unicode编码，可以生成JavaScript代码。但AI不能体验：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;凌晨三点突然意识到&amp;quot;盲文可以当像素&amp;quot;的那一刻顿悟&lt;/li&gt;
&lt;li&gt;第一次看到蛇在地址栏里动起来时的惊喜&lt;/li&gt;
&lt;li&gt;花几个小时调试字符转义问题时的执着&lt;/li&gt;
&lt;li&gt;十年后看到陌生人喜欢你的项目时的满足感&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些&lt;strong&gt;纯粹的人类创造体验&lt;/strong&gt;，在AI可以复制几乎所有代码的时代，反而变得更加珍贵。&lt;/p&gt;
&lt;p&gt;Francisco的项目不是为了解决问题而创造，而是为了探索和乐趣而创造。这种动机，这种过程，这种纯粹的创造喜悦——&lt;strong&gt;这是AI永远无法真正拥有的。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;我们需要更多像这样的项目&#34;&gt;我们需要更多像这样的项目
&lt;/h2&gt;&lt;p&gt;这个地址栏贪吃蛇重新走红，不是因为它特别有用或特别赚钱。它走红是因为它提醒了我们一些重要的事情：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;互联网不应该只是一个高效、安全、标准化的工具。它也应该是一个充满惊喜、可以玩耍、可以实验的地方。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当Francisco十年前问自己&amp;quot;盲文是怎么工作的&amp;quot;时，他不是在解决商业问题或优化用户体验。他只是好奇，然后他创造了一个让数千人微笑的项目。&lt;/p&gt;
&lt;p&gt;在这个越来越同质化、越来越&amp;quot;安全&amp;rdquo;、越来越被算法优化的互联网上，我们需要更多这样的项目。不是因为它们有用，而是因为它们提醒我们：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术的意义不仅仅是效率和安全——它也应该是充满惊奇和乐趣的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在这个游戏上你能得多少分？你的浏览器支持得好吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也许更重要的问题是：&lt;strong&gt;这个项目让你想起了什么？你有没有做过类似的&amp;quot;无用但有趣&amp;quot;的创造？&lt;/strong&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Go 官方再谈错误处理：新语法为何迟迟无法落地？</title>
        <link>https://huizhou92.com/zh-cn/p/go-%E5%AE%98%E6%96%B9%E5%86%8D%E8%B0%88%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%96%B0%E8%AF%AD%E6%B3%95%E4%B8%BA%E4%BD%95%E8%BF%9F%E8%BF%9F%E6%97%A0%E6%B3%95%E8%90%BD%E5%9C%B0/</link>
        <pubDate>Wed, 04 Jun 2025 20:14:24 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/go-%E5%AE%98%E6%96%B9%E5%86%8D%E8%B0%88%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%96%B0%E8%AF%AD%E6%B3%95%E4%B8%BA%E4%BD%95%E8%BF%9F%E8%BF%9F%E6%97%A0%E6%B3%95%E8%90%BD%E5%9C%B0/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/06/0d71cfc56d9aec68cc85fd38ca37e3a7.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20250605093005&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;go-官方再谈错误处理新语法为何迟迟无法落地&#34;&gt;Go 官方再谈错误处理：新语法为何迟迟无法落地？
&lt;/h1&gt;&lt;p&gt;近日，Go 官方博客发布了一篇名为《&lt;a class=&#34;link&#34; href=&#34;https://go.dev/blog/error-syntax&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;On | No syntactic support for error handling&lt;/a&gt;》的文章。这篇文章没有带来期待中的语法突破，反而再次回顾了 Go 语言过去在错误处理语法上多次尝试的失败经验。&lt;br&gt;
Go 团队为什么发表这么一篇文章？&lt;/p&gt;
&lt;h2 id=&#34;为什么-go-团队反复探讨错误处理&#34;&gt;为什么 Go 团队反复探讨“错误处理”？
&lt;/h2&gt;&lt;p&gt;自诞生以来，Go 语言以简洁明了著称，但却始终背负着一个无法回避的问题：错误处理语法过于冗长。&lt;br&gt;
我们熟悉的 Go 错误处理通常长这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;``&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Go&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;printSum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;strconv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Atoi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;strconv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Atoi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;result:&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;反复出现的 &lt;code&gt;if err != nil&lt;/code&gt; 显得单调乏味，代码中大量的错误处理重复模式经常被批评为“&lt;strong&gt;机械且冗余&lt;/strong&gt;”。因此，过去数年，Go 团队多次尝试设计更为简洁的新语法，但最终都未能成功落地。&lt;/p&gt;
&lt;h2 id=&#34;曾经尝试却未成功的那些提案&#34;&gt;曾经尝试却未成功的那些提案
&lt;/h2&gt;&lt;p&gt;Go 团队在过去提出了几种备受关注但最终放弃的方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2018年：&lt;a class=&#34;link&#34; href=&#34;https://go.googlesource.com/proposal/&amp;#43;/master/design/go2draft-error-handling.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;check&lt;/code&gt; 与 &lt;code&gt;handle&lt;/code&gt;&lt;/a&gt; 提案&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;尝试用新关键字简化错误传播，但社区担忧复杂度增加，被否决。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2019年：&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/32437&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; 提案&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;引入内置函数 &lt;code&gt;try&lt;/code&gt;，期望简化语法。但社区认为该方案过于隐式，破坏了代码的明确性，也被搁置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2024 年：？&lt;br&gt;
Ian Lance Taylor 参考 Rust 的实现提出了 &lt;a class=&#34;link&#34; href=&#34;https://go.dev/issue/71203&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;“使用 &lt;code&gt;?&lt;/code&gt; ”减少错误处理样板&lt;/a&gt; 也遭遇到了大量的反对意见，  我也水了一篇博客&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些尝试的失败不仅仅是技术上的，更体现了 Go 社区一种特殊的文化和理念——&lt;strong&gt;明确胜于隐式&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;真正的动机是什么&#34;&gt;真正的动机是什么？
&lt;/h2&gt;&lt;p&gt;细读这篇博客，我们会发现 Go 团队并不是单纯地“回忆过去”，而是在认真回应社区持续发酵的讨论：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;究竟有没有必要为错误处理引入新语法？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文章的字里行间传递了一个关键的讯号：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“Go 社区对于新语法的需求，并非简单的‘yes or no’，而是深入涉及到语言设计哲学和社区价值观的问题。”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;换句话说，Go 团队的动机并不是要立即给出一个新提案，而是希望借此引导社区回到初心，认真审视“我们真正需要什么样的语言设计？”&lt;/p&gt;
&lt;h2 id=&#34;明确胜于隐式go-社区无法放弃的原则&#34;&gt;“明确胜于隐式”：Go 社区无法放弃的原则
&lt;/h2&gt;&lt;p&gt;Go 语言的成功，正是因为其清晰且明确的设计哲学。任何新语法都必须经过社区的严格审视：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新语法能否保持明确性？&lt;/li&gt;
&lt;li&gt;新语法能否带来足够的收益，值得牺牲现有的简单性？&lt;/li&gt;
&lt;li&gt;新语法是否有可能带来其他负面影响？&lt;br&gt;
在这种原则下，每个提案都难免面临严格审视和质疑。这也是过去的尝试频频受挫的根本原因。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;五未来的路在哪里&#34;&gt;五、未来的路在哪里？
&lt;/h2&gt;&lt;p&gt;这篇官方博客所释放的另一个信息是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Go 团队已经接受了短期内不会推出新错误处理语法的现实。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;他们似乎在暗示：错误处理的语法简化并非完全不可行，但至少现在还未找到完美的答案，社区需要更多时间的探索、实践与反思。&lt;br&gt;
因此，未来很长一段时间内，Go 程序员仍需忍受现有模式的重复。但同时也意味着，Go 语言暂时保持了它清晰、直接、没有魔法的风格。&lt;/p&gt;
&lt;p&gt;Go 团队主动发布这样一篇文章，看似回顾历史、承认失败，实则希望引发社区更深层次的讨论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;我们究竟希望 Go 变成什么样子？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;为了简洁，我们愿意牺牲多少明确性？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;无论你是否赞同当前的处理方式，这样的反思和讨论对于语言生态的健康发展，都是极其重要的。&lt;br&gt;
也许下一次提案会再次失败，也许未来某一天，社区终究找到满意的平衡点。但至少，我们可以肯定的是：&lt;br&gt;
&lt;strong&gt;Go 社区一直在探索，一直在反思，也一直在进步。&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;原文链接：&lt;a class=&#34;link&#34; href=&#34;https://go.dev/blog/error-syntax&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://go.dev/blog/error-syntax&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/go-%E5%AE%98%E6%96%B9%E5%86%8D%E8%B0%88%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%96%B0%E8%AF%AD%E6%B3%95%E4%B8%BA%E4%BD%95%E8%BF%9F%E8%BF%9F%E6%97%A0%E6%B3%95%E8%90%BD%E5%9C%B0/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;本文长期链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果您觉得我的博客对你有帮助，请通过 &lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/index.xml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RSS&lt;/a&gt;订阅我。&lt;/li&gt;
&lt;li&gt;或者在&lt;a class=&#34;link&#34; href=&#34;https://x.com/@piaopiaopig&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;X&lt;/a&gt;上关注我。&lt;/li&gt;
&lt;li&gt;如果您有&lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Medium&lt;/a&gt;账号，能给我个关注嘛？我的文章第一时间都会发布在Medium。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Go 的 map 为什么变慢了?.zh-cn</title>
        <link>https://huizhou92.com/zh-cn/p/go-%E7%9A%84-map-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%98%E6%85%A2%E4%BA%86.zh-cn/</link>
        <pubDate>Tue, 20 May 2025 22:18:57 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/go-%E7%9A%84-map-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%98%E6%85%A2%E4%BA%86.zh-cn/</guid>
        <description>&lt;img src="https://images.hxzhouh.com/blog-images/2025/05/a7748f1ab7e01c49c0f35f9591f6cfd3.png" alt="Featured image of post Go 的 map 为什么变慢了?.zh-cn" /&gt;&lt;blockquote&gt;
&lt;p&gt;这篇文章解释了为什么在 Go 1.24 版本中，你的程序可能因为 map 变慢了，以及 Go 团队是怎么计划修复这个问题的。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Golang 1.24 中最吸引我的功能就是 &lt;strong&gt;SwissMap&lt;/strong&gt;，在以前的非官方实现中，有些场景能够提升50% 的性能，官方的实现中，也有不小的性能提升。&lt;br&gt;
详情参考我以前的文章:&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/swisstable-%E4%BC%9A%E6%88%90%E4%B8%BA-golang-std-map%E5%98%9B/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;SwissTable 会成为 Golang std map嘛？&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/go-124-%E7%9A%84-swiss-map%E5%85%BC%E5%AE%B9%E6%80%A7%E6%89%A9%E5%B1%95%E5%93%88%E5%B8%8C%E4%B8%8E%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 1.24 的 Swiss Map：兼容性、扩展哈希与遗留问题&lt;/a&gt;&lt;/p&gt;
&lt;!-- more--&gt;
&lt;p&gt;但是 如果你在使用 Go 1.24 时可能会发现&lt;strong&gt;SwissMap&lt;/strong&gt; 没有达到预期的表现，甚至程序运行变慢了，特别是在 Map很大的时候，这不是你的幻觉，确实存在这个问题。&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/05/4b861f761a7ffbfbd6d6a5cad8010276.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20250520225045&#34;
	
	
&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://x.com/valyala/status/1879988053076504761&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://x.com/valyala/status/1879988053076504761&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个问题记录在 &lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/70835&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Issue #70835&lt;/a&gt; 中，开发者们正在努力解决它。&lt;/p&gt;
&lt;h2 id=&#34;问题出在哪&#34;&gt;问题出在哪？
&lt;/h2&gt;&lt;p&gt;Go 的 map 在新版中使用了Swiss Table，它在小 map 和高并发的场景下非常快。但是当 map 很大、数据又不在 CPU 缓存里（也就是说，数据是“冷”的），就会变慢。&lt;/p&gt;
&lt;p&gt;为什么会这样呢？&lt;/p&gt;
&lt;p&gt;因为 SwissMap 的内部结构比较复杂，它会分几层来存储数据：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先是一个 map 的头部结构&lt;/li&gt;
&lt;li&gt;它指向一个目录，这个目录是多个 table 的指针组成的列表&lt;/li&gt;
&lt;li&gt;每个 table 里面有控制信息、key 和 value&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/01/784e3f6a0ff90601480a2da80f3cb9d0.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当你查找一个 key 的时候，可能需要进行 &lt;strong&gt;4 到 6 次跳转&lt;/strong&gt;，每一次都可能遇到缓存未命中。这样就会导致 CPU 忙着从内存取数据，速度就慢了。&lt;/p&gt;
&lt;p&gt;像 Prometheus 这样的大型项目就发现了这个问题。他们升级到 Go 1.24 后，CPU 使用率上升了很多，经调查发现就是因为 map 的查找变慢了。&lt;/p&gt;
&lt;h2 id=&#34;是怎么发现的&#34;&gt;是怎么发现的？
&lt;/h2&gt;&lt;p&gt;问题并不是在测试用例里发现的，而是在真实的线上场景中出现的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用了很大的 map（比如几兆字节大小）&lt;/li&gt;
&lt;li&gt;经常读取 map 里的数据&lt;/li&gt;
&lt;li&gt;数据不在 CPU 的高速缓存里&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Go 团队的工程师 Michael Pratt 通过做很多测试，找到了 map 访问变慢的原因，并在 &lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/70835&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Issue #70835&lt;/a&gt; 中详细说明。&lt;/p&gt;
&lt;h2 id=&#34;怎么修&#34;&gt;怎么修？
&lt;/h2&gt;&lt;p&gt;为了让 map 更快，他们计划做以下几件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;简化目录结构&lt;/strong&gt;：把原来存指针的列表改成直接存结构，减少一次跳转&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制信息更紧凑&lt;/strong&gt;：把控制信息安排得更集中，这样更容易被 CPU 一次加载&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分离 key 和 value&lt;/strong&gt;：改成“key-key-key + value-value-value”的结构，这样可以优化加载顺序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对齐控制字节&lt;/strong&gt;：把控制信息按照 CPU 缓存对齐，减少未命中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些改动并不简单，因为会影响到 Go 的运行时核心：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要确保垃圾回收能正常工作&lt;/li&gt;
&lt;li&gt;map 扩容和缩容逻辑要更新&lt;/li&gt;
&lt;li&gt;要确保对小 map 的性能没有影响&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;哪些地方在讨论这个&#34;&gt;哪些地方在讨论这个？
&lt;/h2&gt;&lt;p&gt;这个问题被广泛讨论和跟踪，可以通过&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/70835&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Issue #70835&lt;/a&gt;  了解更多的 细节。 &lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/milestone/122&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go Release Dashboard&lt;/a&gt; 中已经标记这个问题将会在 Go1.25 中解决&lt;br&gt;
此外 &lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/71368&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Issue #71368&lt;/a&gt; 中也讨论了 另一个与内存布局的问题。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结
&lt;/h2&gt;&lt;p&gt;Go 团队一直在努力让语言运行得更快更稳。SwissMap 是个好改进，但它也带来了新挑战，比如这次的冷缓存性能下降。&lt;br&gt;
Issue #70835 展示了 Go 是如何通过社区反馈不断进步的。感谢像 Prometheus 这样的开源项目，他们的报告帮助 Go 做得更好。&lt;br&gt;
如果一切顺利，Go 1.25 就能把速度和稳定性都带回来。&lt;br&gt;
我们一起期待吧！&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Green Tea GC: Golang 的 ZGC？</title>
        <link>https://huizhou92.com/zh-cn/p/green-tea-gc-golang-%E7%9A%84-zgc/</link>
        <pubDate>Mon, 05 May 2025 16:30:26 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/green-tea-gc-golang-%E7%9A%84-zgc/</guid>
        <description>&lt;img src="https://images.hxzhouh.com/blog-images/2025/05/fb6313678681ee8e97a05ee521bd0e20.png" alt="Featured image of post Green Tea GC: Golang 的 ZGC？" /&gt;&lt;p&gt;近年来，Go 语言的垃圾回收（GC）机制虽然经历了多个版本优化，但它的性能瓶颈，尤其在高并发与大规模内存场景下，依然是开发者关注的重点。最近，Go 官方在 GitHub 上提出的 &lt;strong&gt;Green Tea GC&lt;/strong&gt;（#73581）引发了热议：它能否进一步解决 Go GC 的耗时问题？本文将深入解析 Go GC 的设计、缺点、实测表现，并带你了解 Green Tea GC 的技术突破。&lt;/p&gt;
&lt;!-- more--&gt;
&lt;h2 id=&#34;-go-gc-的设计与实现&#34;&gt;📦 Go GC 的设计与实现
&lt;/h2&gt;&lt;p&gt;自 Go 1.5 起，Go 使用并发标记-清除（concurrent mark-sweep）算法，结合“三色标记”模型与 Yuasa 写屏障。&lt;/p&gt;
&lt;p&gt;简而言之，Go GC 会在后台并发地遍历堆内存，标记可达对象，并逐步清除未被引用的内存块。整个回收过程中，Go 追求&lt;strong&gt;低延迟、低停顿&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;✅ 并发标记、并发清除&lt;br&gt;
✅ 不会移动对象（即 no compaction）&lt;br&gt;
✅ 按 span（内存块）分批清扫，减少单次 STW（Stop-the-World）时长&lt;/p&gt;
&lt;p&gt;这种设计的直接好处是：应用大部分时间能与 GC 并行工作，最大停顿时间通常低于毫秒级。&lt;/p&gt;
&lt;h2 id=&#34;-go-gc-的已知问题&#34;&gt;🚧 Go GC 的已知问题
&lt;/h2&gt;&lt;p&gt;虽然 Go GC 的延迟表现优秀，但它在耗时和扩展性上仍有几个硬伤，尤其体现在：&lt;/p&gt;
&lt;p&gt;1️⃣ &lt;strong&gt;内存访问低效&lt;/strong&gt;&lt;br&gt;
GC 的标记阶段会跨对象跳跃，导致 CPU 频繁 cache miss、等待内存，约 35% 的 GC CPU 周期被耗在“等内存”。这在 NUMA 架构或多核大内存机器上尤为明显。&lt;/p&gt;
&lt;p&gt;2️⃣ &lt;strong&gt;缺乏分代收集&lt;/strong&gt;&lt;br&gt;
Go GC 没有分代机制，所有对象一视同仁，这在高分配率场景下显得笨重。Pinterest 工程师曾指出，内存压力一旦增大，GC 就会暴增 CPU 消耗，引发延迟激增。&lt;/p&gt;
&lt;p&gt;3️⃣ &lt;strong&gt;频繁 GC 带来的 CPU 占用&lt;/strong&gt;&lt;br&gt;
Twitch 工程团队曾报告：即便在中小堆内存下（&amp;lt;450 MiB），系统稳态下每秒会触发 8–10 次 GC，每分钟累计 400–600 次，GC 占用约 &lt;strong&gt;30% 的 CPU 时间&lt;/strong&gt;。这直接挤压了业务线程的执行空间。&lt;/p&gt;
&lt;h2 id=&#34;-性能测试gc-对-go-程序的影响&#34;&gt;📊 性能测试：GC 对 Go 程序的影响
&lt;/h2&gt;&lt;p&gt;我们来看几个实际基准的变化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Go 1.3/1.4（并发 GC 前）&lt;/strong&gt;&lt;br&gt;
大堆（10GB+）上的 GC 停顿：以秒计算。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Go 1.5（并发 GC 引入后）&lt;/strong&gt;&lt;br&gt;
相同条件下，GC 停顿压缩到 &amp;lt;1ms。&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/05/8d6a9563ad431b76e34d31077cbcd82b.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20250504161704&#34;
	
	
&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Go 1.6–1.8&lt;/strong&gt;&lt;br&gt;
最大堆 200GB，GC 停顿控制在 20ms 以下，甚至常态 1ms。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些进步非常亮眼，但注意：&lt;br&gt;
✅ 延迟控制好了&lt;br&gt;
⚠️ 总耗时和 CPU 消耗依然显著，特别是高负载或高分配场景。&lt;/p&gt;
&lt;h2 id=&#34;-green-tea-gc全新优化方案&#34;&gt;🌿 Green Tea GC：全新优化方案
&lt;/h2&gt;&lt;p&gt;面对这些问题，Go 官方提出了 Green Tea GC。它的核心优化点是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;从单对象扫描，升级为按 span（内存块）批量扫描。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;具体来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小对象（≤512B）标记由单个对象粒度提升为 span 粒度。&lt;/li&gt;
&lt;li&gt;每个 span 中，只有首次标记的对象会将整个 span 推入扫描队列。&lt;/li&gt;
&lt;li&gt;GC 扫描阶段批量处理整个 span，极大提升了内存访问局部性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，Green Tea 改进了并行队列管理，采用类似 Go 调度器的工作窃取机制，进一步提高了多核扩展性。&lt;/p&gt;
&lt;h2 id=&#34;-green-tea-gc-实测表现&#34;&gt;⚡ Green Tea GC 实测表现
&lt;/h2&gt;&lt;p&gt;从初步基准来看，Green Tea GC 带来了有选择性的性能提升：&lt;/p&gt;
&lt;p&gt;✅ &lt;strong&gt;Tile38 基准（高扇出树结构）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GC 开销降低约 35%&lt;/li&gt;
&lt;li&gt;吞吐、延迟、内存使用全面优化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;⚠ &lt;strong&gt;bleve-index 基准（低扇出、频繁变异）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象分布散乱，内存局部性差&lt;/li&gt;
&lt;li&gt;Green Tea 与常规 GC 性能相近，有时略低&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结：Green Tea 并非“银弹”，但在内存局部性良好、多核扩展场景下，它展现了明显优势，并为未来 SIMD 加速等硬件优化奠定了基础。&lt;/p&gt;
&lt;h2 id=&#34;-总结&#34;&gt;🏁 总结
&lt;/h2&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;比较项&lt;/th&gt;
          &lt;th&gt;当前 Go GC&lt;/th&gt;
          &lt;th&gt;Green Tea GC&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;标记粒度&lt;/td&gt;
          &lt;td&gt;单对象&lt;/td&gt;
          &lt;td&gt;span（批量）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;内存局部性&lt;/td&gt;
          &lt;td&gt;差，随机跳跃&lt;/td&gt;
          &lt;td&gt;高，同 span 内批量&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;多核扩展性&lt;/td&gt;
          &lt;td&gt;受限&lt;/td&gt;
          &lt;td&gt;改进，采用工作窃取队列&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;性能提升&lt;/td&gt;
          &lt;td&gt;已接近低延迟上限&lt;/td&gt;
          &lt;td&gt;某些场景下 GC 耗时降 35%&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;应用适用范围&lt;/td&gt;
          &lt;td&gt;普通场景&lt;/td&gt;
          &lt;td&gt;内存局部性好、分配密集场景&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;对于追求极限性能的开发者，Green Tea GC 提供了一个值得关注的新方向。想要试验 Green Tea，可以在 Go 1.25+ 开启实验标志体验。&lt;/p&gt;
&lt;p&gt;📝 &lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/73581&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GitHub Issue #73581&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/31684862/how-fast-is-the-go-1-5-gc-with-terabytes-of-ram&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stackoverflow.com/questions/31684862/how-fast-is-the-go-1-5-gc-with-terabytes-of-ram&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/green-tea-gc-golang-%E7%9A%84-zgc/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;本文长期链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果您觉得我的博客对你有帮助，请通过 &lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/index.xml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RSS&lt;/a&gt;订阅我。&lt;/li&gt;
&lt;li&gt;或者在&lt;a class=&#34;link&#34; href=&#34;https://x.com/@piaopiaopig&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;X&lt;/a&gt;上关注我。&lt;/li&gt;
&lt;li&gt;如果您有&lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Medium&lt;/a&gt;账号，能给我个关注嘛？我的文章第一时间都会发布在Medium。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>软件工程师的身份危机 by  Annie Vella</title>
        <link>https://huizhou92.com/zh-cn/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%BA%AB%E4%BB%BD%E5%8D%B1%E6%9C%BA-by-annie-vella/</link>
        <pubDate>Wed, 26 Mar 2025 19:17:56 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%BA%AB%E4%BB%BD%E5%8D%B1%E6%9C%BA-by-annie-vella/</guid>
        <description>&lt;img src="https://images.hxzhouh.com/blog-images/2025/03/d87dba8dde3c2ca307a2dec04a038486.png" alt="Featured image of post 软件工程师的身份危机 by  Annie Vella" /&gt;&lt;p&gt;原文地址： &lt;a class=&#34;link&#34; href=&#34;https://annievella.com/posts/the-software-engineering-identity-crisis/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://annievella.com/posts/the-software-engineering-identity-crisis/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们很多人选择成为软件工程师，是因为我们在亲手&lt;em&gt;创造&lt;/em&gt;事物中找到了自我价值——而非仅仅管理或监督已有事物。&lt;/p&gt;
&lt;p&gt;但这种身份认同正面临挑战。&lt;/p&gt;
&lt;p&gt;人工智能（AI）编码助手不仅仅改变了我们编写软件的方式，它们还在从根本上动摇了我们对自我身份的认知。我们正在从创造者转变为编排者，从建造者转变为监督者。从工程师变成了看起来非常像……管理者的人。&lt;/p&gt;
&lt;p&gt;这种讽刺意味，直击痛点：多年来，我们一直认为软件工程超越了单纯的编码。需求、设计、测试、运维——这些都被认为是我们的专业技能的一部分。然而，行业却将我们推向了相反的方向。我们将这些职责交给了专业人士——产品负责人、架构师、质量工程师、平台工程师——而我们则加倍投入到我们的编码专业知识中。我们成为了代码大师，成为了现代魔法的骄傲使用者。&lt;/p&gt;
&lt;p&gt;现在，就在我们完善这项技能的同时，人工智能正威胁着要夺走它。&lt;/p&gt;
&lt;h2 id=&#34;我们即将失去的快乐&#34;&gt;我们即将失去的快乐
&lt;/h2&gt;&lt;p&gt;让我们坦诚地谈谈这里存在着什么风险。我们中的许多人不仅仅是编写代码——我们&lt;strong&gt;热爱&lt;/strong&gt;编写代码。我们的身份融入到我们精心设计的每一个优雅的解决方案中，融入到我们通过的每一个测试中，融入到我们通过纯粹的逻辑和创造力解决的每一个问题中。这不仅仅关乎职业或技艺，而是我们身份的真实写照。&lt;/p&gt;
&lt;p&gt;想想那些充满成就感的时刻：当你最终追踪到那个困扰生产环境的难以捉摸的bug时，当你计算出如何优化那个缓慢的算法并看到响应时间从几秒降到几毫秒时，当你把一个迷宫般的遗留代码改造成干净且可维护的东西时。这些不仅仅是成就——它们是我们作为工程师的表达。它们是提醒我们为什么选择这条道路的时刻。&lt;/p&gt;
&lt;p&gt;现在想象一下人工智能接管这些精雕细琢的时刻。这些工具的创造者描绘了一幅乐观的图景——他们说我们将花更多的时间在&lt;strong&gt;定义意图&lt;/strong&gt;、&lt;strong&gt;高层架构&lt;/strong&gt;和&lt;strong&gt;系统思考&lt;/strong&gt;上。但仔细听听他们真正想说的是什么：我们将成为监督者而不是创造者，管理者而不是建造者。&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/03/d902c8a0f8ab5ac9bb58e2077195feb7.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;软件工程师正在进化为系统架构师？&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.linkedin.com/posts/ashtom_how-ai-tools-are-reshaping-the-coding-workforce-activity-7303108929264275456-O5v2&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;软件工程师正在转变为系统思考者和高层架构师吗？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这种转变引发了关于我们作为建造者的身份的重要问题：监督是驱动我们的动力吗？是它让我们早上从床上跳起来，渴望解决下一个难题吗？&lt;/p&gt;
&lt;h2 id=&#34;身份转变它已经到来&#34;&gt;身份转变：它已经到来
&lt;/h2&gt;&lt;p&gt;我们现在讨论的并不是什么理论上的未来——而是我们正在经历的现实。当谷歌最近透露人工智能&lt;a class=&#34;link&#34; href=&#34;https://arstechnica.com/ai/2024/10/google-ceo-says-over-25-of-new-google-code-is-generated-by-ai/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;生成了他们超过四分之一的新代码&lt;/a&gt;时，这仅仅是个开始。Y Combinator 的首席执行官 Garry Tan 透露，对于他们大约四分之一的初创公司来说，&lt;a class=&#34;link&#34; href=&#34;https://www.cnbc.com/2025/03/15/y-combinator-startups-are-fastest-growing-in-fund-history-because-of-ai.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;95% 的代码现在是由人工智能编写的&lt;/a&gt;——标志着一个真正意义重大的转变。我自己的硕士研究也揭示了类似的景象：77% 的人花费在编写代码上的时间变少了，几乎一半的人认为我们的核心技能可能会退居二线，让位于提示工程（prompt engineering）。想想这种转变：从设计解决方案到设计提示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://annievella.com/images/prompt-engineering-replace-coding-skills.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;提示工程会取代传统的编码技能吗？&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;提示工程会取代传统的编码技能吗？&lt;/p&gt;
&lt;p&gt;当被问及如何培养提示工程技能时，软件工程师强调要提高沟通技巧。让 AI 按照你想要的方式行事，意味着能够清晰地表达事情——提供恰到好处的上下文，并清楚地描述任务。你与生成式人工智能（Gen AI）沟通得越好，输出结果就越有可能符合你的期望。有些人甚至建议对这些工具&lt;strong&gt;礼貌&lt;/strong&gt;一些，像对待团队成员一样对待它们——好像你在引导另一个人为你做某事。&lt;/p&gt;
&lt;p&gt;这些变化如此深刻，以至于我们正在创造新的术语来描述我们正在成为什么样的人。以 &lt;strong&gt;vibe coding&lt;/strong&gt;（氛围编码，一种依赖 AI 建议进行编码的方式）为例，这是 &lt;a class=&#34;link&#34; href=&#34;https://karpathy.ai/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Andrej Karpathy&lt;/a&gt; 最近在 &lt;a class=&#34;link&#34; href=&#34;https://x.com/karpathy/status/1886192184808149383&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;推特&lt;/a&gt; 上创造的一个词。它捕捉到了我们编写软件方式的深刻转变。&lt;/p&gt;
&lt;p&gt;在这种方式的一端是传统的方式——工匠的方式。我们有目的地编写每一行代码，每一个函数名和架构决策都反映了我们对系统的深刻理解。&lt;/p&gt;
&lt;p&gt;在另一端呢？我们让 AI填补空白，与它的建议“产生共鸣”。我们关注的是“是什么”，而不是“怎么做”。正如 Karpathy 所说：“完全沉浸在氛围中，拥抱指数增长，忘记代码的存在。”&lt;/p&gt;
&lt;p&gt;最后一部分让我们停顿了一下——如果我们忘记了所有关于代码的事情，我们还是工程师吗？&lt;/p&gt;
&lt;p&gt;在最近的一次&lt;a class=&#34;link&#34; href=&#34;https://www.youtube.com/watch?v=HtqxI53h7zM&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;结对编程&lt;/a&gt;会议中，工程领域的思想领袖 &lt;a class=&#34;link&#34; href=&#34;https://itrevolution.com/author/gene-kim/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Gene Kim&lt;/a&gt; 和 &lt;a class=&#34;link&#34; href=&#34;https://steve-yegge.medium.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Steve Yegge&lt;/a&gt; 演示了这在实践中是什么样子的。他们使用 AI 编码助手，将一个 3500 行的遗留 Ruby 脚本移植到 Kotlin——这项任务通常需要一周的时间——仅用了一个小时。人工智能不仅仅翻译了代码，还改进了它，添加了他们多年来一直想要的模块化架构和单元测试，但却无法证明花费的时间是合理的。&lt;/p&gt;
&lt;p&gt;甚至连 DevOps 的教父 &lt;a class=&#34;link&#34; href=&#34;https://www.jedi.be/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Patrick Debois&lt;/a&gt; 也认为这种转变正在重塑我们的身份。在他&lt;a class=&#34;link&#34; href=&#34;https://ainativedev.io/news/the-4-patterns-of-ai-native-dev-overview&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;最近对 AI 原生开发模式的分析&lt;/a&gt;中，他概述了我们工作方式的四个根本性转变：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://annievella.com/images/patrick-debois-four-AI-native-patterns.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Patrick Debois：AI 原生开发的 4种模式&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://ainativedev.io/news/the-4-patterns-of-ai-native-dev-overview&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Patrick Debois：AI 原生开发的 4 种模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这些模式揭示了一个深刻的转变：我们正在从 AI 系统的生产者转变为管理者，从详细的实现转变为表达意图，从交付转变为通过快速实验进行发现，以及从内容创建转变为知识管理。我们的角色正在演变为将创造与组织、构建与监督相结合。&lt;/p&gt;
&lt;p&gt;总的来说，我认为可以公平地说，我们职业身份的本质正在发生核心变化。&lt;/p&gt;
&lt;h2 id=&#34;塑造我们身份的技艺&#34;&gt;塑造我们身份的技艺
&lt;/h2&gt;&lt;p&gt;要理解这种身份危机，我们需要看看编码的技艺对我们产生了多么深刻的影响。从本质上讲，编写代码是关于掌握和控制——我们花费了多年时间来完善的技能。现代编程语言比过去使用的那些语言高级得多，但它们仍然需要深厚的技术理解。如今，很少有开发人员处理指针和内存管理的细节，但我们仍然以了解事物在底层是如何运作的而自豪。即使框架承担了更多繁重的工作，我们仍然保持着我们作为工匠的身份，我们对自己的工具了如指掌。&lt;/p&gt;
&lt;p&gt;今天的编程更多的是以创造性的方式将 API、框架和库拼接在一起，以构建有意义的东西。事实上，谷歌最近的一项研究表明，软件工程中的&lt;strong&gt;创造力&lt;/strong&gt;主要集中在&lt;a class=&#34;link&#34; href=&#34;https://ieeexplore.ieee.org/document/10445159&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;巧妙的重用而不是纯粹的创新&lt;/a&gt;这一概念上。这对我来说很有意义——我经常评论说，我们现在真的都只是“集成”工程师。&lt;/p&gt;
&lt;p&gt;尽管如此，我们仍然以了解构建某些东西所需的所有奇怪语法而感到自豪。这就像一种只有我们才能理解的秘密语言。精通一门编程语言使你能够灵活驾驭、精准操控它。它非常详细——仅仅一个错误的字符就会破坏整个程序，而且可能需要大量的时间和耐心才能让它按照你想要的方式运行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先，必须完美地执行。在这方面，计算机也类似于传说中的魔法。如果一个字符，一个停顿，咒语的形式不严格正确，魔法就不会起作用。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;——弗雷德里克·P·布鲁克斯，《人月神话》，第一章，Addison-Wesley，1975&lt;/p&gt;
&lt;p&gt;其他 99% 的人认为我们理解代码是魔术，而且确实，可能需要多年的刻意练习才能掌握它。那些掌握不止一种编程语言的人有幸被称为“多面手”。我们中的许多人以编写干净、优雅的代码而感到自豪。我们热情地争论不同的风格和最佳实践，而且常常对此过于认真。&lt;/p&gt;
&lt;h2 id=&#34;一位不甘心的管理者自述&#34;&gt;一位不甘心的管理者自述
&lt;/h2&gt;&lt;p&gt;让我分享一个关于身份演变的故事，它可能会引起共鸣。&lt;/p&gt;
&lt;p&gt;在做了十年个人贡献者之后，我遇到了技术职业道路上臭名昭著的天花板。“高级首席软件工程师”——这就是技术职业道路的尽头。当时 Staff+ Engineering（资深工程师之上的职级）还不存在，而我所在公司的唯一架构师职位也已有人选。我面临着一个会改变我身份的选择：继续做一名建造者，还是成为一名监督者。&lt;/p&gt;
&lt;p&gt;我选择了管理。不情愿地。这就是这条路引导我的方向。我告诉自己这仍然是工程，只是在一个不同的层面上。管理系统与管理人员并没有什么不同。我仍然可以在其他任务之间继续编写代码。&lt;/p&gt;
&lt;p&gt;听起来很熟悉吗？这其中的相似之处令人惊叹。正如我不得不将直接解决问题的工作换成会议和文档工作一样，我们现在也被要求用提示工程来代替编码。那些定义我们作为工程师的技能——掌握语法、优雅地构建我们的代码、捕获和处理边缘情况、调试复杂问题——正在被降级到人工智能。相反，我们被告知要专注于听起来非常像管理的技能：清晰的沟通、系统思考、问题定义。&lt;/p&gt;
&lt;p&gt;但这里没有人谈论的是：身份危机。当你意识到你不再用自己的双手建造东西时的那种深深的失落感。当你的技术专长变得不如你“管理”工具的能力重要时。当你的技能变成监督时。&lt;/p&gt;
&lt;p&gt;组织人工智能能给我们带来同样的身份认同感吗？一种作为建造者、创造者、问题解决者的感觉？&lt;/p&gt;
&lt;h2 id=&#34;当机器挑战我们的身份时&#34;&gt;当机器挑战我们的身份时
&lt;/h2&gt;&lt;p&gt;现在，我们身份危机的根源变得清晰起来。我们花费多年时间完善的技能——那些给予我们目标、意义和自豪感的技能——现在正被机器以更快、更便宜和更大规模的方式完成。当然，质量不如你手写的代码（但目前而言）。但是现在编写代码的速度是惊人的，企业都在争先恐后地参与进来。&lt;/p&gt;
&lt;p&gt;这就是一线希望出现的地方。还记得那种讽刺吗——我们是如何将更广泛的技能方面交给专家的？人工智能正在推动我们重新获得我们曾经知道的东西：软件工程超越了单纯的编码。这个核心真理依然存在——最终，软件工程是关于解决问题、创造解决方案、构建重要的东西。&lt;/p&gt;
&lt;p&gt;这些更广泛的技能——Addy Osmani 在他关于&lt;a class=&#34;link&#34; href=&#34;https://addyo.substack.com/p/beyond-the-70-maximizing-the-human&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;人工智能辅助编码中人类 30% 的文章&lt;/a&gt;中称之为“持久的工程技能”——一直将伟大的工程师与优秀的工程师区分开来。沟通、大局观思考、处理歧义——这些在人工智能驱动的世界中变得更加重要。&lt;/p&gt;
&lt;p&gt;然而，这种对更广泛技能的强调在我们的社区中引发了争论。对于某些人来说，这听起来很像重新包装过的管理。而且他们并没有完全错——最近的一篇 &lt;a class=&#34;link&#34; href=&#34;https://www.cio.com/article/3509174/ai-coding-assistants-wave-goodbye-to-junior-developers.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CIO 文章&lt;/a&gt; 证实，开发团队已经在进行重组，以专注于监督而不是创造。这篇文章设想未来的团队由一个产品经理、一个用户体验设计师和一个主要使用人工智能生成原型的软件架构师组成。这些架构师或高级开发人员必须“理解内容……了解客户是谁以及我们试图实现什么”——这是被重新包装成技术工作的经典管理职责。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://annievella.com/images/addy-osmani-durable-engineering-skills.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;披着技术外衣的管理&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;披着技术外衣的管理&lt;/p&gt;
&lt;p&gt;这种演变引发了关于我们作为工程师的身份的根本性问题：随着传统职业阶梯的转变，下一代软件工程师将如何发展他们的技能？我们如何在拥抱这些新工具的同时，保留塑造我们职业的深厚技术理解和技能？也许最令人不安的是——随着人工智能能力的指数级进步，我们作为工匠的角色是否会像工业革命期间的手工织布工一样过时？&lt;/p&gt;
&lt;h2 id=&#34;前进的道路&#34;&gt;前进的道路
&lt;/h2&gt;&lt;p&gt;也许答案不在于抵制这种转变，而在于通过历史的视角来理解它。这些身份危机——这些通过我们的工作来定义我们自己的根本性转变——并不是什么新鲜事。它们是技术重塑一个职业时重复出现的一种模式的一部分。&lt;/p&gt;
&lt;p&gt;在&lt;a class=&#34;link&#34; href=&#34;https://www.britannica.com/story/the-rise-of-the-machines-pros-and-cons-of-the-industrial-revolution&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;工业革命&lt;/a&gt;期间，工匠们也面临着类似的危机。他们经过几代人磨练的传统技能正在被机器取代。但接下来发生的事情令人着迷：许多人适应了，成为了可以修理和改进这些威胁要取代他们的机器的专业人士。其他人则找到了应用他们对材料和工艺的深刻理解来改进整个工厂运营的方法。&lt;/p&gt;
&lt;p&gt;如果我们把这种类比应用到我们的人工智能时代，就会出现一条类似的道路。软件工程的核心——解决问题和创造价值——仍然没有改变。我们的工具正在发展，随之而来的是有效使用它们所需的技能。&lt;/p&gt;
&lt;p&gt;问题不在于我们是否会成为机器的管理者——而在于我们是否能在这种技能的演变中找到同样的满足感。&lt;/p&gt;
&lt;h2 id=&#34;工程师的困境&#34;&gt;工程师的困境
&lt;/h2&gt;&lt;p&gt;那么，这会把我们带到哪里？我们是否注定要成为人工智能智能体的监督者，而不是代码的编写者？这是一个应该抵制还是拥抱的未来？&lt;/p&gt;
&lt;p&gt;真相，一如既往，是细致入微的。正如一些工程师自然而然地倾向于管理，而另一些工程师则更喜欢保持亲力亲为一样，我们可能会看到在如何与人工智能互动方面出现类似的范围。有些人会擅长组织人工智能系统，专注于高层设计，并使这些系统更高效和可靠——指挥一场技术交响乐，而不是进行独奏。另一些人则会在人类专业知识仍然至关重要的领域找到自己的使命——可能是在安全敏感的应用程序、人工智能缺乏训练数据的新领域，或性能和可靠性至关重要的系统中。关键不是抵制这种演变，而是在其中找到自己的位置。&lt;/p&gt;
&lt;p&gt;显而易见的是，“软件工程师”的定义正在扩大，而不是缩小。使某人有价值的技能正在多样化。这既带来了挑战，也带来了机遇。&lt;/p&gt;
&lt;p&gt;对于那些热爱编码技能的人来说，这种转变可能会让人感到威胁。但请记住，人工智能工具仍然只是工具。它们不了解代码背后的“为什么”、业务背景或所服务的人类需求。它们无法真正意义上进行创新，至少目前还不能。而且据我们所知，它们无法&lt;strong&gt;感受到&lt;/strong&gt;解决复杂问题的满足感或创造新事物的乐趣。&lt;/p&gt;
&lt;p&gt;也许在这个新领域中最有价值的技能不是提示工程或系统架构，而是&lt;strong&gt;适应性&lt;/strong&gt;——愿意进化、学习新技能，并在一个快速变化的领域中找到自己独特的位置。&lt;/p&gt;
&lt;h2 id=&#34;光明的一面&#34;&gt;光明的一面
&lt;/h2&gt;&lt;p&gt;尽管存在这些挑战，但我们需要承认一些重要的事情：这些人工智能工具可以非常强大。借助像&lt;a class=&#34;link&#34; href=&#34;https://codeium.com/windsurf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Windsurf&lt;/a&gt; 和 &lt;a class=&#34;link&#34; href=&#34;https://www.cursor.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Cursor&lt;/a&gt; 这样将软件开发提升到一个全新水平的自主智能体集成开发环境（agentic IDE），就像拥有一个始终在你身边的支持性结对编程伙伴一样，随时准备帮助你解决以前可能看起来令人望而却步的问题。&lt;/p&gt;
&lt;p&gt;对于初级开发人员或我们这些可能感到有些生疏的人来说，人工智能助手可以增强信心——在你盯着一个空白文件时帮助你入门，在你犹豫不决时验证你的方法，或者以一种对你有意义的方式解释复杂的概念。对于经验丰富的开发人员来说，它们就像拥有一个不知疲倦的助手，可以处理日常任务，而你可以专注于问题的更具挑战性的方面。&lt;/p&gt;
&lt;p&gt;如今，我们能迅速搭建原型、探索各种方法，甚至在几分钟内掌握新技术——这速度着实令人震撼。可能需要数周的研究和反复试验才能完成的事情通常可以在几小时甚至几分钟内完成。这就像拥有超能力一样——能够放大我们的能力，并比以往更快地将我们的想法变成现实。&lt;/p&gt;
&lt;h2 id=&#34;现实检验&#34;&gt;现实检验
&lt;/h2&gt;&lt;p&gt;但是，能力越大，责任越大。最近一项全面的 &lt;a class=&#34;link&#34; href=&#34;https://arc.dev/talent-blog/impact-of-ai-on-code/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GitClear 研究&lt;/a&gt; 分析了 2.11 亿行代码，揭示了一些令人担忧的趋势，因为人工智能代码生成工具变得越来越普遍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;复制粘贴的代码增加了 17.1%，这是人工智能辅助的代码重复首次超过重构（移动）的代码。&lt;/li&gt;
&lt;li&gt;重复代码块增加了 8 倍，现在有 6.66% 的提交包含重复的代码段。&lt;/li&gt;
&lt;li&gt;代码改动增加了 26%，所有代码更改中有 5.7% 在两周内被修改或删除。&lt;img src=&#34;https://annievella.com/images/gitclear-2025-trends-in-code-changes.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;GitClear：代码更改趋势&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://arc.dev/talent-blog/impact-of-ai-on-code/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GitClear：代码更改趋势&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虽然我们生成代码的速度比以往任何时候都快，但我们也花费更多的时间来修复人工智能生成的错误并处理更难维护的代码。这不仅仅是速度问题——而是关于编写可持续、可维护软件的技能。&lt;/p&gt;
&lt;h2 id=&#34;隐藏的身份危机&#34;&gt;隐藏的身份危机
&lt;/h2&gt;&lt;p&gt;然而，在这些表面上的变化之下，隐藏着一个更深层次的挑战——一个触及我们作为工程师的核心的挑战。新兴的人机协作领域正在揭示关于我们未来的令人不安的真相。&lt;a class=&#34;link&#34; href=&#34;https://www.sciencedirect.com/science/article/pii/S2352250X24000502&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2024 年的一项研究&lt;/a&gt;表明，当人类和人工智能一起工作时，结果往往达不到预期。不是因为人工智能缺乏能力，而是因为信任在机器和人类之间的运作方式不同。&lt;/p&gt;
&lt;p&gt;我们与人工智能建立信任的方式与我们与人类团队成员建立信任的方式不同。&lt;/p&gt;
&lt;p&gt;对于人类来说，信任是通过共同的成功逐渐建立起来的。一起解决的每一个问题都会加强这种联系。即使是处理得当的失败也能加深信任。对于人工智能来说，信任通常开始时很高，但会迅速瓦解。&lt;/p&gt;
&lt;p&gt;每一个不正确的回答、每一个幻觉般的错误修复、每一次放错地方的信心都会削弱我们对机器的信任。与人类关系中信任通常会随着时间的推移而增长不同，人工智能的信任通常会在早期达到顶峰并下降。&lt;/p&gt;
&lt;p&gt;当信任消失时，生产力也会下降。&lt;/p&gt;
&lt;p&gt;该研究揭示了原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;人工智能在解释我们的意图方面存在固有的不可预测性&lt;/li&gt;
&lt;li&gt;它缺乏使人类协作流畅的上下文意识&lt;/li&gt;
&lt;li&gt;它的决策通常缺乏透明度，因此一旦失去信任就很难重建&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些挑战反映了我们许多人在转变为技术领导者时所经历的事情。正如新的工程经理必须学会信任他们团队的工作而无需自己动手一样，我们现在也面临着与人工智能类似的转变——学会指导和验证，而不是自己编写每一行代码。&lt;/p&gt;
&lt;p&gt;现实是严峻的：尽管人工智能具有原始能力，但团队在有人工智能的情况下通常比没有人工智能的情况下表现更差。正如团队的生产力在无效的领导下会受到影响一样，当我们不了解如何使用我们的人工智能工具时，我们的效率也会降低。&lt;/p&gt;
&lt;h2 id=&#34;重塑你的身份&#34;&gt;重塑你的身份
&lt;/h2&gt;&lt;p&gt;从我作为一名不情愿的经理的历程以及我对这种人工智能转型的研究中，我看到了三种我们可以保留我们作为建造者身份的方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;抵制&lt;/strong&gt;——有些人会选择专注于人类创造力和深厚技术专业知识仍然至关重要的领域&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;适应&lt;/strong&gt;——另一些人会拥抱人工智能编排，成为一种新型技术交响乐的指挥家3. &lt;strong&gt;平衡&lt;/strong&gt;——还有许多人，像我一样，会寻求一条中间道路——使用人工智能来完成日常任务，同时保留直接解决问题的乐趣&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然后我意识到一个改变我观点的事实：&lt;em&gt;我们不必只选择一条道路&lt;/em&gt;。&lt;/p&gt;
&lt;h2 id=&#34;身份的钟摆&#34;&gt;身份的钟摆
&lt;/h2&gt;&lt;p&gt;也许我们身份危机的答案在于&lt;a class=&#34;link&#34; href=&#34;https://charity.wtf/2017/05/11/the-engineer-manager-pendulum/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;工程师/经理的钟摆&lt;/a&gt;。我自己在这些角色之间转换的经历教会了我一些关于身份的关键知识：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管理并没有取代我的工程师身份——它扩展了它&lt;/li&gt;
&lt;li&gt;回归亲力亲为的工作并不是倒退——而是身份的更新&lt;/li&gt;
&lt;li&gt;钟摆的摆动本身成为了我的一部分——适应性强、不断成长、不断进化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;就在那时，我突然意识到：&lt;em&gt;这正是我们需要的人工智能时代的模型&lt;/em&gt;。如果我们不必被迫成为永久的“人工智能经理”，而是可以在以下角色之间切换，那会怎么样呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;深入的技术工作，我们可以直接编写和完善代码&lt;/li&gt;
&lt;li&gt;战略编排，我们可以指导人工智能系统&lt;/li&gt;
&lt;li&gt;将这两种方法结合起来的创造性问题解决&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种平衡的方法与我从其他工程师那里听到的声音产生了深刻的共鸣。我的研究表明了一个明确的信息：保持强大的工程基础比以往任何时候都更加重要。我们需要深厚的技术知识才能有效地审查、验证和调整人工智能生成的代码——因为它通常不太正确。当被问及他们对人工智能编码助手的担忧时，软件工程师将代码质量和安全性排在工作保障之上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://annievella.com/images/ai-concerns.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;对人工智能编码助手的主要担忧&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;软件工程师对人工智能编码助手的主要担忧&lt;/p&gt;
&lt;p&gt;这告诉我一些深刻的事情：我们把自己视为工程卓越的守护者，确保人工智能生成的解决方案遵循可靠的软件工程原则。我们并不是想把我们的专业知识委托给人工智能——我们正在进化以新的方式应用我们的技能。&lt;/p&gt;
&lt;h2 id=&#34;你的行动&#34;&gt;你的行动
&lt;/h2&gt;&lt;p&gt;当我们驾驭这种转型时，一个基本的真理浮出水面：我们的身份危机实际上根本不是关于人工智能的。对人机协作的研究、与管理转型的相似之处、角色的钟摆——它们都指向更深层次的东西。除了在建造者或监督者之间做出选择之外，还存在着我们作为创造者的核心。&lt;/p&gt;
&lt;p&gt;现在我们又回到了原点：人工智能并没有抢走我们的工作，而是给了我们一个机会来重新获得我们交给专家的那些更广泛的角色方面。回到软件工程不仅仅意味着编写代码的时代。当它意味着理解整个问题空间时，从用户需求到业务影响，从系统设计到卓越运营。&lt;/p&gt;
&lt;p&gt;钟摆的比喻在这里为我们提供了智慧。正如我们中的许多人在工程和管理角色之间摇摆一样，我们可以以类似的方式拥抱人工智能的流动性。有些时候，我们会深入研究代码，体验设计优雅解决方案的快感。其他时候，我们会退一步来指导人工智能系统——不是作为监督者，而是作为了解他们技能的每一个部分的大师级建造者。就像工业革命的工人成为优化改变他们技能的机器的专家一样，我们可以掌握这些人工智能系统——使它们成为我们创造力的工具，而不是我们创造力的替代品。&lt;/p&gt;
&lt;p&gt;在人工智能时代，最重要的是保留我们本质的东西：构建事物、解决难题、使某些东西完全正确运行的纯粹乐趣。我们的工程卓越不仅仅是验证人工智能的工作——它源于对系统如此熟悉，以至于我们可以塑造它们、改进它们、改变它们。&lt;/p&gt;
&lt;p&gt;选择不是人工智能是否会改变我们的行业——它已经在改变了。真正的选择是我们如何与它一起进化。我们是会坚持对成为一名工程师的过时观念吗？还是会重新获得我们的技能，不是作为单纯的编码员，而是作为人工智能增强型系统的大师级建造者？&lt;/p&gt;
&lt;p&gt;钟摆正在摆动——你会坚守阵地，还是随之而动？&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%BA%AB%E4%BB%BD%E5%8D%B1%E6%9C%BA-by-annie-vella/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;本文长期链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果您觉得我的博客对你有帮助，请通过 &lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/index.xml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RSS&lt;/a&gt;订阅我。&lt;/li&gt;
&lt;li&gt;或者在&lt;a class=&#34;link&#34; href=&#34;https://x.com/@piaopiaopig&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;X&lt;/a&gt;上关注我。&lt;/li&gt;
&lt;li&gt;如果您有&lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Medium&lt;/a&gt;账号，能给我个关注嘛？我的文章第一时间都会发布在Medium。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>【译】：gRPC丑陋的部分</title>
        <link>https://huizhou92.com/zh-cn/p/%E8%AF%91grpc%E4%B8%91%E9%99%8B%E7%9A%84%E9%83%A8%E5%88%86/</link>
        <pubDate>Fri, 14 Mar 2025 09:59:10 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/%E8%AF%91grpc%E4%B8%91%E9%99%8B%E7%9A%84%E9%83%A8%E5%88%86/</guid>
        <description>&lt;p&gt;原文链接：https://kmcd.dev/posts/grpc-the-ugly-parts/&lt;br&gt;
这篇文章是&lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/series/grpc-the-good-and-the-bad/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gRPC：好与坏&lt;/a&gt;系列的一部分。&lt;/p&gt;
&lt;p&gt;gRPC无疑是微服务领域中的一把利器，它带来了效率和性能上的优势，但gRPC也有其丑陋的一面。作为一个在gRPC上花费了大量时间的人，我想揭示这项技术的一些不那么美好的方面。我已经讨论过gRPC的&lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/grpc-the-good-parts&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;优点&lt;/a&gt;和&lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/grpc-the-bad-parts&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;缺点&lt;/a&gt;，现在让我们来谈谈它的丑陋之处。&lt;/p&gt;
&lt;h2 id=&#34;代码生成&#34;&gt;代码生成
&lt;/h2&gt;&lt;p&gt;首先，我不得不说一下从&lt;code&gt;protobuf&lt;/code&gt;生成的代码有多么丑陋。这些代码通常很冗长、复杂且难以阅读。尽管它并不是为了手动编辑而设计的，但这会影响代码的可读性和可维护性，尤其是在将gRPC集成到大型项目中时。最近在大多数语言中，这种情况已经有所改善，但仍然存在一些粗糙的地方。&lt;/p&gt;
&lt;h3 id=&#34;语言特定的怪癖&#34;&gt;语言特定的怪癖
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;protobuf&lt;/code&gt;和&lt;code&gt;gRPC&lt;/code&gt;的初始实现常常偏离语言特定的规范，尤其是在HTTP处理方面。这在一定程度上源于强制支持&lt;code&gt;HTTP/2&lt;/code&gt;的决定，这一决定后来被证明限制了&lt;code&gt;gRPC&lt;/code&gt;在前端的应用。我们现在从&lt;code&gt;gRPC-Web&lt;/code&gt;中了解到，&lt;code&gt;trailer&lt;/code&gt;并不是像gRPC这样的协议的硬性要求。在这一决定之后，我们现在需要改进&lt;code&gt;protobuf&lt;/code&gt;和&lt;code&gt;gRPC&lt;/code&gt;的语言实现，使其更符合每种语言的习惯。&lt;/p&gt;
&lt;p&gt;对于Go语言来说，避免使用&lt;code&gt;net/http&lt;/code&gt;包是一个艰难的决定，因为这使得在与其他类型的HTTP API一起使用gRPC端点时变得更加困难，并且难以复用HTTP中间件。他们最终在grpc-go中添加了一个&lt;a class=&#34;link&#34; href=&#34;https://pkg.go.dev/google.golang.org/grpc#Server.ServeHTTP&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;ServeHTTP()&lt;/code&gt;&lt;/a&gt;接口，作为使用Go标准库中的HTTP服务器的一种实验性方法，但使用这种方法会导致&lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/benchmarking-go-grpc/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;显著的性能损失&lt;/a&gt;。也许他们这样做是出于性能考虑？如果是这样，这无疑是一个将gRPC与Go生态系统其他部分割裂的权衡。&lt;/p&gt;
&lt;p&gt;有时，语言特定的怪癖实际上会影响你如何设计protobuf类型。如果你遵循&lt;a class=&#34;link&#34; href=&#34;https://buf.build/docs/best-practices/style-guide&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Buf&lt;/a&gt;的风格建议，枚举的名称应该以枚举名的大写蛇形版本作为前缀，就像这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FooBar&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;FOO_BAR_UNSPECIFIED&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;FOO_BAR_FIRST_VALUE&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;FOO_BAR_SECOND_VALUE&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这在&lt;a class=&#34;link&#34; href=&#34;https://buf.build/docs/lint/rules#enum_value_prefix&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;buf的lint规则描述&lt;/a&gt;中有更好的解释，但这种风格指南之所以如此，是因为C++的枚举作用域规则，这使得在同一包中无法有两个具有相同枚举值名称的枚举值。虽然这种约定源于C++的作用域规则，但它影响了你应该如何设计所有的protobuf文件。为什么枚举内部的作用域不足以让C++编译器生成唯一的名称？为什么这种缺陷会影响风格指南，并进而影响所有目标语言？对我来说，这有点丑陋，因为某些语言实现的怪癖以不直观的方式冒了出来。&lt;/p&gt;
&lt;h3 id=&#34;生成的代码甚至不够快&#34;&gt;生成的代码甚至不够快
&lt;/h3&gt;&lt;p&gt;生成代码的一个好处是，你可以生成一些正常人不会写的代码，以获得一些性能优化。然而，如果你查看一些从protobuf生成的代码，你会发现大量使用了运行时反射。为什么？在某种程度上，我是在说生成的代码&lt;strong&gt;不够丑陋&lt;/strong&gt;。让我们看一个具体的例子。请注意，这将是一个非常Go特定的部分，因为我大部分关于protobuf的经验都是在Go中。然而，相同的策略已经应用于大多数语言。&lt;/p&gt;
&lt;p&gt;让我们来看一个Go中的超级简单示例。以下是protobuf：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Hello&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这是由protoc生成的类型：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Hello&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;         &lt;span class=&#34;nx&#34;&gt;protoimpl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;MessageState&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;sizeCache&lt;/span&gt;     &lt;span class=&#34;nx&#34;&gt;protoimpl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;SizeCache&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;unknownFields&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;protoimpl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;UnknownFields&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;Name&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`protobuf:&amp;#34;bytes,1,opt,name=name,proto3&amp;#34; json:&amp;#34;name,omitempty&amp;#34;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// With these methods, contents are stripped&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Reset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ProtoMessage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ProtoReflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;protoreflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Message&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;实际上，并没有为这个类型定义专门的&lt;code&gt;Marshal()&lt;/code&gt;或&lt;code&gt;Unmarshal()&lt;/code&gt;函数。这意味着序列化是通过运行时反射来实现的。反射通常被认为较慢，因为它&lt;strong&gt;确实&lt;/strong&gt;较慢。我觉得奇怪的是，没有为Go生成优化的、类型特定的序列化代码。话虽如此，你可以通过使用一个名为&lt;a class=&#34;link&#34; href=&#34;https://github.com/planetscale/vtprotobuf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vtprotobuf&lt;/a&gt;的单独protoc插件来获得这一点，该插件将为每个protobuf类型生成专门的marshal和unmarshal函数。它还允许使用类型特定的内存池，这也有助于减少分配并提高性能。根据我的&lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/benchmarking-go-grpc/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;测试&lt;/a&gt;，只需添加&lt;code&gt;vtprotobuf&lt;/code&gt;而不做任何代码更改，就可以将性能提高2-4%。这基本上是“免费”的2-4%，所以我觉得很奇怪，这竟然不是标准编译器的一部分。&lt;a class=&#34;link&#34; href=&#34;https://github.com/sudorandom/go-grpc-bench/blob/v0.0.1/gen/flex_vtproto.pb.go#L573&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;你可能不喜欢它，但这就是峰值性能的样子&lt;/a&gt;。无论如何，这个项目需要更多的关注和支持。&lt;/p&gt;
&lt;p&gt;请注意，还有其他一些项目声称在标准protobuf库的基础上取得了惊人的性能提升。他们确实通过做出一些权衡来实现这些性能提升，但很多时候，额外的复杂性是值得的。&lt;/p&gt;
&lt;p&gt;你可能会读到这一部分并想：“好吧，这会增加生成的代码量，增加二进制文件或包的大小，在某些环境中，你可能不希望这样。”这是事实，这就是为什么protobuf有一个&lt;code&gt;optimize_for&lt;/code&gt;选项，所以你可以注释以下之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;option optimize_for = SPEED;&lt;/code&gt; - 更冗长、更快的代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;option optimize_for = CODE_SIZE;&lt;/code&gt; - 更小的代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;option optimize_for = LITE_RUNTIME;&lt;/code&gt; - 旨在在较小的运行时上运行，省略了描述符和反射等功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请参阅&lt;a class=&#34;link&#34; href=&#34;https://protobuf.dev/programming-guides/proto3/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方protobuf文档&lt;/a&gt;中关于&lt;code&gt;optimize_for&lt;/code&gt;的完整描述。虽然这些选项存在，但它们实际上并没有用于大多数目标语言。将来，我完全希望看到大部分&lt;code&gt;vtprotobuf&lt;/code&gt;被整合到Go的标准protobuf编译器中，并在&lt;code&gt;optimize_for = SPEED&lt;/code&gt;时使用。将类似&lt;code&gt;vtprotobuf&lt;/code&gt;的优化整合到标准protobuf编译器中，可以为Go带来显著的性能提升，其他语言也可能存在类似的机会。&lt;/p&gt;
&lt;h2 id=&#34;必填字段&#34;&gt;必填字段
&lt;/h2&gt;&lt;p&gt;Protobuf的维护者在必填字段方面学到了一些艰难的教训。他们觉得自己犯了一个严重的错误，以至于他们推出了一个新版本的protobuf，即proto3，只是为了从规范中删除必填字段。为什么？“必填字段有害”宣言的作者在&lt;a class=&#34;link&#34; href=&#34;https://news.ycombinator.com/item?id=18190005&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;一篇冗长的Hacker News评论&lt;/a&gt;中谈到了这一点，但重要的是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现实世界的实践也表明，许多最初被认为是“必填”的字段随着时间的推移往往会变成可选的，因此有了“必填字段有害”的宣言。在实践中，你希望将所有字段声明为可选的，以便为变化提供最大的灵活性。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;这一点在&lt;a class=&#34;link&#34; href=&#34;https://protobuf.dev/programming-guides/dos-donts/#add-required&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方protobuf风格指南&lt;/a&gt;中得到了呼应，他们建议添加注释来指示某个字段是必填的。如果我们讨论的是将消息从A传递到B，我完全同意这种思路。然而，仅仅因为某些字段被认为是“必填”的会随着时间的推移而变化，并不意味着必填字段不存在。仍然需要代码来强制执行这一要求，老实说，我不想编写这些代码。因此，我认为在不编写大量空检查的情况下处理必填字段的最佳方法是使用&lt;a class=&#34;link&#34; href=&#34;https://github.com/bufbuild/protovalidate&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;protovalidate&lt;/a&gt;或类似的库，这些库具有protobuf选项，允许你注释哪些字段是必填的。然后在服务器和/或客户端上有代码可以使用库来强制执行这些要求。在我看来，这兼具了两者的优点：你仍然可以以不会完全破坏消息完整性的方式声明必填字段。&lt;/p&gt;
&lt;p&gt;我不喜欢这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;User&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;int32&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// required.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我喜欢这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;User&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;int32&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf.validate.field&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;required&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我是&lt;a class=&#34;link&#34; href=&#34;https://github.com/bufbuild/protovalidate&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;protovalidate&lt;/a&gt;的忠实粉丝，我已经多次使用它并为其做出了贡献。一般来说，我认为protobuf字段的&lt;a class=&#34;link&#34; href=&#34;https://protobuf.dev/programming-guides/proto3/#customoptions&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;自定义选项&lt;/a&gt;是protobuf的一个未被充分利用的超能力。&lt;/p&gt;
&lt;h2 id=&#34;难以入门&#34;&gt;难以入门
&lt;/h2&gt;&lt;p&gt;尽管gRPC具有不可否认的优势，但其学习曲线可能很陡峭。对于新手来说，开始使用&lt;code&gt;protobuf&lt;/code&gt;、理解工具链以及设置必要的基础设施可能会让人望而生畏，这使得初始采用的障碍比使用更简单的基于JSON的API更高。为什么它如此陡峭？嗯，它在大多数语言中引入了非惯用的工具链。有一些语言支持的例子使得protobuf生成变得无缝。&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/en-us/aspnet/core/grpc/basics&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Grpc.Tools&lt;/a&gt; for &lt;code&gt;.NET&lt;/code&gt;就是一个闪亮的例子，展示了如何将protobuf工具链更紧密地集成到标准语言工具链中。我们需要更多这样的例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kmcd.dev/posts/grpc-the-ugly-parts/learning-curve.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;当许多使用和依赖protobuf和gRPC的人积极不希望gRPC扩展到前端，并认为推动这一方向会导致不了解情况的人侵入后端领域时，陡峭的学习曲线并没有帮助，他们认为只有他们足够聪明才能在后端工作。这是精英主义的守门行为，不幸的是，这种行业普遍存在。我相信gRPC在Web前端中与在微服务中一样有其地位。&lt;/p&gt;
&lt;p&gt;我通过帮助其他人使用protobuf学到了很多。你可能会在&lt;a class=&#34;link&#34; href=&#34;https://buf.build/links/slack&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Buf的Slack频道&lt;/a&gt;或相关讨论中看到我，因为我确实从中受益匪浅。许多文章的想法直接来自于在那里回答问题。如果我看到某个问题出现的频率足够高，我可能会写一篇文章来讨论它。我认为protobuf和gRPC社区需要更多这种态度。&lt;/p&gt;
&lt;p&gt;我相信陡峭的学习曲线（可以通过工具链来缓解），加上一些后端开发者的抵制（可以通过……同理心来缓解？），已经减缓了它在Web开发中的广泛采用。&lt;/p&gt;
&lt;h2 id=&#34;grpc有其历史&#34;&gt;gRPC有其历史
&lt;/h2&gt;&lt;p&gt;gRPC最初专注于微服务，并且与HTTP/2的紧密联系阻碍了它在Web开发中的广泛采用。即使有了&lt;a class=&#34;link&#34; href=&#34;https://grpc.io/blog/state-of-grpc-web/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gRPC-Web的出现&lt;/a&gt;，仍然有一种看法认为它在前端生态系统中并不是一等公民。与&lt;a class=&#34;link&#34; href=&#34;https://tanstack.com/query/latest&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TanStack Query&lt;/a&gt;等流行前端库缺乏强大的集成进一步巩固了这种看法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kmcd.dev/posts/grpc-the-ugly-parts/bad-blood.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;我认为通过改进工具链，有真正的机会让更多前端开发者对gRPC感到兴奋。目前，整个行业正在围绕“前端”和“后端”之间的界限进行一场巨大的讨论，我认为无论结果如何，我们都会看到更多使用gRPC的TypeScript代码。&lt;/p&gt;
&lt;h2 id=&#34;grpc中的g&#34;&gt;gRPC中的“g”
&lt;/h2&gt;&lt;p&gt;虽然&lt;a class=&#34;link&#34; href=&#34;https://grpc.io/docs/what-is-grpc/faq/#what-does-grpc-stand-for&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gRPC项目声称&lt;/a&gt; gRPC中的“g”是一个&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Backronym&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;反向缩略词&lt;/a&gt;，代表“gRPC”，但它最初代表Google，因为是Google开发并发布了protobuf和gRPC。&lt;br&gt;
&lt;img src=&#34;https://kmcd.dev/posts/grpc-the-ugly-parts/google.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;google 的墓碑&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;关于Google对gRPC和protobuf的长期承诺，始终存在一个悬而未决的问题。他们会继续投资于这些开源项目，还是会在优先级发生变化时突然撤资？请记住，Google&lt;a class=&#34;link&#34; href=&#34;https://techcrunch.com/2024/05/01/google-lays-off-staff-from-flutter-dart-python-weeks-before-its-developer-conference/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;最近裁掉了Flutter、Dart和Python团队的大部分成员&lt;/a&gt;。Protobuf社区正在发展，但它是否足够自给自足以应对这种情况？&lt;/p&gt;
&lt;h2 id=&#34;它尚未完成&#34;&gt;它尚未完成
&lt;/h2&gt;&lt;p&gt;其他人说gRPC不成熟，不是因为它的年龄，而是因为它的生态系统发展程度。我倾向于同意，因为它缺少我期望在一个成熟生态系统中看到的功能和工具。&lt;/p&gt;
&lt;h3 id=&#34;缺少包管理器&#34;&gt;缺少包管理器
&lt;/h3&gt;&lt;p&gt;在没有专门工具的情况下，跨多个项目或仓库共享protobuf定义是一个持续的挑战。虽然像&lt;a class=&#34;link&#34; href=&#34;https://bazel.build/reference/be/protocol-buffer&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Bazel&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://www.pantsbuild.org/2.21/docs/go/integrations/protobuf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Pants&lt;/a&gt;和&lt;a class=&#34;link&#34; href=&#34;https://buf.build/product/bsr&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Buf的BSR&lt;/a&gt;这样的解决方案存在，但我在“现实世界”中使用protobuf的经验……参差不齐。有一些由Google开发的开源项目，它们使用bash脚本拼凑在一起，在手动调用&lt;code&gt;protoc&lt;/code&gt;之前下载依赖项。想象一下，一个编程语言没有管理依赖项的解决方案。这太疯狂了。我认为&lt;a class=&#34;link&#34; href=&#34;https://grpc.io/blog/bazel-rules-protobuf/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Bazel&lt;/a&gt;和&lt;a class=&#34;link&#34; href=&#34;https://buf.build/docs/ecosystem/cli-overview&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Buf工具链&lt;/a&gt;很好地解决了这个问题，但我只是感到沮丧，我遇到的每个使用protobuf的仓库都以最定制化的方式解决了这个问题。社区需要团结起来改进这一点。有一个名为&lt;a class=&#34;link&#34; href=&#34;https://github.com/helsing-ai/buffrs&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Buffrs&lt;/a&gt;的开源仓库似乎正在解决这个问题。我还没有亲自使用过它，但到目前为止它看起来还不错。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kmcd.dev/posts/grpc-the-ugly-parts/build.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;关于依赖项，我想指出的是，&lt;a class=&#34;link&#34; href=&#34;https://protobuf.dev/reference/protobuf/google.protobuf/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Google的“众所周知的”protobuf类型&lt;/a&gt;享有被内置到protoc中的特权。虽然这些类型非常有用且无价，但它们的特权使得其他有用的protobuf类型库难以存在和繁荣。仅仅将这些protobuf定义内置到protoc（和其他工具链中）是对没有真正和一致的依赖管理故事的逃避。&lt;/p&gt;
&lt;h3 id=&#34;编辑器支持&#34;&gt;编辑器支持
&lt;/h3&gt;&lt;p&gt;Protobuf代码生成的编辑器集成还有很多不足之处。如果编辑器能够智能地将生成的代码链接回其protobuf源，那将非常有帮助。这将提供更无缝的体验，但工具链还不够智能。此外，我认为每个人都应该使用&lt;a class=&#34;link&#34; href=&#34;https://buf.build/docs/editor-integration&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Buf的编辑器支持&lt;/a&gt;。如今，开发者期望在编辑器中内置linter和自动格式化工具。而对于protobuf来说，有&lt;a class=&#34;link&#34; href=&#34;https://buf.build/docs/lint/rules&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;非常真实的原因&lt;/a&gt;需要遵循linter的建议。&lt;/p&gt;
&lt;p&gt;像&lt;a class=&#34;link&#34; href=&#34;https://trpc.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;tRPC&lt;/a&gt;这样的项目展示了紧密集成和意见化设计选择的好处——这是protobuf由于其性质无法完全复制的。然而，我仍然希望protobuf生态系统能够发展，提供类似的简化开发者体验。&lt;/p&gt;
&lt;h3 id=&#34;丑陋的文档&#34;&gt;丑陋的文档
&lt;/h3&gt;&lt;p&gt;我从未见过从protobuf生成的文档不是超级丑陋的。我认为，由于gRPC历来是后端服务，后端开发者从未真正努力使用protoc插件生成漂亮的文档输出。我通过&lt;a class=&#34;link&#34; href=&#34;https://github.com/sudorandom/protoc-gen-connect-openapi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;制作一个protoc插件&lt;/a&gt;解决了这个问题，该插件可以从给定的protobuf文件生成OpenAPI。然后我使用众多漂亮的工具之一来显示OpenAPI规范。这远比让我设计一个像样的文档容易得多。从protobuf生成OpenAPI的另一个附带好处是能够利用该生态系统，因为它不仅仅是文档。&lt;/p&gt;
&lt;p&gt;让我们看一个真实的例子。这是使用少数几个从protobuf生成文档的工具之一，&lt;a class=&#34;link&#34; href=&#34;https://github.com/pseudomuto/protoc-gen-doc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;protoc-gen-doc&lt;/a&gt;生成的文档：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kmcd.dev/posts/grpc-the-ugly-parts/protoc-gen-doc.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;将其与一些OpenAPI工具链进行比较。这是使用&lt;a class=&#34;link&#34; href=&#34;https://github.com/stoplightio/elements&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Elements&lt;/a&gt;生成的，但还有许多其他同样精美的替代方案：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kmcd.dev/posts/grpc-the-ugly-parts/elements.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;指责单个插件并说默认模板不如OpenAPI替代品好看有点不公平，因为实际上你确实在protoc-gen-doc中有更多的灵活性。它允许你指定自己的模板，因此它可以像你希望的那样漂亮。然而，这确实符合我的观点：在REST世界中，工具链比gRPC更完善和精致。这是一个可以解决的问题，但我们需要让前端开发者和设计师对gRPC感到兴奋，或者后端工程师需要开始磨练他们的设计技能。&lt;/p&gt;
&lt;p&gt;我还想指出，OpenAPI/Swagger接口通常有一种方法可以直接从文档网站测试端点。这在gRPC世界中的等效工具中是完全缺失的。此外，使用大多数OpenAPI文档工具，你可以清楚地看到哪些字段是必填的，并会显示具有约束的字段。因此，它不仅更漂亮，而且功能也更强大。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论
&lt;/h2&gt;&lt;p&gt;gRPC虽然在许多方面是一个强大的工具，但仍然有成长的空间。生成代码的不理想之处，加上依赖项管理和protobuf模式演变的挑战，可能会给开发者带来摩擦。缺乏直观的编辑器集成以及历史上对后端服务的关注，也阻碍了它在Web开发中的广泛采用。&lt;/p&gt;
&lt;p&gt;然而，我认为gRPC的未来是光明的，并且可以变得不那么丑陋。社区正在积极应对这些挑战，开发诸如&lt;a class=&#34;link&#34; href=&#34;https://buf.build/product/cli&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;buf CLI&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://github.com/bufbuild/protovalidate&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;protovalidate&lt;/a&gt;和&lt;a class=&#34;link&#34; href=&#34;https://github.com/sudorandom/protoc-gen-connect-openapi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;protoc-gen-connect-openapi&lt;/a&gt;等工具来弥合差距并增强开发者体验。随着gRPC的成熟和&lt;a class=&#34;link&#34; href=&#34;https://trends.google.com/trends/explore?date=all&amp;amp;q=%2Fm%2F04dzxdz,%2Fg%2F11cp5mklv8,RESTful&amp;amp;hl=en&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;其生态系统的扩展&lt;/a&gt;，我们可以期待改进的工具链、更好的编辑器支持以及更顺畅地融入前端世界。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/%E8%AF%91grpc%E4%B8%91%E9%99%8B%E7%9A%84%E9%83%A8%E5%88%86/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;本文长期链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果您觉得我的博客对你有帮助，请通过 &lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/index.xml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RSS&lt;/a&gt;订阅我。&lt;/li&gt;
&lt;li&gt;或者在&lt;a class=&#34;link&#34; href=&#34;https://x.com/@piaopiaopig&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;X&lt;/a&gt;上关注我。&lt;/li&gt;
&lt;li&gt;如果您有&lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Medium&lt;/a&gt;账号，能给我个关注嘛？我的文章第一时间都会发布在Medium。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>【译】grpc:好的部分</title>
        <link>https://huizhou92.com/zh-cn/p/%E8%AF%91grpc%E5%A5%BD%E7%9A%84%E9%83%A8%E5%88%86/</link>
        <pubDate>Wed, 12 Mar 2025 10:32:24 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/%E8%AF%91grpc%E5%A5%BD%E7%9A%84%E9%83%A8%E5%88%86/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/03/4d500118b2f1f53be2e1f5651b0a7773.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;br&gt;
原文地址: &lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/grpc-the-good-parts/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kmcd.dev/posts/grpc-the-good-parts/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虽然 REST API 仍是 Web 服务开发的主流选择，但 gRPC 正凭借其卓越的性能、效率和开发体验，受到越来越多的青睐。你可能看过我的文章《&lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/grpc-the-bad-parts/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gRPC 的不足之处&lt;/a&gt;》，其中提到了我对 gRPC 的一些不满。根据那篇文章的众多反馈，我本可以再写一篇续集来继续吐槽。但今天，我们换个角度，来探讨 gRPC &lt;strong&gt;优秀&lt;/strong&gt; 的一面。&lt;br&gt;
显然，许多人没有读完上篇文章的结尾——我曾指出，文中提到的许多问题如今已不复存在。因此，我决定专门写一篇文章，聚焦 gRPC 的优势。&lt;br&gt;
让我们深入探讨 gRPC 在现代 Web 开发中的关键价值。&lt;/p&gt;
&lt;h2 id=&#34;性能&#34;&gt;性能
&lt;/h2&gt;&lt;p&gt;这一点可能会引发争议，但 &lt;a class=&#34;link&#34; href=&#34;https://protobuf.dev/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Protocol Buffers&lt;/a&gt; 确实比 JSON 和 XML 更高效。&lt;a class=&#34;link&#34; href=&#34;https://streamdal.com/blog/ptotobuf-vs-json-for-your-event-driven-architecture/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;多项测试&lt;/a&gt;都证明了这一点。Protobuf 的高效性主要体现在以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;字段名不包含在消息中&lt;/strong&gt;：Protobuf 使用数字标识字段，而 JSON 需要存储完整的字段名。通常，Protobuf 的字段编号仅占 1-2 字节，而 JSON 的字段名可能远超这个大小。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/%E8%A7%A3%E6%9E%90go-varint-%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;VARINT 类型优化&lt;/a&gt;&lt;/strong&gt;：小整数即使声明为 int64 也只需 1 字节。在大多数应用场景中，我们很少使用大整数，这种优化能显著减少数据占用，相比 ASCII 编码的数字更加高效。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;压缩优化&lt;/strong&gt;：虽然 Protobuf 在字符串和字节数组方面并无特别优势，但 gRPC 支持数据压缩，使其至少能与 HTTP/JSON 方案持平。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在实际应用中，改用 Protobuf 编码后，我亲眼见证了数据传输量&lt;strong&gt;减少 50%&lt;/strong&gt; 的效果。&lt;br&gt;
当然，仍然有人&lt;a class=&#34;link&#34; href=&#34;https://reasonablypolymorphic.com/blog/protos-are-wrong/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;质疑 Protobuf&lt;/a&gt;。对我而言，最“致命”的缺陷是「map 的值不能是另一个 map」。从实现角度来看，这本应是可行的，但实际上并不被支持。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;MapMessage&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MapValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;values&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;MapValue&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nested&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;最令人困惑的是，我不明白为什么 &lt;code&gt;value_type&lt;/code&gt; 不能是 map。最终只能通过包装类型来嵌套 map，虽然可行，但略显繁琐。这类问题在 gRPC 中时有发生。哎，这明明是一篇夸奖 gRPC 的文章，我们回到正题。&lt;/p&gt;
&lt;p&gt;总的来说，Protobuf 在许多方面优于 JSON。当然，如果你更喜欢 JSON，&lt;a class=&#34;link&#34; href=&#34;https://protobuf.dev/programming-guides/proto3/#json&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gRPC 也完全支持 JSON&lt;/a&gt;。虽然 gRPC 消息前会有少量二进制帧字节（不可读），但如果你真的在意这些，可以参考下文 &lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/grpc-the-good-parts/#connectrpc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ConnectRPC&lt;/a&gt; 章节。&lt;/p&gt;
&lt;p&gt;此外，大多数 gRPC 实现都支持自定义编码，因此你甚至可以采用自定义的序列化方案。&lt;/p&gt;
&lt;h2 id=&#34;api-契约&#34;&gt;API 契约
&lt;/h2&gt;&lt;p&gt;告别松散的 API 类型推测。gRPC 依靠 &lt;code&gt;protobuf&lt;/code&gt; 定义，提供了严谨的客户端-服务端契约，带来诸多优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;更少错误&lt;/strong&gt;：明确的数据类型要求减少了数据不匹配的风险。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更好的代码生成&lt;/strong&gt;：支持多语言客户端/服务端代码自动生成，节省开发时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更顺畅的 API 演进&lt;/strong&gt;：有了稳定的契约，API 迭代时不易破坏已有客户端。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动化文档生成&lt;/strong&gt;：API 定义即文档，始终与实现保持同步。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;API 契约的强大之处，在我的另一篇文章《&lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/api-contracts/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;用契约构建 API&lt;/a&gt;》中有更深入的讨论。&lt;/p&gt;
&lt;h2 id=&#34;流式通信&#34;&gt;流式通信
&lt;/h2&gt;&lt;p&gt;gRPC 提供了一流的流式通信支持，消除了许多场景下的轮询需求，特别适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;实时聊天应用&lt;/strong&gt;：支持双向消息流，确保低延迟。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实时更新&lt;/strong&gt;：无需轮询，服务器可主动推送数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;需要持续通信的场景&lt;/strong&gt;：如游戏、金融数据传输等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你来自网络开发领域，可能知道基于 gRPC 的 gNMI 已取代 SNMP。通过 gNMI 订阅计数器更新，无需每分钟轮询网络设备。更多讨论可见《&lt;a class=&#34;link&#34; href=&#34;https://kmcd.dev/posts/gnmi/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2024 年为何要选择 gNMI 而非 SNMP&lt;/a&gt;》。&lt;/p&gt;
&lt;h2 id=&#34;跨语言支持&#34;&gt;跨语言支持
&lt;/h2&gt;&lt;p&gt;gRPC 天然支持多语言，几乎涵盖所有主流编程语言。借助代码生成工具，你可以在不同技术栈之间无缝集成。&lt;/p&gt;
&lt;p&gt;这一特性极大提升了团队协作效率，也让开发者能自由选择最适合的工具。&lt;/p&gt;
&lt;h2 id=&#34;推动-http2-发展&#34;&gt;推动 HTTP/2 发展
&lt;/h2&gt;&lt;p&gt;gRPC 是 HTTP/2 普及的有力推动者，借助 HTTP/2 提供：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;多路复用&lt;/strong&gt;：单连接支持多个请求/响应，提升传输效率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;头部压缩&lt;/strong&gt;：减少冗余数据，提高传输速度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;整体性能优化&lt;/strong&gt;：HTTP/2 是更现代的 Web 通信方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http3-进展&#34;&gt;HTTP/3 进展
&lt;/h3&gt;&lt;p&gt;gRPC 正在推进对 HTTP/3 的支持。尽管官方进展缓慢，但已有多个社区实现，如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.NET 的 dotnet-grpc&lt;/li&gt;
&lt;li&gt;Rust 的 Tonic（基于 Hyper）&lt;/li&gt;
&lt;li&gt;Go 语言的 ConnectRPC 与 quic-go&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTTP/3 进一步优化了连接建立速度、解决了&lt;a class=&#34;link&#34; href=&#34;https://blog.cloudflare.com/the-road-to-quic#headoflineblocking&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;队头阻塞&lt;/a&gt;问题，并改善了丢包恢复能力。&lt;/p&gt;
&lt;h2 id=&#34;逐步替换&#34;&gt;逐步替换
&lt;/h2&gt;&lt;p&gt;若想逐步采用 gRPC 或需支持现有 REST 客户端，当前已有成熟方案：&lt;/p&gt;
&lt;h3 id=&#34;jsonhttp-转码&#34;&gt;JSON/HTTP 转码
&lt;/h3&gt;&lt;p&gt;使用 &lt;a class=&#34;link&#34; href=&#34;https://github.com/grpc-ecosystem/grpc-gateway&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gRPC-Gateway&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://cloud.google.com/endpoints&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Google Cloud Endpoints&lt;/a&gt; 或 &lt;a class=&#34;link&#34; href=&#34;https://www.envoyproxy.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Envoy&lt;/a&gt; 等工具，可以在后端享受 gRPC 优势的同时暴露 REST 风格接口。例如定义如下服务：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;service&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Greeter&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;rpc&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SayHello&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HelloRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;returns&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HelloResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;option&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;google.api.http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;/v1/greeter/{name}&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;即可通过 REST 端点访问：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl http://localhost:8080/v1/greeter/world
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这种自动转换能大幅减少支持多种 API 格式的工作量。&lt;/p&gt;
&lt;h3 id=&#34;grpc-web&#34;&gt;gRPC-Web
&lt;/h3&gt;&lt;p&gt;由于浏览器对 HTTP trailers 的支持限制，传统 gRPC 无法直接在 Web 使用。gRPC-Web 协议解决了这个问题，使浏览器也能使用 gRPC，并为仍在使用 HTTP/1.1 的平台（如某些 &lt;a class=&#34;link&#34; href=&#34;https://forum.unity.com/threads/support-for-http-2-with-unitywebrequest.1030510/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Unity&lt;/a&gt; 版本）提供支持。&lt;/p&gt;
&lt;h3 id=&#34;connectrpc&#34;&gt;ConnectRPC
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://connectrpc.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ConnectRPC&lt;/a&gt; 能够从 gRPC 定义自动生成 JSON/HTTP API，同时保持与 gRPC/gRPC-Web 兼容。&lt;a class=&#34;link&#34; href=&#34;https://connectrpc.com/docs/protocol/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Connect 协议&lt;/a&gt;更严格遵循 HTTP 标准，支持如下直观的 curl 调用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    --header &lt;span class=&#34;s2&#34;&gt;&amp;#34;Content-Type: application/json&amp;#34;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    --data &lt;span class=&#34;s1&#34;&gt;&amp;#39;{&amp;#34;name&amp;#34;: &amp;#34;world&amp;#34;}&amp;#39;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    http://localhost:8080/greeter.v1.GreeterService/SayHello
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;twirp&#34;&gt;Twirp
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://twitchtv.github.io/twirp/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Twirp&lt;/a&gt; 由 Twitch 开发，采用类似思路。&lt;a class=&#34;link&#34; href=&#34;https://twitchtv.github.io/twirp/docs/spec_v7.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;其规范&lt;/a&gt;通过 protobuf 生成更符合 HTTP 惯例的 API，但不直接支持 gRPC 协议，需要额外工作实现互操作。&lt;/p&gt;
&lt;h2 id=&#34;工具生态&#34;&gt;工具生态
&lt;/h2&gt;&lt;p&gt;虽然官方工具链仍有不足，但社区生态蓬勃发展：&lt;/p&gt;
&lt;h3 id=&#34;buf-cli&#34;&gt;Buf CLI
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://buf.build/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Buf&lt;/a&gt; 公司推出的 &lt;a class=&#34;link&#34; href=&#34;https://buf.build/product/cli&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Buf CLI&lt;/a&gt; 完全取代了官方的 protoc 编译器。它通过配置化管理 proto 文件依赖和代码生成，提供：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;lint 检查&lt;/strong&gt;：强制代码规范&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;破坏性变更检测&lt;/strong&gt;：防止协议不兼容修改&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简化工作流&lt;/strong&gt;：替代 Makefile 等临时方案&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;第三方插件与工具&#34;&gt;第三方插件与工具
&lt;/h3&gt;&lt;p&gt;gRPC 拥有丰富的插件体系，比如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/pseudomuto/protoc-gen-doc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;protoc-gen-doc&lt;/a&gt;&lt;/strong&gt;：多格式文档生成，支持自定义模板&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/sudorandom/protoc-gen-connect-openapi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;protoc-gen-connect-openapi&lt;/a&gt;&lt;/strong&gt;（作者自荐）：为 ConnectRPC 生成 OpenAPI 规范&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/bufbuild/protovalidate&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;protovalidate&lt;/a&gt;&lt;/strong&gt;：直接在 proto 中定义验证规则，期待其 &lt;a class=&#34;link&#34; href=&#34;https://github.com/bufbuild/protovalidate/issues/67&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TypeScript 支持&lt;/a&gt;实现前后端验证逻辑共享&lt;br&gt;
此外，Postman、Insomnia、k6 等主流工具都已加入 gRPC 支持阵营。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;结语&#34;&gt;结语
&lt;/h2&gt;&lt;p&gt;gRPC 以卓越的性能、强类型契约、流式通信、跨语言能力和 HTTP/2 基础，成为现代 Web 开发的强大工具。无论你是要优化 API 交互，还是构建高效可扩展的系统，gRPC 都值得一试。&lt;br&gt;
随着生态的持续发展，gRPC 的未来充满可能。如果你追求快速、可靠的 API 设计，不妨深入了解并尝试 gRPC，它或许能彻底改变你的开发方式。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/%E8%AF%91grpc%E5%A5%BD%E7%9A%84%E9%83%A8%E5%88%86/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;本文长期链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果您觉得我的博客对你有帮助，请通过 &lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/index.xml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RSS&lt;/a&gt;订阅我。&lt;/li&gt;
&lt;li&gt;或者在&lt;a class=&#34;link&#34; href=&#34;https://x.com/@piaopiaopig&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;X&lt;/a&gt;上关注我。&lt;/li&gt;
&lt;li&gt;如果您有&lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Medium&lt;/a&gt;账号，能给我个关注嘛？我的文章第一时间都会发布在Medium。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>网页图标（Icon）那些事</title>
        <link>https://huizhou92.com/zh-cn/p/%E7%BD%91%E9%A1%B5%E5%9B%BE%E6%A0%87icon%E9%82%A3%E4%BA%9B%E4%BA%8B/</link>
        <pubDate>Tue, 18 Feb 2025 11:30:38 +0800</pubDate>
        
        <guid>https://huizhou92.com/zh-cn/p/%E7%BD%91%E9%A1%B5%E5%9B%BE%E6%A0%87icon%E9%82%A3%E4%BA%9B%E4%BA%8B/</guid>
        <description>&lt;img src="https://images.hxzhouh.com/blog-images/2025/02/65e64661a046efca8dcbc39b98ae2b91.png" alt="Featured image of post 网页图标（Icon）那些事" /&gt;&lt;p&gt;昨天&lt;a class=&#34;link&#34; href=&#34;https://taoshu.in/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;涛叔的博客&lt;/a&gt; 发布了一篇关于友情链接的博客，我毛遂自荐向涛叔请求添加友情链接。涛叔很快回应了我，并且在邮件中友好的提醒我，可以给博客添加一个&lt;code&gt;favicon(icon)&lt;/code&gt;，这样方便RSS订阅用户快速的区分博客。当时我心想 &lt;code&gt;favicon&lt;/code&gt; 是什么？（后端程序员伤不起）&lt;/p&gt;
&lt;!-- more--&gt;
&lt;p&gt;后面我咨询了DeepSeek:&lt;br&gt;
在网页设计中，图标（icon）是一个小而重要的元素。它不仅帮助用户快速识别网站，还能提升用户体验。&lt;/p&gt;
&lt;h3 id=&#34;常见使用场景&#34;&gt;常见使用场景：
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;浏览器标签页&lt;/strong&gt;：显示在网页标题旁边。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;书签栏&lt;/strong&gt;：用户收藏网页时显示。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主屏幕图标&lt;/strong&gt;：移动设备将网页添加到主屏幕时显示。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PWA（渐进式网页应用）&lt;/strong&gt;：作为应用图标使用。&lt;br&gt;
比如这样&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/02/6df56f22e8fad0c4fe55bffcab3ed090.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在浏览器标签页展示图标&#34;
	
	
&gt;&lt;br&gt;
在浏览器标签页展示图标。&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/02/c2530b4f9491c01730c710dcd24a325f.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;在书签栏显示图标。&#34;
	
	
&gt;&lt;br&gt;
在书签栏显示图标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;甚至在安卓手机 上，使用chrome浏览器的将网页添加到主屏幕功能。可以显示icon图标。&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/02/861e9e820063fe4d7bbff32e9f8de05b.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;使用 Android Chrome 将网页添加到手机主屏幕&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;如何设置&#34;&gt;如何设置
&lt;/h2&gt;&lt;p&gt;设置icon 最简单的方式是在 网页的 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 中添加 一行。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;link&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;rel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;icon&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;image/png&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;href&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/favicon.png&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果您是使用 hugo 或者其他工具的话，可能会有favicon的设置。&lt;br&gt;
一些大型网站 比如 &lt;code&gt;google.com&lt;/code&gt;、 &lt;code&gt;apple.com&lt;/code&gt; 它们可能需要考虑的问题更多，设置也并不完全一样。&lt;/p&gt;
&lt;h2 id=&#34;一些需要注意的地方&#34;&gt;一些需要注意的地方
&lt;/h2&gt;&lt;p&gt;为了优化使用体验，在各个场景下都达到最佳的显示效果， icon的的尺寸也是有说法。&lt;/p&gt;
&lt;h3 id=&#34;常见尺寸&#34;&gt;常见尺寸：
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;16x16&lt;/strong&gt;：浏览器标签页图标。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;32x32&lt;/strong&gt;：书签栏图标。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;64x64&lt;/strong&gt;：高分辨率屏幕图标。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;180x180&lt;/strong&gt;：iOS 设备主屏幕图标。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;192x192&lt;/strong&gt; 和 &lt;strong&gt;512x512&lt;/strong&gt;：PWA 图标。&lt;br&gt;
所以我们在一些网站上会看到设置多个icon 的现象。比如 &lt;a class=&#34;link&#34; href=&#34;https://gohugo.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Hugo官网 &lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2025/02/4d83d2d0666f924072095b981ba2ff0e.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Hugo 官网设置了两个 icon&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现代浏览器都支持根据不同的场景，屏幕的PPI 选择不同尺寸的图标，尽量做到所有场景下都达到最好的显示效果。&lt;/p&gt;
&lt;h3 id=&#34;图标格式的选择&#34;&gt;图标格式的选择
&lt;/h3&gt;&lt;p&gt;icon 可以使用不同的图片格式，通过 type指定即可，常见的图标格式包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ICO&lt;/strong&gt;：传统格式，兼容性好，支持多尺寸。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PNG&lt;/strong&gt;：现代格式，支持透明背景，适合高分辨率屏幕。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SVG&lt;/strong&gt;：矢量格式，无限缩放不失真，适合响应式设计。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;多合一-icon&#34;&gt;多合一 Icon
&lt;/h3&gt;&lt;p&gt;如果觉得需要维护多个 icon 文件 比较麻烦的话，可以使用多合一icon（Multi-Resolution ICO 或 Multi-Size ICO）是一种包含多种尺寸和色深的图标文件。允许在一个文件中存储多个位图（BMP 或 PNG 格式）。每个位图可以具有不同的尺寸。&lt;br&gt;
ICO 文件包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;文件头&lt;/strong&gt;（Header）：定义 ICO 文件类型及包含的图像数量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;图像目录&lt;/strong&gt;（Image Directory）：描述每个图像的尺寸、色深、偏移量等信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;图像数据&lt;/strong&gt;（Image Data）：实际存储图像像素数据。&lt;br&gt;
浏览器需要一个图标时，它会从 ICO 文件中选择最合适的尺寸。缺点就是包含多个尺寸的 &lt;code&gt;.ico&lt;/code&gt; 文件可能会比单个尺寸的文件大。&lt;br&gt;
本篇文章没有继续深挖，比如 Android Chrome 独有的 &lt;code&gt;manifest.json&lt;/code&gt; 苹果设备 &lt;code&gt;apple-mobile-web-app-capable&lt;/code&gt; 等。 感兴趣的朋友可以继续深挖。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/zh-cn/p/%E7%BD%91%E9%A1%B5%E5%9B%BE%E6%A0%87icon%E9%82%A3%E4%BA%9B%E4%BA%8B/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;本文长期链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果您觉得我的博客对你有帮助，请通过 &lt;a class=&#34;link&#34; href=&#34;https://huizhou92.com/index.xml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RSS&lt;/a&gt;订阅我。&lt;/li&gt;
&lt;li&gt;或者在&lt;a class=&#34;link&#34; href=&#34;https://x.com/@piaopiaopig&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;X&lt;/a&gt;上关注我。&lt;/li&gt;
&lt;li&gt;如果您有&lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Medium&lt;/a&gt;账号，能给我个关注嘛？我的文章第一时间都会发布在Medium。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
