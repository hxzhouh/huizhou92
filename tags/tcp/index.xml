<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Tcp on huizhou92&#39;s Blog</title>
        <link>https://huizhou92.com/tags/tcp/</link>
        <description>Recent content in Tcp on huizhou92&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>Copyright Â© 2023 huizhou92</copyright>
        <lastBuildDate>Fri, 28 Jun 2024 18:24:40 +0800</lastBuildDate><atom:link href="https://huizhou92.com/tags/tcp/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Why does HTTPS need 7 handshakes and 9 times delay?</title>
        <link>https://huizhou92.com/p/why-does-https-need-7-handshakes-and-9-times-delay/</link>
        <pubDate>Fri, 28 Jun 2024 18:24:40 +0800</pubDate>
        
        <guid>https://huizhou92.com/p/why-does-https-need-7-handshakes-and-9-times-delay/</guid>
        <description>&lt;p&gt;HTTP (Hypertext Transfer Protocol) has become the most widely used application layer protocol on the Internet. However, it is primarily a network protocol for transferring hypertext and provides no security guarantees. Transmitting data packets in plaintext over the Internet makes eavesdropping and man-in-the-middle attacks possible. Transmitting passwords over HTTP is essentially the same as running naked on the Internet.&lt;/p&gt;
&lt;!-- more--&gt;
&lt;blockquote&gt;
&lt;p&gt;This article was first published in the Medium MPP plan. If you are a Medium user, please follow me on &lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Medium&lt;/a&gt;. Thank you very much.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In 1994, Netscape designed the HTTPS (Hypertext Transfer Protocol Secure) protocol, which uses the Secure Sockets Layer (SSL) to ensure secure data transmission. With the development of the Transport Layer Security (TLS) protocol, we have replaced the deprecated SSL protocol with TLS, although the term &amp;ldquo;SSL certificate&amp;rdquo; is still used.&lt;/p&gt;
&lt;p&gt;HTTPS is an extension of the HTTP protocol that allows us to transmit data over the Internet securely. However, the initial request in an HTTPS connection requires 4.5 times the round-trip time (RTT) compared to HTTP. This article will provide a detailed explanation of the request and response process, analyzing why the HTTPS protocol requires 4.5 RTT to obtain a response from the service provider:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP Protocol: Both communication parties establish a TCP connection through a three-way handshake.&lt;/li&gt;
&lt;li&gt;TLS Protocol: Both communication parties establish a TLS connection through a four-way handshake.&lt;/li&gt;
&lt;li&gt;HTTP Protocol: The client sends a request to the server, and the server responds.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The analysis is based on specific versions of protocol implementations and common scenarios. With the advancement of network technology, we can reduce the number of required network communications. This article will mention some common optimization solutions in the corresponding sections.&lt;/p&gt;
&lt;h3 id=&#34;tcp&#34;&gt;TCP
&lt;/h3&gt;&lt;p&gt;As an application layer protocol, HTTP relies on a lower-level transport layer protocol to provide basic data transmission functionality. TCP is commonly used as the underlying protocol for HTTP. To prevent the establishment of erroneous historical connections, TCP communication parties perform a three-way handshake to establish a TCP connection&lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;https://draveness.me/whys-the-design-https-latency/#fn:6&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;. Let&amp;rsquo;s briefly review the entire process of establishing a TCP connection.&lt;br&gt;
&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/02/8b676b2c6764adbe073c57f12fcdf1af.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20240220200057&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The client sends a segment with the &lt;code&gt;SYN&lt;/code&gt; flag and the initial sequence number of the data segment (&lt;code&gt;SEQ = M&lt;/code&gt;) to the server.&lt;/li&gt;
&lt;li&gt;Upon receiving the segment, the server sends a segment with the &lt;code&gt;SYN&lt;/code&gt; and &lt;code&gt;ACK&lt;/code&gt; flags to the client:
&lt;ul&gt;
&lt;li&gt;The server acknowledges the initial sequence number of the client&amp;rsquo;s data segment by returning &lt;code&gt;ACK = M+1&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The server notifies the client of the initial sequence number of the server&amp;rsquo;s data segment by sending &lt;code&gt;SEQ = N&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The client sends a segment with the &lt;code&gt;ACK&lt;/code&gt; flag to the server, confirming the server&amp;rsquo;s initial sequence number, including &lt;code&gt;ACK = N+1&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Through the three-way handshake, the TCP connection parties determine the initial sequence number, window size, and maximum segment size of the TCP connection. This allows the communication parties to ensure that the data segments are not duplicated or missed, control the flow through the window size, and avoid IP fragmentation by using the maximum segment size.&lt;/p&gt;
&lt;p&gt;The original version of the TCP protocol did require a three-way communication to establish a TCP connection. In most current scenarios, the three-way handshake is unavoidable. However, TCP Fast Open (TFO), proposed in 2014, can establish a TCP connection in certain scenarios with just one communication.&lt;br&gt;
&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/02/296cc901d35ef44ebd13290948a29b73.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20240220200245&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;The TFO strategy uses a TFO Cookie stored on the client to establish a connection with the server quickly. When the client initiates a TCP connection to the server, it includes the TFO option in the SYN message. The server generates a Cookie and sends it to the client. The client caches the Cookie and uses it to establish a TCP connection directly with the server when reconnecting. After verifying the Cookie, the server sends SYN and ACK to the client, initiating data transmission. This reduces the number of communications required.&lt;/p&gt;
&lt;h3 id=&#34;tls&#34;&gt;TLS
&lt;/h3&gt;&lt;p&gt;The purpose of TLS is to build a secure transmission channel on top of the reliable TCP protocol. However, TLS itself does not provide reliability guarantees, so we still need a reliable transport layer protocol underneath. After establishing a reliable TCP connection between the communication parties, we need to exchange keys through the TLS handshake. Here, we will explain the connection establishment process of TLS 1.2:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/02/094fa30c0ac0ea649dcb30db7ce478a8.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20240220195816&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The client sends a Client Hello message to the server, including the client&amp;rsquo;s supported protocol version, encryption algorithms, compression algorithms, and &lt;strong&gt;client-generated random number&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Upon receiving the information about the client&amp;rsquo;s supported protocol version and encryption algorithms, the server:
&lt;ul&gt;
&lt;li&gt;Sends a Server Hello message to the client, specifying the chosen protocol version, encryption method, session ID, and &lt;strong&gt;server-generated random number&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Sends a Certificate message to the client, which includes the server&amp;rsquo;s certificate chain, including information about supported domains, issuers, and expiration dates.&lt;/li&gt;
&lt;li&gt;Sends a Server Key Exchange message, transmitting the &lt;strong&gt;public key&lt;/strong&gt; and signature information.&lt;/li&gt;
&lt;li&gt;Optionally sends a CertificateRequest message, requesting the client&amp;rsquo;s certificate for verification.&lt;/li&gt;
&lt;li&gt;Sends a Server Hello Done message to the client, indicating that all relevant information has been sent.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Upon receiving the server&amp;rsquo;s protocol version, encryption method, session ID, and certificate, the client verifies the server&amp;rsquo;s certificate:
&lt;ul&gt;
&lt;li&gt;Sends a Client Key Exchange message to the server, including the &lt;strong&gt;pre-master secret&lt;/strong&gt;, which is a random string encrypted with the server&amp;rsquo;s public key.&lt;/li&gt;
&lt;li&gt;Sends a Change Cipher Spec message to the server, indicating that subsequent data segments will be encrypted.&lt;/li&gt;
&lt;li&gt;Sends a Finished message to the server, which includes an encrypted handshake message.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Upon receiving the Change Cipher Spec and Finished messages from the client:
&lt;ul&gt;
&lt;li&gt;Sends a Change Cipher Spec message to the client, indicating that subsequent data segments will be encrypted.&lt;/li&gt;
&lt;li&gt;Sends a Finished message to the client, verifying the client&amp;rsquo;s Finished message and completing the TLS handshake.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The key to the TLS handshake uses the random strings generated by both communication parties and the server&amp;rsquo;s public key to generate a negotiated key. This symmetric key allows both parties to encrypt messages, preventing eavesdropping and attacks by intermediaries and ensuring secure communication.&lt;/p&gt;
&lt;p&gt;In TLS 1.2, establishing a TLS connection takes 2 RTT. However, TLS 1.3 optimizes the protocol, reducing the round-trip time to one, significantly reducing the time required. After 1 RTT, the client can already transmit application-layer data to the server.&lt;/p&gt;
&lt;p&gt;We won&amp;rsquo;t go into detail about the TLS 1.3 connection establishment process here. In addition to reducing the network overhead in regular handshakes, TLS 1.3 introduces a 0-RTT connection establishment process. 60% of network connections are established when users first visit a website or after a certain interval, while the remaining 40% can be addressed using the 0-RTT strategy of TLS 1.3. However, this strategy, similar to TFO, carries some security risks and should be used with consideration for specific business scenarios.&lt;/p&gt;
&lt;h3 id=&#34;http&#34;&gt;HTTP
&lt;/h3&gt;&lt;p&gt;Transmitting data over a well-established TCP and TLS channel is relatively straightforward. The HTTP protocol can directly utilize the reliable and secure channel established at the lower layers to transmit data. The client writes data to the server using the TCP socket interface, and the server responds through the same means after processing the data. Since the entire process involves the client sending a request and the server returning a response, it takes 1 RTT.&lt;/p&gt;
&lt;p&gt;The data exchange in the HTTP protocol consumes only 1 RTT. When the client and server handle a single HTTP request, we cannot optimize beyond the HTTP protocol itself. However, as the number of requests increases, HTTP/2 allows the reuse of established TCP connections to reduce the additional overhead of TCP and TLS handshakes.&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary
&lt;/h2&gt;&lt;p&gt;When a client wants to access a server via HTTPS, the entire process requires 7 handshakes and consumes 9 times the latency. If the RTT is approximately 40ms due to physical distance limitations, the first request requires ~180ms. However, if we want to access a server in the United States with an RTT of approximately 200ms, the HTTPS request will take ~900ms, which is a significant delay. Let&amp;rsquo;s summarize the reasons why the HTTPS protocol requires 9 times the latency to complete communication:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The TCP protocol requires a three-way handshake to establish a reliable TCP connection (1.5 RTT).&lt;/li&gt;
&lt;li&gt;The TLS protocol establishes a TLS connection over TCP through a four-way handshake to ensure communication security (2 RTT).&lt;/li&gt;
&lt;li&gt;The HTTP protocol sends a request and receives a response over TCP and TLS in one round trip (1 RTT).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;It is important to note that the calculations of round-trip delay in this article are based on specific scenarios and protocol versions. Network protocols are constantly evolving, and issues that were initially overlooked are often addressed through patch updates. However, in the end, a complete rewrite from the ground up is still necessary.&lt;/p&gt;
&lt;p&gt;HTTP/3 is an example of this. It uses the UDP-based QUIC protocol for handshakes, combining the TCP and TLS handshake processes to reduce the 7 handshakes to 3. It directly establishes a reliable and secure transmission channel, reducing the time required from ~900ms to ~500ms. We will cover HTTP/3-related content in future articles. Finally, let&amp;rsquo;s consider some open-ended questions for further exploration. Interested readers can carefully consider the following questions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What are the similarities and differences between the QUIC protocol and the TCP protocol as transport layer protocols?&lt;/li&gt;
&lt;li&gt;How is it possible to establish a client-server connection using 0-RTT?&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;further-reading&#34;&gt;Further Reading
&lt;/h1&gt;&lt;p&gt;Here are some excellent articles that explain TCP three-way handshake, TLS connection, and TCP Fast Open in detail:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://books.google.com.hk/books?id=FLvsis4_QhEC&amp;amp;pg=PA344&amp;amp;redir_esc=y#v=onepage&amp;amp;q&amp;amp;f=false&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Walls, Colin (2005). Embedded Software: The Works. Newnes. p. 344. ISBN 0-7506-7954-9. Archived from the original on 2019-02-09. Retrieved 2018-10-20.&lt;/a&gt;Â &lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.websecurity.digicert.com/security-topics/what-is-ssl-tls-https&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;What is an SSL Certificate?&lt;/a&gt;Â &lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/HTTPS&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Wikipedia: HTTPS&lt;/a&gt;Â &lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/TCP_Fast_Open&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Wikipedia: TCP Fast Open&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://tools.ietf.org/html/rfc793&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RFC793 Transmission Control Protocol, September 1981 RFC793&lt;/a&gt;Â &lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://tools.ietf.org/html/rfc5246&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RFC5246 The Transport Layer Security (TLS) Protocol. Version 1.2. Aug 2008 RFC5246&lt;/a&gt;Â &lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.rfc-editor.org/info/rfc7413&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Cheng, Y., Chu, J., Radhakrishnan, S., and A. Jain, âTCP Fast Openâ, RFC 7413, DOI 10.17487/RFC7413, December 2014,&lt;/a&gt;.Â &lt;a class=&#34;link&#34; href=&#34;https://draveness.me/whys-the-design-https-latency/#fnref:8&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;â©ï¸&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://tlseminar.github.io/first-few-milliseconds/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;The First Few Milliseconds of an TLS 1.2 Connection&lt;/a&gt;Â &lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.thesslstore.com/blog/tls-1-3-handshake-tls-1-2/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TLS 1.3 Handshake: Taking a Closer Look&lt;/a&gt;Â &lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.cloudflare.com/introducing-0-rtt/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Introducing Zero Round Trip Time Resumption (0-RTT)Â &lt;/a&gt;Â &lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>Why Does It Take Four Waves For TCP To Disconnect?</title>
        <link>https://huizhou92.com/p/why-does-it-take-four-waves-for-tcp-to-disconnect/</link>
        <pubDate>Thu, 01 Feb 2024 11:11:00 +0000</pubDate>
        
        <guid>https://huizhou92.com/p/why-does-it-take-four-waves-for-tcp-to-disconnect/</guid>
        <description>&lt;p&gt;TCP protocol is one of the network protocols we use in our daily lives. It is responsible for establishing and terminating connections. In the &lt;a class=&#34;link&#34; href=&#34;https://levelup.gitconnected.com/why-tcp-requires-three-handshakes-to-establish-a-connection-31d814aac6b8&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;previous&lt;/a&gt; blog post, we analyzed why TCP requires three handshakes to establish a connection. When establishing a connection, we need to ensure the issues of historical connections and sequence numbers. Unlike the three-way handshake during connection establishment, disconnecting a TCP connection requires a four-way handshake. This article will explore why TCP disconnects require a four-way handshake instead of three or any other number.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This article is first published in the medium MPP plan. If you are a medium user, please follow me in &lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;medium&lt;/a&gt;. Thank you very much.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/db19965682f215f42c5a8a03cd7f7b76.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Material from: history-computer.com&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;overview&#34;&gt;Overview
&lt;/h1&gt;&lt;p&gt;Before delving into why a four-way handshake is necessary, letâs first understand the process of TCP connection termination. Typically, when one party in the communication decides to terminate the connection, it sends a FIN (Finish) control message to the other party, indicating that it has no more data to send. The receiving party responds with an ACK (Acknowledgment) control message to acknowledge and enters a half-closed state, indicating that it will no longer send data but can still receive data. When the other party also has no more data to send, it sends a FIN message to indicate its intention to disconnect. The receiving party then sends another ACK message to confirm, and only then will the connection be fully closed.&lt;br&gt;
&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/b2b3a5d3921acfa31d009eab0f48e139.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;The Four-Way Handshake Processï¼ geeksforgeeks.org ï¼&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;design&#34;&gt;Design
&lt;/h1&gt;&lt;p&gt;Why does TCP disconnect require a four-way handshake? Letâs analyze this question from several aspects:&lt;/p&gt;
&lt;h1 id=&#34;ensuring-data-integrity&#34;&gt;Ensuring Data Integrity
&lt;/h1&gt;&lt;p&gt;TCP is a connection-oriented reliable transport protocol that guarantees data reliability and integrity. During connection termination, both parties may still have unsent or unacknowledged data packets. If only a three-way handshake is performed, the other party may not know whether the FIN message it sent has been received during the final handshake. This could result in the other party not fully receiving the data, leading to data loss. Therefore, by performing a four-way handshake, both parties can ensure that they receive each otherâs data completely and maintain data integrity.&lt;/p&gt;
&lt;h1 id=&#34;handling-network-latency-and-packetloss&#34;&gt;Handling Network Latency and PacketÂ Loss
&lt;/h1&gt;&lt;p&gt;In a network, data packets may be delayed or lost due to network latency or packet loss. During connection termination, if only a three-way handshake is performed, the other party may not know whether the FIN message it sent has been received, which may prevent timely closure of the connection. By performing a four-way handshake, sufficient time is provided for the network to handle latency and packet loss issues, ensuring that the connection can be properly closed.&lt;/p&gt;
&lt;h1 id=&#34;waiting-for-unsent-data-to-besent&#34;&gt;Waiting for Unsent Data to beÂ Sent
&lt;/h1&gt;&lt;p&gt;During connection termination, both parties may still have unsent data packets. If only a three-way handshake is performed, the other party may not know whether there is any unsent data before sending the FIN message. By performing a four-way handshake, both parties have enough time to send and receive the remaining data, ensuring data integrity and correctness.&lt;/p&gt;
&lt;h1 id=&#34;handling-the-half-closed-state&#34;&gt;Handling the Half-Closed State
&lt;/h1&gt;&lt;p&gt;During the TCP connection termination process, one party enters a half-closed state by sending a FIN message, indicating that it will no longer send data but can still receive data. If only a three-way handshake is performed, the other party will immediately close the connection upon receiving the FIN message, which may prevent proper handling of the half-closed state. By performing a four-way handshake, both parties can ensure the correct handling of the half-closed state, avoiding data loss and confusion.&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion
&lt;/h1&gt;&lt;p&gt;Based on the analysis above, we can conclude that a four-way handshake is necessary for TCP disconnection to ensure data integrity, handle network latency and packet loss, wait for unsent data to be sent, and handle the half-closed state. Through the four-way handshake, both parties can better coordinate and handle the disconnection, ensuring the correct transmission of data and secure closure of the connection.&lt;/p&gt;
&lt;p&gt;When discussing TCP disconnection, we should not focus on why a four-way handshake is used, but rather understand why multiple handshakes are needed to ensure data integrity and proper connection closure. By gaining a deep understanding of TCP protocol design, we can better apply and comprehend the principles and mechanisms of network communication.&lt;/p&gt;
&lt;p&gt;Whether it is three handshakes or four handshakes, the first element of a tcp connection to consider is always security and data integrity, although it seems that three handshakes and four handshakes seem to be very inefficient, but the vast majority of Internet traffic is based on the tcp protocol, which is enough to prove that its reliability, on the issue of performance, there are other ways to optimize the performance of the protocol, such as udp, and later on, we will analyze how UDP and UDP-based QUIC protocol will affect the Internet in the next ten years. and how the UDP-based QUIC protocol will influence the next decade of the Internet.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;If you found my article enjoyable, feel free to follow me and give it a ð. Your support would be greatly appreciated.&lt;/p&gt;
&lt;h1 id=&#34;references&#34;&gt;References
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://tools.ietf.org/html/rfc793&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RFC 793âââTransmission Control ProtocolâââIETF Tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://networkengineering.stackexchange.com/questions/24072/why-do-we-need-a-4-way-handshake-to-terminate-a-tcp-connection&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Why do we need a 4-way handshake to terminate a TCP connection?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/why-tcp-connect-termination-need-4-way-handshake&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;why-tcp-connect-termination-need-4-way-handshake&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        
    </channel>
</rss>
