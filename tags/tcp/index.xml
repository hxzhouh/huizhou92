<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Tcp on huizhou92&#39;s Blog</title>
        <link>https://huizhou92.com/tags/tcp/</link>
        <description>Recent content in Tcp on huizhou92&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>Copyright ¬© 2023 huizhou92</copyright>
        <lastBuildDate>Mon, 02 Dec 2024 15:44:12 +0800</lastBuildDate><atom:link href="https://huizhou92.com/tags/tcp/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Debunking the Misconception: Maximum Number of TCP Connections on a Server</title>
        <link>https://huizhou92.com/p/debunking-the-misconception-maximum-number-of-tcp-connections-on-a-server/</link>
        <pubDate>Mon, 02 Dec 2024 15:44:12 +0800</pubDate>
        
        <guid>https://huizhou92.com/p/debunking-the-misconception-maximum-number-of-tcp-connections-on-a-server/</guid>
        <description>&lt;img src="https://images.hxzhouh.com/blog-images/2024/12/5a04e98368531b4e0208f40a907399f0.png" alt="Featured image of post Debunking the Misconception: Maximum Number of TCP Connections on a Server" /&gt;&lt;h2 id=&#34;introduction&#34;&gt;Introduction
&lt;/h2&gt;&lt;p&gt;There&amp;rsquo;s a widespread misconception:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Since TCP port numbers are 16-bit unsigned integers with a maximum value of 65535, a single server can support at most 65536 TCP socket connections.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Even experienced network programmers may believe this conclusion to be proper. Let&amp;rsquo;s debunk this myth using both theoretical and practical perspectives.&lt;/p&gt;
&lt;!-- more--&gt;
&lt;h2 id=&#34;theoretical-analysis&#34;&gt;Theoretical Analysis
&lt;/h2&gt;&lt;p&gt;In &lt;code&gt;*nix&lt;/code&gt; systems, each TCP connection is uniquely identified by a &lt;strong&gt;4-tuple&lt;/strong&gt; structure: &lt;code&gt;{local_ip, local_port, remote_ip, remote_port}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For IPv4, the system can theoretically manage up to &lt;code&gt;2^(32 + 16 + 32 + 16)&lt;/code&gt; connections‚Äîequivalent to &lt;code&gt;2^96&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;IPv4 can be viewed as a 32-bit unsigned number.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;breaking-down-the-4-tuple-limits&#34;&gt;Breaking Down the 4-Tuple Limits
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;A single server typically uses only one &lt;code&gt;local_ip&lt;/code&gt;&lt;/strong&gt;, meaning the server could theoretically manage &lt;code&gt;2^(16 + 32 + 16)&lt;/code&gt; connections.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A single service (e.g., an Nginx process) usually listens on one &lt;code&gt;local_port&lt;/code&gt;&lt;/strong&gt;, which reduces the capacity further to &lt;code&gt;2^(32 + 16)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;If one remote machine (client) connects to a server&lt;/strong&gt;, fixing &lt;code&gt;local_ip&lt;/code&gt;, &lt;code&gt;local_port&lt;/code&gt;, and &lt;code&gt;remote_ip&lt;/code&gt; leaves only the &lt;code&gt;remote_port&lt;/code&gt; variable. Since the &lt;code&gt;remote_port&lt;/code&gt; range is 16-bit, there are only &lt;code&gt;2^16 = 65536&lt;/code&gt; possible connections from a single client to a specific server endpoint.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This limitation is the root of the &lt;strong&gt;classic misunderstanding&lt;/strong&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For protocols beyond TCP (like UDP), the tuple expands to include the protocol type, making it a 5-tuple, adding even more possibilities.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The actual limits for a server depend on factors beyond the tuple structure.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;practical-limitations&#34;&gt;Practical Limitations
&lt;/h2&gt;&lt;h3 id=&#34;file-descriptors&#34;&gt;File Descriptors
&lt;/h3&gt;&lt;p&gt;In Linux, everything is treated as a file, and sockets are no exception. The number of file descriptors determines the maximum number of simultaneous TCP connections.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Maximum file descriptors supported by the system:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;root@test1 ~&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;# cat /proc/sys/fs/file-max&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;m&#34;&gt;1616352&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Maximum file descriptors per process:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;root@test1 ~&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;# ulimit -n&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;m&#34;&gt;1024&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Both values can be modified. For instance, during stress testing, these limits are often increased manually.&lt;/p&gt;
&lt;h3 id=&#34;ip_local_port_range&#34;&gt;ip_local_port_range
&lt;/h3&gt;&lt;p&gt;When a client connects to the same TCP endpoint (&lt;code&gt;ip:port&lt;/code&gt;), each connection requires a unique local TCP endpoint. For clients with a single IP, the available local ports determine the connection limit.&lt;/p&gt;
&lt;p&gt;On &lt;code&gt;*nix&lt;/code&gt; systems, the default local port range is typically from &lt;code&gt;32768&lt;/code&gt; to &lt;code&gt;61000&lt;/code&gt;. Check this range using:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;root@test1 ~&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;# cat /proc/sys/net/ipv4/ip_local_port_range&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;m&#34;&gt;32768&lt;/span&gt;    &lt;span class=&#34;m&#34;&gt;60999&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;This means a single client can establish around &lt;strong&gt;30,000 connections&lt;/strong&gt; to the same server endpoint during stress tests.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Operating systems automatically reuse local ports if multiple distinct remote endpoints (ip:port) are involved.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;memory--cpu&#34;&gt;Memory &amp;amp; CPU
&lt;/h3&gt;&lt;p&gt;Each TCP socket in the &lt;code&gt;ESTABLISHED&lt;/code&gt; state consumes approximately &lt;strong&gt;3.3 KB of memory&lt;/strong&gt;. While CPU usage for idle connections is minimal, the server&amp;rsquo;s memory capacity significantly impacts the total number of connections.&lt;/p&gt;
&lt;p&gt;In practice, hardware resources like memory and CPU limit the maximum number of TCP connections a server can handle, long before reaching the theoretical &lt;code&gt;4-tuple&lt;/code&gt; limit.&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2024/12/87f4a2f2de8879668f10358d0cb3effc.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2^96 is too bigger&#34;
	
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary
&lt;/h2&gt;&lt;p&gt;The maximum number of TCP connections a server can support is an astronomical &lt;code&gt;2^96&lt;/code&gt;. However, practical constraints like memory, CPU, file descriptors, and port availability impose far lower limits.&lt;/p&gt;
&lt;p&gt;There&amp;rsquo;s no universal number; the limit depends on hardware, configuration, and workload.&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;The background Photo by¬†&lt;a class=&#34;link&#34; href=&#34;https://unsplash.com/@alinnnaaaa?utm_source=medium&amp;amp;utm_medium=referral&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Alina Grubnyak&lt;/a&gt;¬†on¬†&lt;a class=&#34;link&#34; href=&#34;https://unsplash.com/?utm_source=medium&amp;amp;utm_medium=referral&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Unsplash&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Why does HTTPS need 7 handshakes and 9 times delay?</title>
        <link>https://huizhou92.com/p/why-does-https-need-7-handshakes-and-9-times-delay/</link>
        <pubDate>Fri, 28 Jun 2024 18:24:40 +0800</pubDate>
        
        <guid>https://huizhou92.com/p/why-does-https-need-7-handshakes-and-9-times-delay/</guid>
        <description>&lt;p&gt;HTTP (Hypertext Transfer Protocol) has become the most widely used application layer protocol on the Internet. However, it is primarily a network protocol for transferring hypertext and provides no security guarantees. Transmitting data packets in plaintext over the Internet makes eavesdropping and man-in-the-middle attacks possible. Transmitting passwords over HTTP is essentially the same as running naked on the Internet.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;blockquote&gt;
&lt;p&gt;This article was first published in the Medium MPP plan. If you are a Medium user, please follow me on &lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Medium&lt;/a&gt;. Thank you very much.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In 1994, Netscape designed the HTTPS (Hypertext Transfer Protocol Secure) protocol, which uses the Secure Sockets Layer (SSL) to ensure secure data transmission. With the development of the Transport Layer Security (TLS) protocol, we have replaced the deprecated SSL protocol with TLS, although the term &amp;ldquo;SSL certificate&amp;rdquo; is still used.&lt;/p&gt;
&lt;p&gt;HTTPS is an extension of the HTTP protocol that allows us to transmit data over the Internet securely. However, the initial request in an HTTPS connection requires 4.5 times the round-trip time (RTT) compared to HTTP. This article will provide a detailed explanation of the request and response process, analyzing why the HTTPS protocol requires 4.5 RTT to obtain a response from the service provider:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP Protocol: Both communication parties establish a TCP connection through a three-way handshake.&lt;/li&gt;
&lt;li&gt;TLS Protocol: Both communication parties establish a TLS connection through a four-way handshake.&lt;/li&gt;
&lt;li&gt;HTTP Protocol: The client sends a request to the server, and the server responds.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The analysis is based on specific versions of protocol implementations and common scenarios. With the advancement of network technology, we can reduce the number of required network communications. This article will mention some common optimization solutions in the corresponding sections.&lt;/p&gt;
&lt;h3 id=&#34;tcp&#34;&gt;TCP
&lt;/h3&gt;&lt;p&gt;As an application layer protocol, HTTP relies on a lower-level transport layer protocol to provide basic data transmission functionality. TCP is commonly used as the underlying protocol for HTTP. To prevent the establishment of erroneous historical connections, TCP communication parties perform a three-way handshake to establish a TCP connection&lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;https://draveness.me/whys-the-design-https-latency/#fn:6&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;. Let&amp;rsquo;s briefly review the entire process of establishing a TCP connection.&lt;br&gt;
&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/02/8b676b2c6764adbe073c57f12fcdf1af.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20240220200057&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The client sends a segment with the &lt;code&gt;SYN&lt;/code&gt; flag and the initial sequence number of the data segment (&lt;code&gt;SEQ = M&lt;/code&gt;) to the server.&lt;/li&gt;
&lt;li&gt;Upon receiving the segment, the server sends a segment with the &lt;code&gt;SYN&lt;/code&gt; and &lt;code&gt;ACK&lt;/code&gt; flags to the client:
&lt;ul&gt;
&lt;li&gt;The server acknowledges the initial sequence number of the client&amp;rsquo;s data segment by returning &lt;code&gt;ACK = M+1&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The server notifies the client of the initial sequence number of the server&amp;rsquo;s data segment by sending &lt;code&gt;SEQ = N&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The client sends a segment with the &lt;code&gt;ACK&lt;/code&gt; flag to the server, confirming the server&amp;rsquo;s initial sequence number, including &lt;code&gt;ACK = N+1&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Through the three-way handshake, the TCP connection parties determine the initial sequence number, window size, and maximum segment size of the TCP connection. This allows the communication parties to ensure that the data segments are not duplicated or missed, control the flow through the window size, and avoid IP fragmentation by using the maximum segment size.&lt;/p&gt;
&lt;p&gt;The original version of the TCP protocol did require a three-way communication to establish a TCP connection. In most current scenarios, the three-way handshake is unavoidable. However, TCP Fast Open (TFO), proposed in 2014, can establish a TCP connection in certain scenarios with just one communication.&lt;br&gt;
&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/02/296cc901d35ef44ebd13290948a29b73.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20240220200245&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;The TFO strategy uses a TFO Cookie stored on the client to establish a connection with the server quickly. When the client initiates a TCP connection to the server, it includes the TFO option in the SYN message. The server generates a Cookie and sends it to the client. The client caches the Cookie and uses it to establish a TCP connection directly with the server when reconnecting. After verifying the Cookie, the server sends SYN and ACK to the client, initiating data transmission. This reduces the number of communications required.&lt;/p&gt;
&lt;h3 id=&#34;tls&#34;&gt;TLS
&lt;/h3&gt;&lt;p&gt;The purpose of TLS is to build a secure transmission channel on top of the reliable TCP protocol. However, TLS itself does not provide reliability guarantees, so we still need a reliable transport layer protocol underneath. After establishing a reliable TCP connection between the communication parties, we need to exchange keys through the TLS handshake. Here, we will explain the connection establishment process of TLS 1.2:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/02/094fa30c0ac0ea649dcb30db7ce478a8.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20240220195816&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The client sends a Client Hello message to the server, including the client&amp;rsquo;s supported protocol version, encryption algorithms, compression algorithms, and &lt;strong&gt;client-generated random number&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Upon receiving the information about the client&amp;rsquo;s supported protocol version and encryption algorithms, the server:
&lt;ul&gt;
&lt;li&gt;Sends a Server Hello message to the client, specifying the chosen protocol version, encryption method, session ID, and &lt;strong&gt;server-generated random number&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Sends a Certificate message to the client, which includes the server&amp;rsquo;s certificate chain, including information about supported domains, issuers, and expiration dates.&lt;/li&gt;
&lt;li&gt;Sends a Server Key Exchange message, transmitting the &lt;strong&gt;public key&lt;/strong&gt; and signature information.&lt;/li&gt;
&lt;li&gt;Optionally sends a CertificateRequest message, requesting the client&amp;rsquo;s certificate for verification.&lt;/li&gt;
&lt;li&gt;Sends a Server Hello Done message to the client, indicating that all relevant information has been sent.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Upon receiving the server&amp;rsquo;s protocol version, encryption method, session ID, and certificate, the client verifies the server&amp;rsquo;s certificate:
&lt;ul&gt;
&lt;li&gt;Sends a Client Key Exchange message to the server, including the &lt;strong&gt;pre-master secret&lt;/strong&gt;, which is a random string encrypted with the server&amp;rsquo;s public key.&lt;/li&gt;
&lt;li&gt;Sends a Change Cipher Spec message to the server, indicating that subsequent data segments will be encrypted.&lt;/li&gt;
&lt;li&gt;Sends a Finished message to the server, which includes an encrypted handshake message.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Upon receiving the Change Cipher Spec and Finished messages from the client:
&lt;ul&gt;
&lt;li&gt;Sends a Change Cipher Spec message to the client, indicating that subsequent data segments will be encrypted.&lt;/li&gt;
&lt;li&gt;Sends a Finished message to the client, verifying the client&amp;rsquo;s Finished message and completing the TLS handshake.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The key to the TLS handshake uses the random strings generated by both communication parties and the server&amp;rsquo;s public key to generate a negotiated key. This symmetric key allows both parties to encrypt messages, preventing eavesdropping and attacks by intermediaries and ensuring secure communication.&lt;/p&gt;
&lt;p&gt;In TLS 1.2, establishing a TLS connection takes 2 RTT. However, TLS 1.3 optimizes the protocol, reducing the round-trip time to one, significantly reducing the time required. After 1 RTT, the client can already transmit application-layer data to the server.&lt;/p&gt;
&lt;p&gt;We won&amp;rsquo;t go into detail about the TLS 1.3 connection establishment process here. In addition to reducing the network overhead in regular handshakes, TLS 1.3 introduces a 0-RTT connection establishment process. 60% of network connections are established when users first visit a website or after a certain interval, while the remaining 40% can be addressed using the 0-RTT strategy of TLS 1.3. However, this strategy, similar to TFO, carries some security risks and should be used with consideration for specific business scenarios.&lt;/p&gt;
&lt;h3 id=&#34;http&#34;&gt;HTTP
&lt;/h3&gt;&lt;p&gt;Transmitting data over a well-established TCP and TLS channel is relatively straightforward. The HTTP protocol can directly utilize the reliable and secure channel established at the lower layers to transmit data. The client writes data to the server using the TCP socket interface, and the server responds through the same means after processing the data. Since the entire process involves the client sending a request and the server returning a response, it takes 1 RTT.&lt;/p&gt;
&lt;p&gt;The data exchange in the HTTP protocol consumes only 1 RTT. When the client and server handle a single HTTP request, we cannot optimize beyond the HTTP protocol itself. However, as the number of requests increases, HTTP/2 allows the reuse of established TCP connections to reduce the additional overhead of TCP and TLS handshakes.&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary
&lt;/h2&gt;&lt;p&gt;When a client wants to access a server via HTTPS, the entire process requires 7 handshakes and consumes 9 times the latency. If the RTT is approximately 40ms due to physical distance limitations, the first request requires ~180ms. However, if we want to access a server in the United States with an RTT of approximately 200ms, the HTTPS request will take ~900ms, which is a significant delay. Let&amp;rsquo;s summarize the reasons why the HTTPS protocol requires 9 times the latency to complete communication:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The TCP protocol requires a three-way handshake to establish a reliable TCP connection (1.5 RTT).&lt;/li&gt;
&lt;li&gt;The TLS protocol establishes a TLS connection over TCP through a four-way handshake to ensure communication security (2 RTT).&lt;/li&gt;
&lt;li&gt;The HTTP protocol sends a request and receives a response over TCP and TLS in one round trip (1 RTT).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;It is important to note that the calculations of round-trip delay in this article are based on specific scenarios and protocol versions. Network protocols are constantly evolving, and issues that were initially overlooked are often addressed through patch updates. However, in the end, a complete rewrite from the ground up is still necessary.&lt;/p&gt;
&lt;p&gt;HTTP/3 is an example of this. It uses the UDP-based QUIC protocol for handshakes, combining the TCP and TLS handshake processes to reduce the 7 handshakes to 3. It directly establishes a reliable and secure transmission channel, reducing the time required from ~900ms to ~500ms. We will cover HTTP/3-related content in future articles. Finally, let&amp;rsquo;s consider some open-ended questions for further exploration. Interested readers can carefully consider the following questions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What are the similarities and differences between the QUIC protocol and the TCP protocol as transport layer protocols?&lt;/li&gt;
&lt;li&gt;How is it possible to establish a client-server connection using 0-RTT?&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;further-reading&#34;&gt;Further Reading
&lt;/h1&gt;&lt;p&gt;Here are some excellent articles that explain TCP three-way handshake, TLS connection, and TCP Fast Open in detail:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://books.google.com.hk/books?id=FLvsis4_QhEC&amp;amp;pg=PA344&amp;amp;redir_esc=y#v=onepage&amp;amp;q&amp;amp;f=false&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Walls, Colin (2005). Embedded Software: The Works. Newnes. p. 344. ISBN 0-7506-7954-9. Archived from the original on 2019-02-09. Retrieved 2018-10-20.&lt;/a&gt;¬†&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.websecurity.digicert.com/security-topics/what-is-ssl-tls-https&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;What is an SSL Certificate?&lt;/a&gt;¬†&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/HTTPS&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Wikipedia: HTTPS&lt;/a&gt;¬†&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/TCP_Fast_Open&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Wikipedia: TCP Fast Open&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://tools.ietf.org/html/rfc793&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RFC793 Transmission Control Protocol, September 1981 RFC793&lt;/a&gt;¬†&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://tools.ietf.org/html/rfc5246&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RFC5246 The Transport Layer Security (TLS) Protocol. Version 1.2. Aug 2008 RFC5246&lt;/a&gt;¬†&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.rfc-editor.org/info/rfc7413&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Cheng, Y., Chu, J., Radhakrishnan, S., and A. Jain, ‚ÄúTCP Fast Open‚Äù, RFC 7413, DOI 10.17487/RFC7413, December 2014,&lt;/a&gt;.¬†&lt;a class=&#34;link&#34; href=&#34;https://draveness.me/whys-the-design-https-latency/#fnref:8&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;‚Ü©Ô∏é&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://tlseminar.github.io/first-few-milliseconds/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;The First Few Milliseconds of an TLS 1.2 Connection&lt;/a&gt;¬†&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.thesslstore.com/blog/tls-1-3-handshake-tls-1-2/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TLS 1.3 Handshake: Taking a Closer Look&lt;/a&gt;¬†&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.cloudflare.com/introducing-0-rtt/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Introducing Zero Round Trip Time Resumption (0-RTT)¬†&lt;/a&gt;¬†&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>Why TCP requires three handshakes to establish a connection</title>
        <link>https://huizhou92.com/p/why-tcp-requires-three-handshakes-to-establish-a-connection/</link>
        <pubDate>Fri, 28 Jun 2024 16:33:50 +0800</pubDate>
        
        <guid>https://huizhou92.com/p/why-tcp-requires-three-handshakes-to-establish-a-connection/</guid>
        <description>&lt;p&gt;TCP protocol is a network protocol that we encounter almost every day. The majority of network connections are established based on the TCP protocol. People who have studied computer networks or have some understanding of the TCP protocol know that establishing a connection using TCP requires a three-way handshake.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This article is first published in the medium MPP plan. If you are a medium user, please follow me in &lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;medium&lt;/a&gt;. Thank you very much.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/c680b2ef5dc88552c1838e5bf7f1ba65.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20240517205741&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;If we briefly explain the process of establishing a TCP connection, many people who have prepared for interviews would be familiar with it. However, when it comes to delving into the question of ‚ÄúWhy does TCP require a three-way handshake to establish a connection?‚Äù most people would not be able to answer this question or might provide incorrect answers. This article will discuss why we need a three-way handshake to establish a TCP connection instead of four or two.&lt;/p&gt;
&lt;h1 id=&#34;overview&#34;&gt;Overview
&lt;/h1&gt;&lt;p&gt;Before analyzing the question at hand, let‚Äôs first address a common misconception that has misled many people regarding the TCP connection process. For a long time, the author of this article also believed that it provided a good explanation for why a TCP connection requires a three-way handshake:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ndash;&amp;gt; Can you hear¬†me?&lt;br&gt;
&amp;lt;&amp;ndash; I can hear you. Can you hear¬†me?&lt;br&gt;
&amp;ndash;&amp;gt; I can hear you¬†too.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Using analogies to explain a problem often leads to a situation where ‚Äúnine out of ten analogies are wrong.‚Äù If someone uses an analogy to answer your ‚Äúwhy‚Äù question, you need to carefully consider the flaws in their analogy. Analogies can only provide a partial similarity, and we can never find an absolutely correct analogy. Analogies are only useful when we want to present the characteristics of something in a simple and understandable way. In the rest of the article, we will explain why this analogy is flawed, and readers can read the remaining content with this question in mind.&lt;/p&gt;
&lt;p&gt;When many people try to answer or think about this question, they tend to focus on the ‚Äúthree‚Äù in the three-way handshake, which is indeed important. However, if we reexamine the question, do we really understand what a ‚Äúconnection‚Äù is? Only when we know the definition of a ‚Äúconnection‚Äù can we attempt to answer why TCP requires a three-way handshake.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream. The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The &lt;a class=&#34;link&#34; href=&#34;https://tools.ietf.org/html/rfc793&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RFC 793‚Ää‚Äî‚ÄäTransmission Control Protocol&lt;/a&gt; document clearly defines what a connection is in TCP. In summary, a connection is the information used to ensure reliability and flow control mechanisms, including sockets, sequence numbers, and window sizes.&lt;/p&gt;
&lt;p&gt;Therefore, establishing a TCP connection means that the two parties involved in communication need to reach a consensus on the three types of information mentioned above. A pair of sockets in a connection is composed of an Internet address identifier and a port. The window size is mainly used for flow control, and the sequence number is used to track the sequence of data packets sent by the initiating party, allowing the receiving party to confirm the successful receipt of a particular data packet based on the sequence number.&lt;/p&gt;
&lt;p&gt;At this point, we have transformed the original question into ‚ÄúWhy do we need a three-way handshake to initialize sockets, window sizes, and initial sequence numbers?‚Äù Next, we will analyze and seek explanations for this refined question.&lt;/p&gt;
&lt;h1 id=&#34;design&#34;&gt;Design
&lt;/h1&gt;&lt;p&gt;This article will mainly discuss why we need a three-way handshake to initialize sockets, window sizes, initial sequence numbers, and establish a TCP connection from the following aspects:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A three-way handshake is required to prevent the initialization of duplicate historical connections.&lt;/li&gt;
&lt;li&gt;A three-way handshake is required to initialize the initial sequence numbers of both communicating parties.&lt;/li&gt;
&lt;li&gt;Discuss the possibility of establishing a connection with a different number of handshakes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Among these arguments, the first one is the primary reason why TCP chooses to use a three-way handshake. The other reasons are secondary in comparison. We discuss them here to provide a more comprehensive perspective and understand this interesting design decision from multiple angles.&lt;/p&gt;
&lt;h1 id=&#34;historical-connections&#34;&gt;Historical Connections
&lt;/h1&gt;&lt;p&gt;The &lt;a class=&#34;link&#34; href=&#34;https://tools.ietf.org/html/rfc793&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RFC 793‚Ää‚Äî‚ÄäTransmission Control Protocol&lt;/a&gt; clearly points out the primary reason why TCP uses a three-way handshake: to prevent confusion caused by the initiation of old duplicate connections.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/6679e5256608619c68d265cab45e3c3c.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img for geeksforgeeks.org&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Imagine this scenario: if the number of communications between the two parties is only two, once the sender sends a connection establishment request, it cannot retract this request. In a complex or poor network condition, if the sender continuously sends multiple connection establishment requests and TCP establishes a connection with only two communications, the receiver can only choose to accept or reject the sender‚Äôs request. The receiver is not sure whether this request is an expired connection due to network congestion.&lt;/p&gt;
&lt;p&gt;Therefore, TCP chooses to use a three-way handshake to establish a connection and introduces the &lt;code&gt;RST&lt;/code&gt; control message. When the receiver receives the request, it sends the sender&amp;rsquo;s &lt;code&gt;SEQ+1&lt;/code&gt; as part of the &lt;code&gt;ACK&lt;/code&gt; control message. At this point, the sender can determine whether the current connection is a historical connection:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the current connection is a historical connection, meaning the &lt;code&gt;SEQ&lt;/code&gt; has expired or timed out, the sender will directly send an &lt;code&gt;RST&lt;/code&gt; control message to terminate this connection.&lt;/li&gt;
&lt;li&gt;If the current connection is not a historical connection, the sender will send an &lt;code&gt;ACK&lt;/code&gt; control message, and the two parties will successfully establish a connection.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By using a three-way handshake and the &lt;code&gt;RST&lt;/code&gt; control message, the ultimate control over whether to establish a connection is given to the sender. Only the sender has enough context to determine if the current connection is erroneous or expired. This is also the primary reason why TCP uses a three-way handshake to establish a connection.&lt;/p&gt;
&lt;h1 id=&#34;initial-sequencenumbers&#34;&gt;Initial Sequence¬†Numbers
&lt;/h1&gt;&lt;p&gt;Another important reason for using a three-way handshake is that both communicating parties need to obtain an initial sequence number for sending information. As a reliable transport layer protocol, TCP needs to build a reliable transport layer in an unstable network environment. The uncertainty of the network can lead to issues such as packet loss and out-of-order delivery. Common problems may include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Data packets being repeatedly sent by the sender, resulting in duplicate data.&lt;/li&gt;
&lt;li&gt;Data packets being lost during transmission due to routing or other network nodes.&lt;/li&gt;
&lt;li&gt;Data packets arriving at the receiver may not be in the order they were sent.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To address these potential issues, the TCP protocol requires the sender to include a ‚Äúsequence number‚Äù field in the data packet. With the sequence number corresponding to each data packet, we can:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The receiver can deduplicate repeated data packets based on the sequence number.&lt;/li&gt;
&lt;li&gt;The sender will resend the corresponding data packet until it is acknowledged.&lt;/li&gt;
&lt;li&gt;The receiver can reorder the data packets based on their sequence numbers.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sequence numbers play a crucial role in TCP connections, and the initial sequence number, as part of a TCP connection, needs to be initialized during the three-way handshake. Since both parties in a TCP connection need to obtain the initial sequence number, they need to send a &lt;code&gt;SYN&lt;/code&gt; control message to each other, carrying their expected initial sequence number &lt;code&gt;SEQ&lt;/code&gt;. Upon receiving the &lt;code&gt;SYN&lt;/code&gt; message, the receiver will confirm it using the &lt;code&gt;ACK&lt;/code&gt; control message and &lt;code&gt;SEQ+1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;As shown in the above diagram, the two TCPs, A and B, send &lt;code&gt;SYN&lt;/code&gt; and &lt;code&gt;ACK&lt;/code&gt; control messages to each other. After both parties obtain their expected initial sequence numbers, they can start communication. Due to the design of the TCP message header, we can combine the two middle communications into one. TCP B can send both the &lt;code&gt;ACK&lt;/code&gt; and &lt;code&gt;SYN&lt;/code&gt; control messages to TCP A simultaneously, reducing the four communications to three.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;A three-way handshake is necessary because sequence numbers are not tied to a global clock in the network, and TCPs may have different mechanisms for picking the ISN‚Äôs. The receiver of the first SYN has no way of knowing whether the segment was an old delayed one or not unless it remembers the last sequence number used on the connection (which is not always possible), and so it must ask the sender to verify this SYN. The three-way handshake and the advantages of a clock-driven scheme are discussed in [3].&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Furthermore, as a distributed system, the network does not have a global clock for counting. TCP can initialize sequence numbers using different mechanisms. As the receiver of a TCP connection, we cannot determine if the initial sequence number received from the other party is expired. Therefore, we need the other party to make this determination. It is not practical for the receiver to save and verify the sequence numbers, which reinforces the point we made in the previous section‚Ää‚Äî‚Ääavoiding the initialization of historical wrong connections.&lt;/p&gt;
&lt;h1 id=&#34;number-of-communications&#34;&gt;Number of Communications
&lt;/h1&gt;&lt;p&gt;When discussing the number of communications required to establish a TCP connection, we often focus on why it takes three communications instead of two or four. Discussing using more communications to establish a connection is often meaningless because we can always ‚Äúexchange the same information using more communications.‚Äù Therefore, it is technically possible to establish a connection using four, five, or even more communications.&lt;/p&gt;
&lt;p&gt;The issue of increasing the number of communications in a TCP connection often does not require discussion. What we pursue is actually completing the information exchange with the fewest number of communications (the theoretical minimum). This is why we repeatedly emphasize in the previous sections that using a ‚Äútwo-way handshake‚Äù cannot establish a TCP connection, and using a three-way handshake is the minimum number of communications required to establish a connection.&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion
&lt;/h1&gt;&lt;p&gt;In this article, we discussed why TCP requires a three-way handshake to establish a connection. Before analyzing this question in detail, we first reconsidered what a TCP connection is. The &lt;a class=&#34;link&#34; href=&#34;https://tools.ietf.org/html/rfc793&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RFC 793‚Ää‚Äî‚ÄäTransmission Control Protocol‚Ää‚Äî‚ÄäIETF Tools&lt;/a&gt; provides a clear definition of a TCP connection‚Ää‚Äî‚Ääthe data used for ensuring reliability and flow control mechanisms, including sockets, sequence numbers, and window sizes.&lt;/p&gt;
&lt;p&gt;The three-way handshake in TCP can effectively prevent the initiation of erroneous historical connections and reduce unnecessary resource consumption for both communicating parties. The three-way handshake helps both parties obtain the initial sequence numbers, ensuring that data packets are transmitted without duplication or loss and maintaining their order. At this point, it is clear why ‚Äútwo-way handshake‚Äù and ‚Äúfour-way handshake‚Äù are not used:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;‚ÄúTwo-way handshake‚Äù: It cannot prevent the initialization of erroneous historical connections and wastes resources for the receiver.&lt;/li&gt;
&lt;li&gt;‚ÄúFour-way handshake‚Äù: The design of the TCP protocol allows us to simultaneously transmit both the &lt;code&gt;ACK&lt;/code&gt; and &lt;code&gt;SYN&lt;/code&gt; control messages, reducing the number of communications. Therefore, there is no need to use more communications to transmit the same information.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Returning to the question raised at the beginning of the article, why is using an analogy to explain TCP‚Äôs three-way handshake incorrect? This is mainly because the analogy does not clearly explain the core issue‚Ää‚Äî‚Ääavoiding the initialization of historical duplicate connections.&lt;/p&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://tools.ietf.org/html/rfc793&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RFC 793‚Ää‚Äî‚ÄäTransmission Control Protocol‚Ää‚Äî‚ÄäIETF Tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://networkengineering.stackexchange.com/questions/24068/why-do-we-need-a-3-way-handshake-why-not-just-2-way&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Why do we need a 3-way handshake? Why not just 2-way?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/tcp-3-way-handshake-process/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;# TCP 3-Way Handshake Process&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Why Does It Take Four Waves For TCP To Disconnect?</title>
        <link>https://huizhou92.com/p/why-does-it-take-four-waves-for-tcp-to-disconnect/</link>
        <pubDate>Thu, 01 Feb 2024 11:11:00 +0000</pubDate>
        
        <guid>https://huizhou92.com/p/why-does-it-take-four-waves-for-tcp-to-disconnect/</guid>
        <description>&lt;p&gt;TCP protocol is one of the network protocols we use in our daily lives. It is responsible for establishing and terminating connections. In the &lt;a class=&#34;link&#34; href=&#34;https://levelup.gitconnected.com/why-tcp-requires-three-handshakes-to-establish-a-connection-31d814aac6b8&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;previous&lt;/a&gt; blog post, we analyzed why TCP requires three handshakes to establish a connection. When establishing a connection, we need to ensure the issues of historical connections and sequence numbers. Unlike the three-way handshake during connection establishment, disconnecting a TCP connection requires a four-way handshake. This article will explore why TCP disconnects require a four-way handshake instead of three or any other number.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This article is first published in the medium MPP plan. If you are a medium user, please follow me in &lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;medium&lt;/a&gt;. Thank you very much.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/db19965682f215f42c5a8a03cd7f7b76.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Material from: history-computer.com&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;overview&#34;&gt;Overview
&lt;/h1&gt;&lt;p&gt;Before delving into why a four-way handshake is necessary, let‚Äôs first understand the process of TCP connection termination. Typically, when one party in the communication decides to terminate the connection, it sends a FIN (Finish) control message to the other party, indicating that it has no more data to send. The receiving party responds with an ACK (Acknowledgment) control message to acknowledge and enters a half-closed state, indicating that it will no longer send data but can still receive data. When the other party also has no more data to send, it sends a FIN message to indicate its intention to disconnect. The receiving party then sends another ACK message to confirm, and only then will the connection be fully closed.&lt;br&gt;
&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/b2b3a5d3921acfa31d009eab0f48e139.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;The Four-Way Handshake ProcessÔºà geeksforgeeks.org Ôºâ&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;design&#34;&gt;Design
&lt;/h1&gt;&lt;p&gt;Why does TCP disconnect require a four-way handshake? Let‚Äôs analyze this question from several aspects:&lt;/p&gt;
&lt;h1 id=&#34;ensuring-data-integrity&#34;&gt;Ensuring Data Integrity
&lt;/h1&gt;&lt;p&gt;TCP is a connection-oriented reliable transport protocol that guarantees data reliability and integrity. During connection termination, both parties may still have unsent or unacknowledged data packets. If only a three-way handshake is performed, the other party may not know whether the FIN message it sent has been received during the final handshake. This could result in the other party not fully receiving the data, leading to data loss. Therefore, by performing a four-way handshake, both parties can ensure that they receive each other‚Äôs data completely and maintain data integrity.&lt;/p&gt;
&lt;h1 id=&#34;handling-network-latency-and-packetloss&#34;&gt;Handling Network Latency and Packet¬†Loss
&lt;/h1&gt;&lt;p&gt;In a network, data packets may be delayed or lost due to network latency or packet loss. During connection termination, if only a three-way handshake is performed, the other party may not know whether the FIN message it sent has been received, which may prevent timely closure of the connection. By performing a four-way handshake, sufficient time is provided for the network to handle latency and packet loss issues, ensuring that the connection can be properly closed.&lt;/p&gt;
&lt;h1 id=&#34;waiting-for-unsent-data-to-besent&#34;&gt;Waiting for Unsent Data to be¬†Sent
&lt;/h1&gt;&lt;p&gt;During connection termination, both parties may still have unsent data packets. If only a three-way handshake is performed, the other party may not know whether there is any unsent data before sending the FIN message. By performing a four-way handshake, both parties have enough time to send and receive the remaining data, ensuring data integrity and correctness.&lt;/p&gt;
&lt;h1 id=&#34;handling-the-half-closed-state&#34;&gt;Handling the Half-Closed State
&lt;/h1&gt;&lt;p&gt;During the TCP connection termination process, one party enters a half-closed state by sending a FIN message, indicating that it will no longer send data but can still receive data. If only a three-way handshake is performed, the other party will immediately close the connection upon receiving the FIN message, which may prevent proper handling of the half-closed state. By performing a four-way handshake, both parties can ensure the correct handling of the half-closed state, avoiding data loss and confusion.&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion
&lt;/h1&gt;&lt;p&gt;Based on the analysis above, we can conclude that a four-way handshake is necessary for TCP disconnection to ensure data integrity, handle network latency and packet loss, wait for unsent data to be sent, and handle the half-closed state. Through the four-way handshake, both parties can better coordinate and handle the disconnection, ensuring the correct transmission of data and secure closure of the connection.&lt;/p&gt;
&lt;p&gt;When discussing TCP disconnection, we should not focus on why a four-way handshake is used, but rather understand why multiple handshakes are needed to ensure data integrity and proper connection closure. By gaining a deep understanding of TCP protocol design, we can better apply and comprehend the principles and mechanisms of network communication.&lt;/p&gt;
&lt;p&gt;Whether it is three handshakes or four handshakes, the first element of a tcp connection to consider is always security and data integrity, although it seems that three handshakes and four handshakes seem to be very inefficient, but the vast majority of Internet traffic is based on the tcp protocol, which is enough to prove that its reliability, on the issue of performance, there are other ways to optimize the performance of the protocol, such as udp, and later on, we will analyze how UDP and UDP-based QUIC protocol will affect the Internet in the next ten years. and how the UDP-based QUIC protocol will influence the next decade of the Internet.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;If you found my article enjoyable, feel free to follow me and give it a üëè. Your support would be greatly appreciated.&lt;/p&gt;
&lt;h1 id=&#34;references&#34;&gt;References
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://tools.ietf.org/html/rfc793&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RFC 793‚Ää‚Äî‚ÄäTransmission Control Protocol‚Ää‚Äî‚ÄäIETF Tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://networkengineering.stackexchange.com/questions/24072/why-do-we-need-a-4-way-handshake-to-terminate-a-tcp-connection&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Why do we need a 4-way handshake to terminate a TCP connection?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/why-tcp-connect-termination-need-4-way-handshake&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;why-tcp-connect-termination-need-4-way-handshake&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        
    </channel>
</rss>
