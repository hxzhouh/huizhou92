<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Linux on huizhou92&#39;s Blog</title>
        <link>https://huizhou92.com/tags/linux/</link>
        <description>Recent content in Linux on huizhou92&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>Copyright © 2023 huizhou92</copyright>
        <lastBuildDate>Mon, 02 Dec 2024 15:44:12 +0800</lastBuildDate><atom:link href="https://huizhou92.com/tags/linux/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Debunking the Misconception: Maximum Number of TCP Connections on a Server</title>
        <link>https://huizhou92.com/p/debunking-the-misconception-maximum-number-of-tcp-connections-on-a-server/</link>
        <pubDate>Mon, 02 Dec 2024 15:44:12 +0800</pubDate>
        
        <guid>https://huizhou92.com/p/debunking-the-misconception-maximum-number-of-tcp-connections-on-a-server/</guid>
        <description>&lt;img src="https://images.hxzhouh.com/blog-images/2024/12/5a04e98368531b4e0208f40a907399f0.png" alt="Featured image of post Debunking the Misconception: Maximum Number of TCP Connections on a Server" /&gt;&lt;h2 id=&#34;introduction&#34;&gt;Introduction
&lt;/h2&gt;&lt;p&gt;There&amp;rsquo;s a widespread misconception:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Since TCP port numbers are 16-bit unsigned integers with a maximum value of 65535, a single server can support at most 65536 TCP socket connections.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Even experienced network programmers may believe this conclusion to be proper. Let&amp;rsquo;s debunk this myth using both theoretical and practical perspectives.&lt;/p&gt;
&lt;!-- more--&gt;
&lt;h2 id=&#34;theoretical-analysis&#34;&gt;Theoretical Analysis
&lt;/h2&gt;&lt;p&gt;In &lt;code&gt;*nix&lt;/code&gt; systems, each TCP connection is uniquely identified by a &lt;strong&gt;4-tuple&lt;/strong&gt; structure: &lt;code&gt;{local_ip, local_port, remote_ip, remote_port}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For IPv4, the system can theoretically manage up to &lt;code&gt;2^(32 + 16 + 32 + 16)&lt;/code&gt; connections—equivalent to &lt;code&gt;2^96&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;IPv4 can be viewed as a 32-bit unsigned number.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;breaking-down-the-4-tuple-limits&#34;&gt;Breaking Down the 4-Tuple Limits
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;A single server typically uses only one &lt;code&gt;local_ip&lt;/code&gt;&lt;/strong&gt;, meaning the server could theoretically manage &lt;code&gt;2^(16 + 32 + 16)&lt;/code&gt; connections.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A single service (e.g., an Nginx process) usually listens on one &lt;code&gt;local_port&lt;/code&gt;&lt;/strong&gt;, which reduces the capacity further to &lt;code&gt;2^(32 + 16)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;If one remote machine (client) connects to a server&lt;/strong&gt;, fixing &lt;code&gt;local_ip&lt;/code&gt;, &lt;code&gt;local_port&lt;/code&gt;, and &lt;code&gt;remote_ip&lt;/code&gt; leaves only the &lt;code&gt;remote_port&lt;/code&gt; variable. Since the &lt;code&gt;remote_port&lt;/code&gt; range is 16-bit, there are only &lt;code&gt;2^16 = 65536&lt;/code&gt; possible connections from a single client to a specific server endpoint.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This limitation is the root of the &lt;strong&gt;classic misunderstanding&lt;/strong&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For protocols beyond TCP (like UDP), the tuple expands to include the protocol type, making it a 5-tuple, adding even more possibilities.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The actual limits for a server depend on factors beyond the tuple structure.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;practical-limitations&#34;&gt;Practical Limitations
&lt;/h2&gt;&lt;h3 id=&#34;file-descriptors&#34;&gt;File Descriptors
&lt;/h3&gt;&lt;p&gt;In Linux, everything is treated as a file, and sockets are no exception. The number of file descriptors determines the maximum number of simultaneous TCP connections.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Maximum file descriptors supported by the system:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;root@test1 ~&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;# cat /proc/sys/fs/file-max&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;m&#34;&gt;1616352&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Maximum file descriptors per process:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;root@test1 ~&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;# ulimit -n&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;m&#34;&gt;1024&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Both values can be modified. For instance, during stress testing, these limits are often increased manually.&lt;/p&gt;
&lt;h3 id=&#34;ip_local_port_range&#34;&gt;ip_local_port_range
&lt;/h3&gt;&lt;p&gt;When a client connects to the same TCP endpoint (&lt;code&gt;ip:port&lt;/code&gt;), each connection requires a unique local TCP endpoint. For clients with a single IP, the available local ports determine the connection limit.&lt;/p&gt;
&lt;p&gt;On &lt;code&gt;*nix&lt;/code&gt; systems, the default local port range is typically from &lt;code&gt;32768&lt;/code&gt; to &lt;code&gt;61000&lt;/code&gt;. Check this range using:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;root@test1 ~&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;# cat /proc/sys/net/ipv4/ip_local_port_range&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;m&#34;&gt;32768&lt;/span&gt;    &lt;span class=&#34;m&#34;&gt;60999&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;This means a single client can establish around &lt;strong&gt;30,000 connections&lt;/strong&gt; to the same server endpoint during stress tests.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Operating systems automatically reuse local ports if multiple distinct remote endpoints (ip:port) are involved.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;memory--cpu&#34;&gt;Memory &amp;amp; CPU
&lt;/h3&gt;&lt;p&gt;Each TCP socket in the &lt;code&gt;ESTABLISHED&lt;/code&gt; state consumes approximately &lt;strong&gt;3.3 KB of memory&lt;/strong&gt;. While CPU usage for idle connections is minimal, the server&amp;rsquo;s memory capacity significantly impacts the total number of connections.&lt;/p&gt;
&lt;p&gt;In practice, hardware resources like memory and CPU limit the maximum number of TCP connections a server can handle, long before reaching the theoretical &lt;code&gt;4-tuple&lt;/code&gt; limit.&lt;br&gt;
&lt;img src=&#34;https://images.hxzhouh.com/blog-images/2024/12/87f4a2f2de8879668f10358d0cb3effc.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2^96 is too bigger&#34;
	
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary
&lt;/h2&gt;&lt;p&gt;The maximum number of TCP connections a server can support is an astronomical &lt;code&gt;2^96&lt;/code&gt;. However, practical constraints like memory, CPU, file descriptors, and port availability impose far lower limits.&lt;/p&gt;
&lt;p&gt;There&amp;rsquo;s no universal number; the limit depends on hardware, configuration, and workload.&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;The background Photo by &lt;a class=&#34;link&#34; href=&#34;https://unsplash.com/@alinnnaaaa?utm_source=medium&amp;amp;utm_medium=referral&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Alina Grubnyak&lt;/a&gt; on &lt;a class=&#34;link&#34; href=&#34;https://unsplash.com/?utm_source=medium&amp;amp;utm_medium=referral&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Unsplash&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>11 Tips for Detecting and Responding to Intrusions on Linux</title>
        <link>https://huizhou92.com/p/11-tips-for-detecting-and-responding-to-intrusions-on-linux/</link>
        <pubDate>Fri, 10 May 2024 09:31:00 +0000</pubDate>
        
        <guid>https://huizhou92.com/p/11-tips-for-detecting-and-responding-to-intrusions-on-linux/</guid>
        <description>&lt;img src="https://images.yixiao9206.cn/blog-images/2024/05/8a6d3ceaf014801bc93c355d1e164d4e.png" alt="Featured image of post 11 Tips for Detecting and Responding to Intrusions on Linux" /&gt;&lt;p&gt;With the increasing popularity of open-source products, it is crucial for a backend engineer to be able to clearly identify whether an abnormal machine has been compromised. Based on my personal work experience, I have compiled several common scenarios of machines being hacked for reference.&lt;/p&gt;
&lt;!--more --&gt;
&lt;blockquote&gt;
&lt;p&gt;This article is first published in the medium MPP plan. If you are a medium user, please follow me in &lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;medium&lt;/a&gt;. Thank you very much.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;style type=&#34;text/css&#34;&gt;
     
    .notice {
        --title-color: #fff;
        --title-background-color: #6be;
        --content-color: #444;
        --content-background-color: #e7f2fa;
    }

    .notice.info {
        --title-background-color: #fb7;
        --content-background-color: #fec;
    }

    .notice.tip {
        --title-background-color: #5a5;
        --content-background-color: #efe;
    }

    .notice.warning {
        --title-background-color: #c33;
        --content-background-color: #fee;
    }

     
    @media (prefers-color-scheme:dark) {
        .notice {
            --title-color: #fff;
            --title-background-color: #069;
            --content-color: #ddd;
            --content-background-color: #023;
        }

        .notice.info {
            --title-background-color: #a50;
            --content-background-color: #420;
        }

        .notice.tip {
            --title-background-color: #363;
            --content-background-color: #121;
        }

        .notice.warning {
            --title-background-color: #800;
            --content-background-color: #400;
        }
    }

    body.dark .notice {
        --title-color: #fff;
        --title-background-color: #069;
        --content-color: #ddd;
        --content-background-color: #023;
    }

    body.dark .notice.info {
        --title-background-color: #a50;
        --content-background-color: #420;
    }

    body.dark .notice.tip {
        --title-background-color: #363;
        --content-background-color: #121;
    }

    body.dark .notice.warning {
        --title-background-color: #800;
        --content-background-color: #400;
    }

     
    .notice {
        padding: 18px;
        line-height: 24px;
        margin-bottom: 24px;
        border-radius: 4px;
        color: var(--content-color);
        background: var(--content-background-color);
    }

    .notice p:last-child {
        margin-bottom: 0
    }

     
    .notice-title {
        margin: -18px -18px 12px;
        padding: 4px 18px;
        border-radius: 4px 4px 0 0;
        font-weight: 700;
        color: var(--title-color);
        background: var(--title-background-color);
    }

     
    .icon-notice {
        display: inline-flex;
        align-self: center;
        margin-right: 8px;
    }

    .icon-notice img,
    .icon-notice svg {
        height: 1em;
        width: 1em;
        fill: currentColor;
    }

    .icon-notice img,
    .icon-notice.baseline svg {
        top: .125em;
        position: relative;
    }
&lt;/style&gt;&lt;div class=&#34;notice tips&#34; &gt;
    &lt;p class=&#34;notice-title&#34;&gt;
        &lt;span class=&#34;icon-notice baseline&#34;&gt;
            
        &lt;/span&gt;&lt;/p&gt;&lt;p&gt;The following scenarios are observed on CentOS systems and are similar for other Linux distributions.&lt;/p&gt;&lt;/div&gt;

&lt;h2 id=&#34;1-intruders-may-delete-machine-logs&#34;&gt;1. Intruders May Delete Machine Logs
&lt;/h2&gt;&lt;p&gt;Check if log information still exists or has been cleared using the following commands:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/42e92e989d964542c270e2815bde6619.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Image&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-intruders-may-create-a-new-file-for-storing-usernames-and-passwords&#34;&gt;2. Intruders May Create a New File for Storing Usernames and Passwords
&lt;/h2&gt;&lt;p&gt;Check &lt;code&gt;/etc/passwd&lt;/code&gt; and &lt;code&gt;/etc/shadow&lt;/code&gt; files for any alterations using the following commands:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/e239d400fade65005ac316954e70fac8.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20240510085544&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-intruders-may-modify-usernames-and-passwords&#34;&gt;3. Intruders May Modify Usernames and Passwords
&lt;/h2&gt;&lt;p&gt;Examine the contents of &lt;code&gt;/etc/passwd&lt;/code&gt; and &lt;code&gt;/etc/shadow&lt;/code&gt; files for any changes using the following commands:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/b757b1e52c23abf2d352d480cbdfe85d.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20240510085559&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-check-recent-successful-and-last-unsuccessful-login-events-on-the-machine&#34;&gt;4. Check Recent Successful and Last Unsuccessful Login Events on the Machine
&lt;/h2&gt;&lt;p&gt;Refer to the log &amp;ldquo;/var/log/lastlog&amp;rdquo; using the following commands:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/ed0004d926cf0e1d7289d2437c25be21.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20240510085611&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;5-use-who-to-view-all-currently-logged-in-users-on-the-machine&#34;&gt;5. Use &lt;code&gt;who&lt;/code&gt; to View All Currently Logged-in Users on the Machine
&lt;/h2&gt;&lt;p&gt;Refer to the log file &amp;ldquo;/var/run/utmp&amp;rdquo;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/f9f029a7bdbba6d3b2ed542885c9dd75.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20240510085623&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;6-use-last-to-view-users-logged-in-since-machine-creation&#34;&gt;6. Use &lt;code&gt;last&lt;/code&gt; to View Users Logged in Since Machine Creation
&lt;/h2&gt;&lt;p&gt;Refer to the log file &amp;ldquo;/var/log/wtmp&amp;rdquo;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/e1173e24b413d89a811a138ea74dcef2.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20240510085717&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;7-use-ac-to-view-connection-time-in-hours-for-all-users-on-the-machine&#34;&gt;7. Use &lt;code&gt;ac&lt;/code&gt; to View Connection Time (in Hours) for All Users on the Machine
&lt;/h2&gt;&lt;p&gt;Refer to the log file &amp;ldquo;/var/log/wtmp&amp;rdquo;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/1c311e4b87e54606127029433b6ecb6f.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20240510085812&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;8-if-abnormal-traffic-is-detected&#34;&gt;8. If Abnormal Traffic is Detected
&lt;/h2&gt;&lt;p&gt;Use &amp;ldquo;tcpdump&amp;rdquo; to capture network packets or &amp;ldquo;iperf&amp;rdquo; to check traffic.&lt;/p&gt;
&lt;h2 id=&#34;9-review-the-varlogsecure-log-file&#34;&gt;9. Review the &lt;code&gt;/var/log/secure&lt;/code&gt; Log File
&lt;/h2&gt;&lt;p&gt;Attempt to identify information about intruders using the following commands:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/6dd9205f9ffcab13df215be22965c6dd.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20240510085837&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;10-identify-scripts-executed-by-abnormal-processes&#34;&gt;10. Identify Scripts Executed by Abnormal Processes
&lt;/h2&gt;&lt;p&gt;a. Use the &lt;code&gt;top&lt;/code&gt; command to view the PID of abnormal processes:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/38f534f788f32154517ab65359f3e9c9.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20240510085848&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;b. Search for the executable file of the process in the virtual file system directory:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/afb05ea6f7a54b5f129b365623fbccba.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20240510085857&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;11-file-recovery-after-confirming-intrusion-and-deletion-of-important-files&#34;&gt;11. File Recovery After Confirming Intrusion and Deletion of Important Files
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;When a process opens a file, even if it&amp;rsquo;s deleted, it remains on the disk as long as the process keeps it open. To recover such files, use &lt;code&gt;lsof&lt;/code&gt; from the &lt;code&gt;/proc&lt;/code&gt; directory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Most &lt;code&gt;lsof&lt;/code&gt; information is stored in directories named after the process&amp;rsquo;s PID, such as &lt;code&gt;/proc/1234&lt;/code&gt;, containing information for PID 1234. Each process directory contains various files providing insight into the process&amp;rsquo;s memory space, file descriptor list, symbolic links to files on disk, and other system information. &lt;code&gt;lsof&lt;/code&gt; uses this and other kernel internal state information to generate its output.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Using the information above, you can retrieve the data by examining &lt;code&gt;/proc/&amp;lt;PID&amp;gt;/fd/&amp;lt;descriptor&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, to recover &lt;code&gt;/var/log/secure&lt;/code&gt;, follow these steps:&lt;/p&gt;
&lt;p&gt;a. Check &lt;code&gt;/var/log/secure&lt;/code&gt;, confirming its absence:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/6c18c569526d125bae3f25506cd5ec33.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20240510085921&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;b. Use &lt;code&gt;lsof&lt;/code&gt; to check if any process is currently accessing &lt;code&gt;/var/log/secure&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/8461eb12150d46a0207768619be58e61.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20240510085930&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;c. From the information above, PID 1264 (rsyslogd) has opened the file with a file descriptor of 4. It&amp;rsquo;s marked as deleted. Therefore, you can check the corresponding information in &lt;code&gt;/proc/1264/fd/4&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/4f325beddb0b3eda8e6ba836f8ec3ad7.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20240510085938&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;d. You can recover the data by redirecting it to a file using I/O redirection:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/5c36a1b092df4eacf143d1171a19d651.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20240510085950&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;e. Confirm the existence of &lt;code&gt;/var/log/secure&lt;/code&gt; again. This method is particularly useful for many applications, especially log files and databases.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/05/46b775fce5dcc17d6114c49eb060460b.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20240510090000&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;The above is the method I summarized for dealing with Linux intrusion. It can generally handle most problems. If you encounter an unresolved issue, it is best to seek advice from a professional IT operations and maintenance engineer.&lt;/p&gt;
&lt;p&gt;I may not have written it completely correctly, so if you have different opinions, please leave a comment and let me know.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>The Time In The Computers, Context Switching</title>
        <link>https://huizhou92.com/p/the-time-in-the-computers-context-switching/</link>
        <pubDate>Fri, 15 Mar 2024 12:48:15 +0000</pubDate>
        
        <guid>https://huizhou92.com/p/the-time-in-the-computers-context-switching/</guid>
        <description>&lt;img src="https://miro.medium.com/v2/resize:fit:4800/format:webp/0*3q_OdOTK2k1i1R3j" alt="Featured image of post The Time In The Computers, Context Switching" /&gt;&lt;p&gt;Process is one of the great inventions of the operating system, which shields application programs from hardware details such as CPU scheduling and memory management, abstracting the concept of a process, allowing applications to focus on implementing their own business logic, and &amp;ldquo;simultaneously&amp;rdquo; performing many tasks on a limited CPU. However, while it brings convenience to users, it also introduces some additional overhead. As shown in the figure below, during the running time of a process, although the CPU is busy, it does not complete any user work, which is the additional overhead brought by the process mechanism.&lt;br&gt;
&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/03/e1fd29a84d212fe4c9161eaa7edda593.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20240319113416&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This article is first published in the medium MPP plan. If you are a medium user, please follow me in &lt;a class=&#34;link&#34; href=&#34;https://medium.huizhou92.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;medium&lt;/a&gt;. Thank you very much.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;During the process switch from process A to process B, first save the context of process A so that when A resumes running, it knows what the next instruction of process A is. Then, restore the context of process B to the register. This process is called a context switch. The context switch overhead is not significant in scenarios with few processes and infrequent switches. However, now the Linux operating system is used in high-concurrency network backend servers. When a single machine supports thousands of user requests, this overhead needs to be addressed. Because user processes are blocked by network I/O such as Redis, Mysql data, or when the process time slice is up, it will trigger a context switch.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.yixiao9206.cn/blog-images/2024/03/1412e8c9d5f8d443e04acce317ec68f3.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pasted image 20240319112652&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;a-simple-experiment-on-process-context-switch-overhead&#34;&gt;A Simple Experiment on Process Context Switch Overhead
&lt;/h1&gt;&lt;p&gt;Without further ado, let&amp;rsquo;s conduct an experiment to see how long it takes for a context switch! The experimental method is to create two processes and transfer a token between them. One process will be blocked when reading the token, and the other process will be blocked when waiting for its return. After back-and-forth transmission for a certain number of times, we can then calculate their average single-switch time overhead.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gist.github.com/hxzhouh/7c201a16f6dc37068fa9eefae9334b04&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;test04&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# gcc main.c -o main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# ./main./main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Before Context Switch Time1565352257 s, &lt;span class=&#34;m&#34;&gt;774767&lt;/span&gt; us
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;After Context SWitch Time1565352257 s, &lt;span class=&#34;m&#34;&gt;842852&lt;/span&gt; us
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;The time for each execution may vary, but &lt;strong&gt;the average time for each context switch is around 3.5 microseconds&lt;/strong&gt;. Of course, this number varies depending on the machine, and it is recommended to test it on real hardware.&lt;/p&gt;
&lt;p&gt;When we tested system calls earlier, the minimum value was 200 nanoseconds. It can be seen that the context switch overhead is greater than the system call overhead. While a system call only switches from user mode to kernel mode within the process and then switches back, a context switch directly switches from process A to process B. Obviously, this context switch requires more work to be done.&lt;/p&gt;
&lt;h1 id=&#34;types-of-overhead-in-process-context-switching&#34;&gt;Types of Overhead in Process Context Switching
&lt;/h1&gt;&lt;p&gt;So what specific CPU overheads are involved in context switching? Overheads can be divided into two types: direct overhead and indirect overhead.&lt;/p&gt;
&lt;p&gt;Direct overhead includes tasks that the CPU must perform during the switch, including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;Switching the page table global directory.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Switching the kernel stack.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Switching hardware contexts (all data to be loaded into registers before the process resumes, collectively referred to as hardware context)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ip(instruction pointer): points to the next instruction being executed&lt;/li&gt;
&lt;li&gt;bp(base pointer): used to store the stack bottom address of the executing function&amp;rsquo;s stack frame&lt;/li&gt;
&lt;li&gt;sp(stack pointer): used to store the stack top address of the executing function&amp;rsquo;s stack frame&lt;/li&gt;
&lt;li&gt;cr3: Page Directory Base Register, stores the physical address of the page directory table&lt;/li&gt;
&lt;li&gt;&amp;hellip;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Refreshing TLB.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Execution of the system scheduler&amp;rsquo;s code.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Indirect overhead mainly refers to the fact that when switching to a new process, due to various caches not being hot, the speed of execution will be slower. If the process is always scheduled on the same CPU, it&amp;rsquo;s somewhat better, but if it crosses CPUs, the previously warmed TLB, L1, L2, L3 caches become useless because the running process has changed, leading to more memory IO penetrations for the new process. In fact, our previous experiment did not measure this situation well, so the actual context switch overhead may be greater than 3.5 microseconds.&lt;br&gt;
For students who want to understand the detailed operation process, please refer to Chapter 3 and Chapter 9 of &amp;ldquo;Understanding the Linux Kernel.&amp;rdquo;&lt;/p&gt;
&lt;h2 id=&#34;a-more-professional-testing-tool---lmbench&#34;&gt;A More Professional Testing Tool - lmbench
&lt;/h2&gt;&lt;p&gt;lmbench is an open-source benchmark for evaluating system performance on multiple platforms, which can test various aspects of performance including document reading and writing, memory operations, process creation and destruction overhead, and networking. The usage is simple, but it runs a bit slow. Interested students can try it out themselves.&lt;br&gt;
The advantage of this tool is that it conducts multiple experiments, each with 2 processes, 8 processes, and 16 processes. The size of data used by each process also varies, fully simulating the impact of cache misses. I used it for testing and the results are as follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-------------------------------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Host                 OS  2p/0K 2p/16K 2p/64K 8p/16K 8p/64K 16p/16K 16p/64K  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                         ctxsw  ctxsw  ctxsw ctxsw  ctxsw   ctxsw   ctxsw  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;--------- ------------- ------ ------ ------ ------ ------ ------- -------  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;bjzw_46_7 Linux 2.6.32- 2.7800 2.7800 2.7000 4.3800 4.0400 4.75000 5.48000
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;lmbench shows that the process context switch time ranges from 2.7 microseconds to 5.48 microseconds.&lt;/p&gt;
&lt;h1 id=&#34;thread-context-switching-time&#34;&gt;Thread Context Switching Time
&lt;/h1&gt;&lt;p&gt;Previously, we tested the overhead of process context switching, now let&amp;rsquo;s continue to test threads in Linux. Let&amp;rsquo;s see if threads can be faster than processes, and if so, how much faster.&lt;/p&gt;
&lt;p&gt;In Linux, there are actually no threads, but just to cater to developers&amp;rsquo; taste, a lightweight process was created and called a thread. Like processes, lightweight processes also have their own independent task_struct process descriptors and their own independent PIDs. From the perspective of the operating system, there is no difference in scheduling between threads and processes; they are just selecting a task_struct from the waiting queue to switch to the running state. The only difference between lightweight processes and regular processes is that lightweight processes can share the same memory address space, code segment, global variables, and the same set of open files.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For threads in the same process, the PID seen by &lt;code&gt;getpid()&lt;/code&gt; is actually the same, but there is a &lt;code&gt;tgid&lt;/code&gt; field in the task_struct. For multi-threaded programs, what &lt;code&gt;getpid()&lt;/code&gt; system call actually gets is this &lt;code&gt;tgid&lt;/code&gt;, so multiple threads belonging to&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;the same process appear to have the same PID.&lt;/p&gt;
&lt;p&gt;We&amp;rsquo;ll use an experiment to test this &lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/0d90b92000c0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;test06&lt;/a&gt;. The principle is similar to the process test. We create 20 threads and use a pipe to pass signals between them. When a signal is received, it will wake up, then pass the signal to the next thread, and sleep by itself. In this experiment, we separately considered the additional overhead of passing signals through the pipe and calculated it in the first step.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-css&#34; data-lang=&#34;css&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;gcc&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;-lpthread&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;-o&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;508250&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;363495&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;The results may vary each time, and the above results are averages of multiple runs. The approximate time for each thread switch is around 3.8 microseconds. &lt;strong&gt;From the perspective of context switch time, Linux threads (lightweight processes) are actually not much different from processes&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&#34;linux-related-commands&#34;&gt;Linux Related Commands
&lt;/h2&gt;&lt;p&gt;Now that we know the CPU time consumed by context switching, how can we check how many switches are happening in Linux? If context switches are affecting the overall system performance, is there a way to identify problematic processes and optimize them?&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# vmstat 1  &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;      &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;595504&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;5724&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;190884&lt;/span&gt;    &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;    &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;295&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;297&lt;/span&gt;    &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;    &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;14&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;6&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;75&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;m&#34;&gt;5&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;      &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;593016&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;5732&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;193288&lt;/span&gt;    &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;    &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;     &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;    &lt;span class=&#34;m&#34;&gt;92&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;19889&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;29104&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;20&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;6&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;67&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;7&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;      &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;591292&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;5732&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;195476&lt;/span&gt;    &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;    &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;     &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;     &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;20151&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;28487&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;20&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;6&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;66&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;8&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;      &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;589296&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;5732&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;196800&lt;/span&gt;    &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;    &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;116&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;384&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;19326&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;27693&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;20&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;7&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;67&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;7&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;      &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;586956&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;5740&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;199496&lt;/span&gt;    &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;    &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;216&lt;/span&gt;    &lt;span class=&#34;m&#34;&gt;24&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;18321&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;24018&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;22&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;8&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;62&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;or&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# sar -w 1  &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;proc/s  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     Total number of tasks created per second.  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cswch/s  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     Total number of context switches per second.  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11:19:20 AM    proc/s   cswch/s  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11:19:21 AM    110.28  23468.22  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11:19:22 AM    128.85  33910.58  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11:19:23 AM     47.52  40733.66  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11:19:24 AM     35.85  30972.64  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11:19:25 AM     47.62  24951.43  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11:19:26 AM     47.52  42950.50  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;......
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;The above environment is a production machine with a configuration of 8 cores and 8GB of KVM virtual machine, running nginx+fpm. There are about 100 user interface requests processed per second on average. The &lt;strong&gt;cs column&lt;/strong&gt; in the above output indicates the number of context switches that occurred in 1 second, and it&amp;rsquo;s about 40,000 times per second. Roughly estimating, each core needs to switch about 5,000 times per second, which means nearly 20 milliseconds are spent on context switching per second. Considering this is a virtual machine, there are some additional overheads in virtualization, and it also consumes CPU for user interface logic processing, system call kernel logic processing, networking, and soft interrupt processing, so a 20ms overhead is not low.&lt;br&gt;
So, further, let&amp;rsquo;s see which processes are causing frequent context switches?&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# pidstat -w 1  &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11:07:56 AM       PID   cswch/s nvcswch/s  Command
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11:07:56 AM     &lt;span class=&#34;m&#34;&gt;32316&lt;/span&gt;      4.00      0.00  php-fpm  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11:07:56 AM     &lt;span class=&#34;m&#34;&gt;32508&lt;/span&gt;    160.00     34.00  php-fpm  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11:07:56 AM     &lt;span class=&#34;m&#34;&gt;32726&lt;/span&gt;    131.00      8.00  php-fpm  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;......
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Because fpm operates in synchronous blocking mode, most of the switches are voluntary, with fewer involuntary switches occurring only when the time slice expires.&lt;/p&gt;
&lt;p&gt;If you want to see the total context switch situation of a specific process, you can directly check it under the /proc interface, but this is the total value.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;grep ctxt /proc/32583/status  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;voluntary_ctxt_switches:        &lt;span class=&#34;m&#34;&gt;573066&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;nonvoluntary_ctxt_switches:     &lt;span class=&#34;m&#34;&gt;89260&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;We don&amp;rsquo;t need to remember exactly what the context switch does, just remember one conclusion: &lt;strong&gt;the context switch overhead on my working machine is about 2.7-5.48 microseconds&lt;/strong&gt;, you can test it on your own machine using the code or tools I provided.&lt;/li&gt;
&lt;li&gt;You can use &lt;code&gt;vmstat&lt;/code&gt; &lt;code&gt;sar&lt;/code&gt; and other tools to view the context switches of processes and then locate performance issues.&lt;/li&gt;
&lt;li&gt;lmbench is relatively more accurate because it considers the additional overhead caused by cache misses after the switch.&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        
    </channel>
</rss>
